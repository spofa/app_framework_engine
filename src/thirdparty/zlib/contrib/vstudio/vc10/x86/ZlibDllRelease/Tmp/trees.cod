; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\trees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	__dist_code
PUBLIC	__length_code
_static_l_desc DD FLAT:_static_ltree
	DD	FLAT:_extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
_static_d_desc DD FLAT:_static_dtree
	DD	FLAT:_extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
_static_bl_desc DD 00H
	DD	FLAT:_extra_blbits
	DD	00H
	DD	013H
	DD	07H
	ORG $+3
_bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+4
_extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
_extra_blbits DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
_static_ltree DW 0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
_static_dtree DW 00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
__dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
__length_code DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
_base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
_base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\trees.c
;	COMDAT _bi_windup
_TEXT	SEGMENT
_bi_windup PROC						; COMDAT
; _s$ = eax

; 1189 :     if (s->bi_valid > 8) {

  00000	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00006	53		 push	 ebx
  00007	83 f9 08	 cmp	 ecx, 8
  0000a	7e 22		 jle	 SHORT $LN3@bi_windup

; 1190 :         put_short(s, s->bi_buf);

  0000c	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00013	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0001c	ff 40 14	 inc	 DWORD PTR [eax+20]
  0001f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00022	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00025	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  0002c	eb 10		 jmp	 SHORT $LN6@bi_windup
$LN3@bi_windup:

; 1191 :     } else if (s->bi_valid > 0) {

  0002e	85 c9		 test	 ecx, ecx
  00030	7e 12		 jle	 SHORT $LN1@bi_windup

; 1192 :         put_byte(s, (Byte)s->bi_buf);

  00032	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00035	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00038	8a 98 b8 16 00
	00		 mov	 bl, BYTE PTR [eax+5816]
$LN6@bi_windup:
  0003e	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00041	ff 40 14	 inc	 DWORD PTR [eax+20]
$LN1@bi_windup:

; 1193 :     }
; 1194 :     s->bi_buf = 0;

  00044	33 c9		 xor	 ecx, ecx
  00046	66 89 88 b8 16
	00 00		 mov	 WORD PTR [eax+5816], cx

; 1195 :     s->bi_valid = 0;

  0004d	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00053	5b		 pop	 ebx

; 1196 : #ifdef DEBUG
; 1197 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1198 : #endif
; 1199 : }

  00054	c3		 ret	 0
_bi_windup ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _bi_flush
_TEXT	SEGMENT
_bi_flush PROC						; COMDAT
; _s$ = eax

; 1172 :     if (s->bi_valid == 16) {

  00000	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00006	53		 push	 ebx
  00007	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0000a	75 37		 jne	 SHORT $LN3@bi_flush

; 1173 :         put_short(s, s->bi_buf);

  0000c	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00013	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0001c	ff 40 14	 inc	 DWORD PTR [eax+20]
  0001f	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  00026	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00029	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0002f	ff 40 14	 inc	 DWORD PTR [eax+20]

; 1174 :         s->bi_buf = 0;

  00032	33 c9		 xor	 ecx, ecx
  00034	66 89 88 b8 16
	00 00		 mov	 WORD PTR [eax+5816], cx

; 1175 :         s->bi_valid = 0;

  0003b	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00041	5b		 pop	 ebx

; 1180 :     }
; 1181 : }

  00042	c3		 ret	 0
$LN3@bi_flush:

; 1176 :     } else if (s->bi_valid >= 8) {

  00043	83 f9 08	 cmp	 ecx, 8
  00046	7c 27		 jl	 SHORT $LN1@bi_flush

; 1177 :         put_byte(s, (Byte)s->bi_buf);

  00048	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004e	8a 98 b8 16 00
	00		 mov	 bl, BYTE PTR [eax+5816]
  00054	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl

; 1178 :         s->bi_buf >>= 8;

  00057	0f b6 90 b9 16
	00 00		 movzx	 edx, BYTE PTR [eax+5817]
  0005e	ff 40 14	 inc	 DWORD PTR [eax+20]

; 1179 :         s->bi_valid -= 8;

  00061	83 80 bc 16 00
	00 f8		 add	 DWORD PTR [eax+5820], -8 ; fffffff8H
  00068	66 89 90 b8 16
	00 00		 mov	 WORD PTR [eax+5816], dx
$LN1@bi_flush:
  0006f	5b		 pop	 ebx

; 1180 :     }
; 1181 : }

  00070	c3		 ret	 0
_bi_flush ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _bi_reverse
_TEXT	SEGMENT
_bi_reverse PROC					; COMDAT
; _code$ = ecx
; _len$ = edx

; 1158 :     register unsigned res = 0;

  00000	33 c0		 xor	 eax, eax
  00002	56		 push	 esi
$LL3@bi_reverse:

; 1159 :     do {
; 1160 :         res |= code & 1;

  00003	8b f1		 mov	 esi, ecx
  00005	83 e6 01	 and	 esi, 1
  00008	0b c6		 or	 eax, esi

; 1161 :         code >>= 1, res <<= 1;
; 1162 :     } while (--len > 0);

  0000a	4a		 dec	 edx
  0000b	d1 e9		 shr	 ecx, 1
  0000d	03 c0		 add	 eax, eax
  0000f	85 d2		 test	 edx, edx
  00011	7f f0		 jg	 SHORT $LL3@bi_reverse

; 1163 :     return res >> 1;

  00013	d1 e8		 shr	 eax, 1
  00015	5e		 pop	 esi

; 1164 : }

  00016	c3		 ret	 0
_bi_reverse ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _detect_data_type
_TEXT	SEGMENT
_detect_data_type PROC					; COMDAT
; _s$ = esi

; 1123 :     /* black_mask is the bit mask of black-listed bytes
; 1124 :      * set bits 0..6, 14..25, and 28..31
; 1125 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1126 :      */
; 1127 :     unsigned long black_mask = 0xf3ffc07fUL;

  00000	ba 7f c0 ff f3	 mov	 edx, -201342849		; f3ffc07fH

; 1128 :     int n;
; 1129 : 
; 1130 :     /* Check for non-textual ("black-listed") bytes. */
; 1131 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  00005	33 c0		 xor	 eax, eax
  00007	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  0000d	8d 49 00	 npad	 3
$LL10@detect_dat:

; 1132 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00010	f6 c2 01	 test	 dl, 1
  00013	74 06		 je	 SHORT $LN9@detect_dat
  00015	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00019	75 46		 jne	 SHORT $LN15@detect_dat
$LN9@detect_dat:

; 1128 :     int n;
; 1129 : 
; 1130 :     /* Check for non-textual ("black-listed") bytes. */
; 1131 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  0001b	40		 inc	 eax
  0001c	83 c1 04	 add	 ecx, 4
  0001f	d1 ea		 shr	 edx, 1
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	7e ea		 jle	 SHORT $LL10@detect_dat

; 1133 :             return Z_BINARY;
; 1134 : 
; 1135 :     /* Check for textual ("white-listed") bytes. */
; 1136 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1137 :             || s->dyn_ltree[13].Freq != 0)

  00026	66 83 be b8 00
	00 00 00	 cmp	 WORD PTR [esi+184], 0
  0002e	75 34		 jne	 SHORT $LN5@detect_dat
  00030	66 83 be bc 00
	00 00 00	 cmp	 WORD PTR [esi+188], 0
  00038	75 2a		 jne	 SHORT $LN5@detect_dat
  0003a	66 83 be c8 00
	00 00 00	 cmp	 WORD PTR [esi+200], 0
  00042	75 20		 jne	 SHORT $LN5@detect_dat

; 1139 :     for (n = 32; n < LITERALS; n++)

  00044	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00049	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  0004f	90		 npad	 1
$LL4@detect_dat:

; 1140 :         if (s->dyn_ltree[n].Freq != 0)

  00050	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00054	75 0e		 jne	 SHORT $LN5@detect_dat

; 1139 :     for (n = 32; n < LITERALS; n++)

  00056	40		 inc	 eax
  00057	83 c1 04	 add	 ecx, 4
  0005a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005f	7c ef		 jl	 SHORT $LL4@detect_dat
$LN15@detect_dat:

; 1141 :             return Z_TEXT;
; 1142 : 
; 1143 :     /* There are no "black-listed" or "white-listed" bytes:
; 1144 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1145 :      */
; 1146 :     return Z_BINARY;

  00061	33 c0		 xor	 eax, eax

; 1147 : }

  00063	c3		 ret	 0
$LN5@detect_dat:

; 1138 :         return Z_TEXT;

  00064	b8 01 00 00 00	 mov	 eax, 1

; 1147 : }

  00069	c3		 ret	 0
_detect_data_type ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _compress_block
_TEXT	SEGMENT
_len$80985 = -16					; size = 4
_extra$ = -16						; size = 4
_val$80965 = -16					; size = 4
_lx$ = -12						; size = 4
_len$80962 = -8						; size = 4
_dist$ = -4						; size = 4
_ltree$ = 8						; size = 4
_dtree$ = 12						; size = 4
_compress_block PROC					; COMDAT
; _s$ = eax

; 1064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _ltree$[ebp]

; 1065 :     unsigned dist;      /* distance of matched string */
; 1066 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1067 :     unsigned lx = 0;    /* running index in l_buf */

  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 1068 :     unsigned code;      /* the code to send */
; 1069 :     int extra;          /* number of extra bits to send */
; 1070 : 
; 1071 :     if (s->last_lit != 0) do {

  0000e	39 88 a0 16 00
	00		 cmp	 DWORD PTR [eax+5792], ecx
  00014	0f 84 bb 00 00
	00		 je	 $LN17@compress_b
  0001a	eb 07		 jmp	 SHORT $LN19@compress_b
  0001c	8d 64 24 00	 npad	 4
$LL26@compress_b:
  00020	8b 4d f4	 mov	 ecx, DWORD PTR _lx$[ebp]
$LN19@compress_b:

; 1072 :         dist = s->d_buf[lx];

  00023	8b 90 a4 16 00
	00		 mov	 edx, DWORD PTR [eax+5796]
  00029	0f b7 14 4a	 movzx	 edx, WORD PTR [edx+ecx*2]

; 1073 :         lc = s->l_buf[lx++];

  0002d	8b b0 98 16 00
	00		 mov	 esi, DWORD PTR [eax+5784]
  00033	0f b6 34 31	 movzx	 esi, BYTE PTR [ecx+esi]
  00037	41		 inc	 ecx
  00038	89 4d f4	 mov	 DWORD PTR _lx$[ebp], ecx

; 1074 :         if (dist == 0) {
; 1075 :             send_code(s, lc, ltree); /* send a literal byte */

  0003b	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00041	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx
  00044	85 d2		 test	 edx, edx
  00046	0f 85 04 01 00
	00		 jne	 $LN16@compress_b
  0004c	0f b7 7c b3 02	 movzx	 edi, WORD PTR [ebx+esi*4+2]
  00051	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00056	2b d7		 sub	 edx, edi
  00058	3b ca		 cmp	 ecx, edx
  0005a	7e 54		 jle	 SHORT $LN15@compress_b
  0005c	0f b7 34 b3	 movzx	 esi, WORD PTR [ebx+esi*4]
  00060	66 8b d6	 mov	 dx, si
  00063	66 d3 e2	 shl	 dx, cl
  00066	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00069	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00070	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00077	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0007a	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0007d	ff 40 14	 inc	 DWORD PTR [eax+20]
  00080	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  00087	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0008a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0008d	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00090	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00096	ff 40 14	 inc	 DWORD PTR [eax+20]
  00099	8b 5d 08	 mov	 ebx, DWORD PTR _ltree$[ebp]
  0009c	b1 10		 mov	 cl, 16			; 00000010H
  0009e	2a ca		 sub	 cl, dl
  000a0	66 d3 ee	 shr	 si, cl
  000a3	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  000a7	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  000ae	eb 10		 jmp	 SHORT $LN28@compress_b
$LN15@compress_b:
  000b0	66 8b 14 b3	 mov	 dx, WORD PTR [ebx+esi*4]
$LN4@compress_b:

; 1094 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  000b4	66 d3 e2	 shl	 dx, cl
  000b7	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  000be	03 cf		 add	 ecx, edi
$LN28@compress_b:
  000c0	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN18@compress_b:

; 1095 :             }
; 1096 :         } /* literal or match pair ? */
; 1097 : 
; 1098 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1099 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1100 :                "pendingBuf overflow");
; 1101 : 
; 1102 :     } while (lx < s->last_lit);

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _lx$[ebp]
  000c9	3b 88 a0 16 00
	00		 cmp	 ecx, DWORD PTR [eax+5792]
  000cf	0f 82 4b ff ff
	ff		 jb	 $LL26@compress_b
$LN17@compress_b:

; 1103 : 
; 1104 :     send_code(s, END_BLOCK, ltree);

  000d5	0f b7 bb 02 04
	00 00		 movzx	 edi, WORD PTR [ebx+1026]
  000dc	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  000e2	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000e7	2b d7		 sub	 edx, edi
  000e9	3b ca		 cmp	 ecx, edx
  000eb	0f 8e c3 02 00
	00		 jle	 $LN2@compress_b
  000f1	0f b7 b3 00 04
	00 00		 movzx	 esi, WORD PTR [ebx+1024]
  000f8	66 8b d6	 mov	 dx, si
  000fb	66 d3 e2	 shl	 dx, cl
  000fe	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00101	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00108	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  0010f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00112	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00115	ff 40 14	 inc	 DWORD PTR [eax+20]
  00118	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  0011f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00122	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00125	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00128	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0012e	ff 40 14	 inc	 DWORD PTR [eax+20]
  00131	b1 10		 mov	 cl, 16			; 00000010H
  00133	2a ca		 sub	 cl, dl
  00135	66 d3 ee	 shr	 si, cl
  00138	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  0013c	5f		 pop	 edi
  0013d	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00143	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 1105 : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
$LN16@compress_b:

; 1076 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1077 :         } else {
; 1078 :             /* Here, lc is the match length - MIN_MATCH */
; 1079 :             code = _length_code[lc];

  00150	0f b6 be 00 00
	00 00		 movzx	 edi, BYTE PTR __length_code[esi]

; 1080 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  00157	0f b7 94 bb 06
	04 00 00	 movzx	 edx, WORD PTR [ebx+edi*4+1030]
  0015f	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00164	2b da		 sub	 ebx, edx
  00166	89 55 f8	 mov	 DWORD PTR _len$80962[ebp], edx
  00169	8b 55 08	 mov	 edx, DWORD PTR _ltree$[ebp]
  0016c	3b cb		 cmp	 ecx, ebx
  0016e	7e 61		 jle	 SHORT $LN12@compress_b
  00170	0f b7 94 ba 04
	04 00 00	 movzx	 edx, WORD PTR [edx+edi*4+1028]
  00178	89 55 f0	 mov	 DWORD PTR _val$80965[ebp], edx
  0017b	66 d3 e2	 shl	 dx, cl
  0017e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00181	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00188	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  0018f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00192	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00195	ff 40 14	 inc	 DWORD PTR [eax+20]
  00198	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  0019f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a2	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001a5	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001a8	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  001ae	8b 5d f0	 mov	 ebx, DWORD PTR _val$80965[ebp]
  001b1	ff 40 14	 inc	 DWORD PTR [eax+20]
  001b4	b1 10		 mov	 cl, 16			; 00000010H
  001b6	2a ca		 sub	 cl, dl
  001b8	66 d3 eb	 shr	 bx, cl
  001bb	8b 4d f8	 mov	 ecx, DWORD PTR _len$80962[ebp]
  001be	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  001c2	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  001c8	66 89 98 b8 16
	00 00		 mov	 WORD PTR [eax+5816], bx
  001cf	eb 1b		 jmp	 SHORT $LN29@compress_b
$LN12@compress_b:
  001d1	66 8b 94 ba 04
	04 00 00	 mov	 dx, WORD PTR [edx+edi*4+1028]
  001d9	66 d3 e2	 shl	 dx, cl
  001dc	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  001e3	03 4d f8	 add	 ecx, DWORD PTR _len$80962[ebp]
  001e6	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN29@compress_b:

; 1081 :             extra = extra_lbits[code];

  001ec	8b 1c bd 00 00
	00 00		 mov	 ebx, DWORD PTR _extra_lbits[edi*4]
  001f3	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  001f6	89 5d f0	 mov	 DWORD PTR _extra$[ebp], ebx

; 1082 :             if (extra != 0) {

  001f9	85 db		 test	 ebx, ebx
  001fb	74 7a		 je	 SHORT $LN8@compress_b

; 1083 :                 lc -= base_length[code];

  001fd	2b 34 bd 00 00
	00 00		 sub	 esi, DWORD PTR _base_length[edi*4]

; 1084 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  00204	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0020a	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0020f	2b fb		 sub	 edi, ebx
  00211	3b cf		 cmp	 ecx, edi
  00213	7e 50		 jle	 SHORT $LN9@compress_b
  00215	66 8b fe	 mov	 di, si
  00218	66 d3 e7	 shl	 di, cl
  0021b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0021e	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  00225	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  0022c	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  0022f	88 1c 39	 mov	 BYTE PTR [ecx+edi], bl
  00232	ff 40 14	 inc	 DWORD PTR [eax+20]
  00235	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  0023c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0023f	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  00242	88 1c 0f	 mov	 BYTE PTR [edi+ecx], bl
  00245	8b 98 bc 16 00
	00		 mov	 ebx, DWORD PTR [eax+5820]
  0024b	ff 40 14	 inc	 DWORD PTR [eax+20]
  0024e	b1 10		 mov	 cl, 16			; 00000010H
  00250	2a cb		 sub	 cl, bl
  00252	66 d3 ee	 shr	 si, cl
  00255	8b 4d f0	 mov	 ecx, DWORD PTR _extra$[ebp]
  00258	8d 4c 0b f0	 lea	 ecx, DWORD PTR [ebx+ecx-16]
  0025c	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  00263	eb 0c		 jmp	 SHORT $LN30@compress_b
$LN9@compress_b:
  00265	66 d3 e6	 shl	 si, cl
  00268	66 09 b0 b8 16
	00 00		 or	 WORD PTR [eax+5816], si
  0026f	03 cb		 add	 ecx, ebx
$LN30@compress_b:
  00271	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN8@compress_b:

; 1085 :             }
; 1086 :             dist--; /* dist is now the match distance - 1 */

  00277	4a		 dec	 edx
  00278	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx

; 1087 :             code = d_code(dist);

  0027b	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  00281	73 09		 jae	 SHORT $LN23@compress_b
  00283	0f b6 b2 00 00
	00 00		 movzx	 esi, BYTE PTR __dist_code[edx]
  0028a	eb 0c		 jmp	 SHORT $LN24@compress_b
$LN23@compress_b:
  0028c	8b ca		 mov	 ecx, edx
  0028e	c1 e9 07	 shr	 ecx, 7
  00291	0f b6 b1 00 01
	00 00		 movzx	 esi, BYTE PTR __dist_code[ecx+256]
$LN24@compress_b:

; 1088 :             Assert (code < D_CODES, "bad d_code");
; 1089 : 
; 1090 :             send_code(s, code, dtree);       /* send the distance code */

  00298	8b 4d 0c	 mov	 ecx, DWORD PTR _dtree$[ebp]
  0029b	0f b7 7c b1 02	 movzx	 edi, WORD PTR [ecx+esi*4+2]
  002a0	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  002a6	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  002ab	2b df		 sub	 ebx, edi
  002ad	89 7d f0	 mov	 DWORD PTR _len$80985[ebp], edi
  002b0	3b cb		 cmp	 ecx, ebx
  002b2	7e 60		 jle	 SHORT $LN7@compress_b
  002b4	8b 55 0c	 mov	 edx, DWORD PTR _dtree$[ebp]
  002b7	0f b7 3c b2	 movzx	 edi, WORD PTR [edx+esi*4]
  002bb	66 8b d7	 mov	 dx, di
  002be	66 d3 e2	 shl	 dx, cl
  002c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002c4	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002cb	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  002d2	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002d5	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  002d8	ff 40 14	 inc	 DWORD PTR [eax+20]
  002db	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002de	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  002e5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002e8	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  002eb	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  002f1	ff 40 14	 inc	 DWORD PTR [eax+20]
  002f4	b1 10		 mov	 cl, 16			; 00000010H
  002f6	2a ca		 sub	 cl, dl
  002f8	66 d3 ef	 shr	 di, cl
  002fb	8b 4d f0	 mov	 ecx, DWORD PTR _len$80985[ebp]
  002fe	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  00302	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00308	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  0030b	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00312	eb 19		 jmp	 SHORT $LN31@compress_b
$LN7@compress_b:
  00314	8b 5d 0c	 mov	 ebx, DWORD PTR _dtree$[ebp]
  00317	66 8b 1c b3	 mov	 bx, WORD PTR [ebx+esi*4]
  0031b	66 d3 e3	 shl	 bx, cl
  0031e	66 09 98 b8 16
	00 00		 or	 WORD PTR [eax+5816], bx
  00325	03 cf		 add	 ecx, edi
  00327	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN31@compress_b:

; 1091 :             extra = extra_dbits[code];

  0032d	8b 3c b5 00 00
	00 00		 mov	 edi, DWORD PTR _extra_dbits[esi*4]
  00334	8b 5d 08	 mov	 ebx, DWORD PTR _ltree$[ebp]

; 1092 :             if (extra != 0) {

  00337	85 ff		 test	 edi, edi
  00339	0f 84 87 fd ff
	ff		 je	 $LN18@compress_b

; 1093 :                 dist -= base_dist[code];

  0033f	2b 14 b5 00 00
	00 00		 sub	 edx, DWORD PTR _base_dist[esi*4]

; 1094 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  00346	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0034c	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00351	2b f7		 sub	 esi, edi
  00353	3b ce		 cmp	 ecx, esi
  00355	0f 8e 59 fd ff
	ff		 jle	 $LN4@compress_b
  0035b	66 8b f2	 mov	 si, dx
  0035e	66 d3 e6	 shl	 si, cl
  00361	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00364	66 09 b0 b8 16
	00 00		 or	 WORD PTR [eax+5816], si
  0036b	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00372	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00375	88 1c 31	 mov	 BYTE PTR [ecx+esi], bl
  00378	ff 40 14	 inc	 DWORD PTR [eax+20]
  0037b	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  00382	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00385	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00388	88 1c 0e	 mov	 BYTE PTR [esi+ecx], bl
  0038b	8b 98 bc 16 00
	00		 mov	 ebx, DWORD PTR [eax+5820]
  00391	ff 40 14	 inc	 DWORD PTR [eax+20]
  00394	b1 10		 mov	 cl, 16			; 00000010H
  00396	2a cb		 sub	 cl, bl
  00398	66 d3 ea	 shr	 dx, cl
  0039b	66 89 90 b8 16
	00 00		 mov	 WORD PTR [eax+5816], dx
  003a2	8d 54 3b f0	 lea	 edx, DWORD PTR [ebx+edi-16]
  003a6	8b 5d 08	 mov	 ebx, DWORD PTR _ltree$[ebp]
  003a9	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  003af	e9 12 fd ff ff	 jmp	 $LN18@compress_b
$LN2@compress_b:

; 1103 : 
; 1104 :     send_code(s, END_BLOCK, ltree);

  003b4	66 8b 93 00 04
	00 00		 mov	 dx, WORD PTR [ebx+1024]
  003bb	66 d3 e2	 shl	 dx, cl
  003be	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  003c5	03 cf		 add	 ecx, edi
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  003cf	5b		 pop	 ebx

; 1105 : }

  003d0	8b e5		 mov	 esp, ebp
  003d2	5d		 pop	 ebp
  003d3	c3		 ret	 0
_compress_block ENDP
_TEXT	ENDS
PUBLIC	__tr_align
; Function compile flags: /Ogtp
;	COMDAT __tr_align
_TEXT	SEGMENT
__tr_align PROC						; COMDAT
; _s$ = eax

; 895  :     send_bits(s, STATIC_TREES<<1, 3);

  00000	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00006	ba 02 00 00 00	 mov	 edx, 2
  0000b	66 d3 e2	 shl	 dx, cl
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	be 01 00 00 00	 mov	 esi, 1
  00015	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0001c	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0001f	7e 4c		 jle	 SHORT $LN4@tr_align
  00021	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00028	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0002b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002e	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00031	01 70 14	 add	 DWORD PTR [eax+20], esi
  00034	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  0003b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00041	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00044	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0004a	01 70 14	 add	 DWORD PTR [eax+20], esi
  0004d	57		 push	 edi
  0004e	b1 10		 mov	 cl, 16			; 00000010H
  00050	2a ca		 sub	 cl, dl
  00052	bf 02 00 00 00	 mov	 edi, 2
  00057	66 d3 ef	 shr	 di, cl
  0005a	83 c2 f3	 add	 edx, -13		; fffffff3H
  0005d	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00063	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  0006a	5f		 pop	 edi
  0006b	eb 09		 jmp	 SHORT $LN3@tr_align
$LN4@tr_align:
  0006d	83 c1 03	 add	 ecx, 3
  00070	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN3@tr_align:

; 896  :     send_code(s, END_BLOCK, static_ltree);

  00076	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0007c	33 d2		 xor	 edx, edx
  0007e	66 d3 e2	 shl	 dx, cl
  00081	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00088	83 f9 09	 cmp	 ecx, 9
  0008b	7e 4c		 jle	 SHORT $LN2@tr_align
  0008d	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00094	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00097	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009a	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0009d	01 70 14	 add	 DWORD PTR [eax+20], esi
  000a0	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  000a7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000aa	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ad	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000b0	01 70 14	 add	 DWORD PTR [eax+20], esi
  000b3	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  000b9	b1 10		 mov	 cl, 16			; 00000010H
  000bb	33 f6		 xor	 esi, esi
  000bd	2a ca		 sub	 cl, dl
  000bf	66 d3 ee	 shr	 si, cl
  000c2	83 c2 f7	 add	 edx, -9			; fffffff7H
  000c5	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  000cb	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 897  : #ifdef DEBUG
; 898  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 899  : #endif
; 900  :     bi_flush(s);

  000d4	e9 00 00 00 00	 jmp	 _bi_flush
$LN2@tr_align:

; 896  :     send_code(s, END_BLOCK, static_ltree);

  000d9	83 c1 07	 add	 ecx, 7
  000dc	5e		 pop	 esi
  000dd	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  000e3	5b		 pop	 ebx

; 897  : #ifdef DEBUG
; 898  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 899  : #endif
; 900  :     bi_flush(s);

  000e4	e9 00 00 00 00	 jmp	 _bi_flush
__tr_align ENDP
_TEXT	ENDS
PUBLIC	__tr_flush_bits
; Function compile flags: /Ogtp
;	COMDAT __tr_flush_bits
_TEXT	SEGMENT
__tr_flush_bits PROC					; COMDAT
; _s$ = eax

; 885  :     bi_flush(s);

  00000	e9 00 00 00 00	 jmp	 _bi_flush
__tr_flush_bits ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _send_tree
_TEXT	SEGMENT
tv1014 = -28						; size = 4
tv1013 = -28						; size = 4
tv1012 = -28						; size = 4
tv1011 = -28						; size = 4
tv1010 = -28						; size = 4
tv1009 = -28						; size = 4
tv1008 = -28						; size = 4
_curlen$ = -28						; size = 4
tv589 = -24						; size = 4
_val$80753 = -20					; size = 4
_val$80742 = -20					; size = 4
_val$80730 = -20					; size = 4
_val$80719 = -20					; size = 4
_val$80706 = -20					; size = 4
_val$80695 = -20					; size = 4
_val$80684 = -20					; size = 4
_prevlen$ = -20						; size = 4
tv1196 = -16						; size = 4
_nextlen$ = -12						; size = 4
_len$80739 = -8						; size = 4
_len$80716 = -8						; size = 4
_len$80692 = -8						; size = 4
_len$80681 = -8						; size = 4
_min_count$ = -8					; size = 4
_count$ = -4						; size = 4
_send_tree PROC						; COMDAT
; _s$ = eax
; _tree$ = edx
; _max_code$ = ecx

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f2		 mov	 esi, edx

; 755  :     int n;                     /* iterates over all tree elements */
; 756  :     int prevlen = -1;          /* last emitted length */
; 757  :     int curlen;                /* length of current code */
; 758  :     int nextlen = tree[0].Len; /* length of next code */

  0000a	0f b7 5e 02	 movzx	 ebx, WORD PTR [esi+2]

; 759  :     int count = 0;             /* repeat count of the current code */

  0000e	33 d2		 xor	 edx, edx
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _prevlen$[ebp], -1
  0001a	89 5d f4	 mov	 DWORD PTR _nextlen$[ebp], ebx

; 760  :     int max_count = 7;         /* max repeat count */

  0001d	8d 4a 07	 lea	 ecx, DWORD PTR [edx+7]

; 761  :     int min_count = 4;         /* min repeat count */

  00020	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _min_count$[ebp], 4

; 762  : 
; 763  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 764  :     if (nextlen == 0) max_count = 138, min_count = 3;

  00027	85 db		 test	 ebx, ebx
  00029	75 0c		 jne	 SHORT $LN36@send_tree
  0002b	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  00030	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _min_count$[ebp], 3
$LN36@send_tree:

; 765  : 
; 766  :     for (n = 0; n <= max_code; n++) {

  00037	85 ff		 test	 edi, edi
  00039	0f 88 35 05 00
	00		 js	 $LN33@send_tree
  0003f	83 c6 06	 add	 esi, 6
  00042	47		 inc	 edi
  00043	89 75 f0	 mov	 DWORD PTR tv1196[ebp], esi
  00046	89 7d e8	 mov	 DWORD PTR tv589[ebp], edi
  00049	bb 01 00 00 00	 mov	 ebx, 1
  0004e	8b ff		 npad	 2
$LL35@send_tree:

; 767  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00050	8b 7d f0	 mov	 edi, DWORD PTR tv1196[ebp]
  00053	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  00056	8b 75 f4	 mov	 esi, DWORD PTR _nextlen$[ebp]

; 768  :         if (++count < max_count && curlen == nextlen) {

  00059	03 d3		 add	 edx, ebx
  0005b	89 75 e4	 mov	 DWORD PTR _curlen$[ebp], esi
  0005e	89 7d f4	 mov	 DWORD PTR _nextlen$[ebp], edi
  00061	89 55 fc	 mov	 DWORD PTR _count$[ebp], edx
  00064	3b d1		 cmp	 edx, ecx
  00066	7d 08		 jge	 SHORT $LN32@send_tree
  00068	3b f7		 cmp	 esi, edi
  0006a	0f 84 f7 04 00
	00		 je	 $LN34@send_tree
$LN32@send_tree:

; 769  :             continue;
; 770  :         } else if (count < min_count) {

  00070	3b 55 f8	 cmp	 edx, DWORD PTR _min_count$[ebp]
  00073	0f 8d a5 00 00
	00		 jge	 $LN30@send_tree
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL29@send_tree:

; 771  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  00080	0f b7 bc b0 7e
	0a 00 00	 movzx	 edi, WORD PTR [eax+esi*4+2686]
  00088	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0008e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00093	2b d7		 sub	 edx, edi
  00095	3b ca		 cmp	 ecx, edx
  00097	7e 5d		 jle	 SHORT $LN26@send_tree
  00099	0f b7 b4 b0 7c
	0a 00 00	 movzx	 esi, WORD PTR [eax+esi*4+2684]
  000a1	66 8b d6	 mov	 dx, si
  000a4	66 d3 e2	 shl	 dx, cl
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000aa	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  000b1	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  000b8	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000bb	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000be	ff 40 14	 inc	 DWORD PTR [eax+20]
  000c1	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  000c8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000cb	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ce	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000d1	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  000d7	b1 10		 mov	 cl, 16			; 00000010H
  000d9	bb 01 00 00 00	 mov	 ebx, 1
  000de	01 58 14	 add	 DWORD PTR [eax+20], ebx
  000e1	2a ca		 sub	 cl, dl
  000e3	66 d3 ee	 shr	 si, cl
  000e6	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  000ea	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  000f1	8b 75 e4	 mov	 esi, DWORD PTR _curlen$[ebp]
  000f4	eb 14		 jmp	 SHORT $LN44@send_tree
$LN26@send_tree:
  000f6	66 8b 94 b0 7c
	0a 00 00	 mov	 dx, WORD PTR [eax+esi*4+2684]
  000fe	66 d3 e2	 shl	 dx, cl
  00101	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00108	03 cf		 add	 ecx, edi
$LN44@send_tree:
  0010a	29 5d fc	 sub	 DWORD PTR _count$[ebp], ebx
  0010d	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00113	0f 85 67 ff ff
	ff		 jne	 $LL29@send_tree

; 772  : 
; 773  :         } else if (curlen != 0) {

  00119	e9 11 04 00 00	 jmp	 $LN5@send_tree
$LN30@send_tree:
  0011e	85 f6		 test	 esi, esi
  00120	0f 84 cb 01 00
	00		 je	 $LN23@send_tree

; 774  :             if (curlen != prevlen) {

  00126	3b 75 ec	 cmp	 esi, DWORD PTR _prevlen$[ebp]
  00129	0f 84 aa 00 00
	00		 je	 $LN42@send_tree

; 775  :                 send_code(s, curlen, s->bl_tree); count--;

  0012f	0f b7 8c b0 7e
	0a 00 00	 movzx	 ecx, WORD PTR [eax+esi*4+2686]
  00137	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0013c	2b f9		 sub	 edi, ecx
  0013e	89 4d f8	 mov	 DWORD PTR _len$80681[ebp], ecx
  00141	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00147	3b cf		 cmp	 ecx, edi
  00149	7e 68		 jle	 SHORT $LN21@send_tree
  0014b	0f b7 94 b0 7c
	0a 00 00	 movzx	 edx, WORD PTR [eax+esi*4+2684]
  00153	89 55 ec	 mov	 DWORD PTR _val$80684[ebp], edx
  00156	66 d3 e2	 shl	 dx, cl
  00159	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0015c	89 45 e4	 mov	 DWORD PTR tv1014[ebp], eax
  0015f	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00166	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00169	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  0016f	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00172	8b 45 e4	 mov	 eax, DWORD PTR tv1014[ebp]
  00175	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00178	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  0017b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017e	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  00184	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00187	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0018d	8b 7d ec	 mov	 edi, DWORD PTR _val$80684[ebp]
  00190	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00193	b1 10		 mov	 cl, 16			; 00000010H
  00195	2a ca		 sub	 cl, dl
  00197	66 d3 ef	 shr	 di, cl
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _len$80681[ebp]
  0019d	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  001a1	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  001a7	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  001aa	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  001b1	eb 21		 jmp	 SHORT $LN20@send_tree
$LN21@send_tree:
  001b3	66 8b bc b0 7c
	0a 00 00	 mov	 di, WORD PTR [eax+esi*4+2684]
  001bb	66 d3 e7	 shl	 di, cl
  001be	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  001c4	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  001cb	03 4d f8	 add	 ecx, DWORD PTR _len$80681[ebp]
  001ce	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN20@send_tree:
  001d4	2b d3		 sub	 edx, ebx
  001d6	89 55 fc	 mov	 DWORD PTR _count$[ebp], edx
$LN42@send_tree:

; 776  :             }
; 777  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 778  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  001d9	0f b7 88 be 0a
	00 00		 movzx	 ecx, WORD PTR [eax+2750]
  001e0	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  001e5	2b f9		 sub	 edi, ecx
  001e7	89 4d f8	 mov	 DWORD PTR _len$80692[ebp], ecx
  001ea	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  001f0	3b cf		 cmp	 ecx, edi
  001f2	7e 67		 jle	 SHORT $LN19@send_tree
  001f4	0f b7 90 bc 0a
	00 00		 movzx	 edx, WORD PTR [eax+2748]
  001fb	89 55 ec	 mov	 DWORD PTR _val$80695[ebp], edx
  001fe	66 d3 e2	 shl	 dx, cl
  00201	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00204	89 45 e4	 mov	 DWORD PTR tv1013[ebp], eax
  00207	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0020e	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00211	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  00217	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0021a	8b 45 e4	 mov	 eax, DWORD PTR tv1013[ebp]
  0021d	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00220	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  00223	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00226	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  0022c	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  0022f	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00235	8b 7d ec	 mov	 edi, DWORD PTR _val$80695[ebp]
  00238	01 58 14	 add	 DWORD PTR [eax+20], ebx
  0023b	b1 10		 mov	 cl, 16			; 00000010H
  0023d	2a ca		 sub	 cl, dl
  0023f	66 d3 ef	 shr	 di, cl
  00242	8b 4d f8	 mov	 ecx, DWORD PTR _len$80692[ebp]
  00245	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  00249	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  0024f	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  00252	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00259	eb 1a		 jmp	 SHORT $LN18@send_tree
$LN19@send_tree:
  0025b	66 8b b8 bc 0a
	00 00		 mov	 di, WORD PTR [eax+2748]
  00262	66 d3 e7	 shl	 di, cl
  00265	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  0026c	03 4d f8	 add	 ecx, DWORD PTR _len$80692[ebp]
  0026f	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN18@send_tree:
  00275	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0027b	83 c2 fd	 add	 edx, -3			; fffffffdH
  0027e	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00281	7e 5c		 jle	 SHORT $LN17@send_tree
  00283	89 55 ec	 mov	 DWORD PTR _val$80706[ebp], edx
  00286	66 d3 e2	 shl	 dx, cl
  00289	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0028c	89 45 e4	 mov	 DWORD PTR tv1012[ebp], eax
  0028f	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00296	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00299	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  0029f	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  002a2	8b 45 e4	 mov	 eax, DWORD PTR tv1012[ebp]
  002a5	01 58 14	 add	 DWORD PTR [eax+20], ebx
  002a8	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  002ab	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  002b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002b4	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  002b7	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  002bd	8b 7d ec	 mov	 edi, DWORD PTR _val$80706[ebp]
  002c0	01 58 14	 add	 DWORD PTR [eax+20], ebx
  002c3	b1 10		 mov	 cl, 16			; 00000010H
  002c5	2a ca		 sub	 cl, dl
  002c7	66 d3 ef	 shr	 di, cl
  002ca	83 c2 f2	 add	 edx, -14		; fffffff2H
  002cd	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  002d3	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  002da	e9 50 02 00 00	 jmp	 $LN5@send_tree
$LN17@send_tree:
  002df	66 d3 e2	 shl	 dx, cl
  002e2	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  002e9	83 c1 02	 add	 ecx, 2
  002ec	e9 38 02 00 00	 jmp	 $LN45@send_tree
$LN23@send_tree:

; 779  : 
; 780  :         } else if (count <= 10) {
; 781  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  002f1	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  002f6	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  002f9	0f 8f 19 01 00
	00		 jg	 $LN14@send_tree
  002ff	0f b7 88 c2 0a
	00 00		 movzx	 ecx, WORD PTR [eax+2754]
  00306	2b f9		 sub	 edi, ecx
  00308	89 4d f8	 mov	 DWORD PTR _len$80716[ebp], ecx
  0030b	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  00311	3b cf		 cmp	 ecx, edi
  00313	7e 67		 jle	 SHORT $LN13@send_tree
  00315	0f b7 90 c0 0a
	00 00		 movzx	 edx, WORD PTR [eax+2752]
  0031c	89 55 ec	 mov	 DWORD PTR _val$80719[ebp], edx
  0031f	66 d3 e2	 shl	 dx, cl
  00322	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00325	89 45 e4	 mov	 DWORD PTR tv1011[ebp], eax
  00328	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  0032f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00332	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  00338	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0033b	8b 45 e4	 mov	 eax, DWORD PTR tv1011[ebp]
  0033e	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00341	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  00344	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00347	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  0034d	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00350	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00356	8b 7d ec	 mov	 edi, DWORD PTR _val$80719[ebp]
  00359	01 58 14	 add	 DWORD PTR [eax+20], ebx
  0035c	b1 10		 mov	 cl, 16			; 00000010H
  0035e	2a ca		 sub	 cl, dl
  00360	66 d3 ef	 shr	 di, cl
  00363	8b 4d f8	 mov	 ecx, DWORD PTR _len$80716[ebp]
  00366	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  0036a	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00370	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  00373	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  0037a	eb 20		 jmp	 SHORT $LN12@send_tree
$LN13@send_tree:
  0037c	66 8b b8 c0 0a
	00 00		 mov	 di, WORD PTR [eax+2752]
  00383	66 d3 e7	 shl	 di, cl
  00386	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0038c	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  00393	03 4d f8	 add	 ecx, DWORD PTR _len$80716[ebp]
  00396	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN12@send_tree:
  0039c	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  003a2	83 c2 fd	 add	 edx, -3			; fffffffdH
  003a5	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  003a8	7e 5c		 jle	 SHORT $LN11@send_tree
  003aa	89 55 ec	 mov	 DWORD PTR _val$80730[ebp], edx
  003ad	66 d3 e2	 shl	 dx, cl
  003b0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003b3	89 45 e4	 mov	 DWORD PTR tv1010[ebp], eax
  003b6	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  003bd	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  003c0	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  003c6	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  003c9	8b 45 e4	 mov	 eax, DWORD PTR tv1010[ebp]
  003cc	01 58 14	 add	 DWORD PTR [eax+20], ebx
  003cf	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  003d2	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  003d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003db	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  003de	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  003e4	8b 7d ec	 mov	 edi, DWORD PTR _val$80730[ebp]
  003e7	01 58 14	 add	 DWORD PTR [eax+20], ebx
  003ea	b1 10		 mov	 cl, 16			; 00000010H
  003ec	2a ca		 sub	 cl, dl
  003ee	66 d3 ef	 shr	 di, cl
  003f1	83 c2 f3	 add	 edx, -13		; fffffff3H
  003f4	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  003fa	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00401	e9 29 01 00 00	 jmp	 $LN5@send_tree
$LN11@send_tree:
  00406	66 d3 e2	 shl	 dx, cl
  00409	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00410	83 c1 03	 add	 ecx, 3

; 782  : 
; 783  :         } else {

  00413	e9 11 01 00 00	 jmp	 $LN45@send_tree
$LN14@send_tree:

; 784  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  00418	0f b7 88 c6 0a
	00 00		 movzx	 ecx, WORD PTR [eax+2758]
  0041f	2b f9		 sub	 edi, ecx
  00421	89 4d f8	 mov	 DWORD PTR _len$80739[ebp], ecx
  00424	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0042a	3b cf		 cmp	 ecx, edi
  0042c	7e 67		 jle	 SHORT $LN8@send_tree
  0042e	0f b7 90 c4 0a
	00 00		 movzx	 edx, WORD PTR [eax+2756]
  00435	89 55 ec	 mov	 DWORD PTR _val$80742[ebp], edx
  00438	66 d3 e2	 shl	 dx, cl
  0043b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0043e	89 45 e4	 mov	 DWORD PTR tv1009[ebp], eax
  00441	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00448	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0044b	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  00451	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00454	8b 45 e4	 mov	 eax, DWORD PTR tv1009[ebp]
  00457	01 58 14	 add	 DWORD PTR [eax+20], ebx
  0045a	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  0045d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00460	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  00466	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00469	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  0046f	8b 7d ec	 mov	 edi, DWORD PTR _val$80742[ebp]
  00472	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00475	b1 10		 mov	 cl, 16			; 00000010H
  00477	2a ca		 sub	 cl, dl
  00479	66 d3 ef	 shr	 di, cl
  0047c	8b 4d f8	 mov	 ecx, DWORD PTR _len$80739[ebp]
  0047f	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  00483	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00489	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  0048c	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  00493	eb 20		 jmp	 SHORT $LN7@send_tree
$LN8@send_tree:
  00495	66 8b b8 c4 0a
	00 00		 mov	 di, WORD PTR [eax+2756]
  0049c	66 d3 e7	 shl	 di, cl
  0049f	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  004a5	66 09 b8 b8 16
	00 00		 or	 WORD PTR [eax+5816], di
  004ac	03 4d f8	 add	 ecx, DWORD PTR _len$80739[ebp]
  004af	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN7@send_tree:
  004b5	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  004bb	83 c2 f5	 add	 edx, -11		; fffffff5H
  004be	83 f9 09	 cmp	 ecx, 9
  004c1	7e 59		 jle	 SHORT $LN6@send_tree
  004c3	89 55 ec	 mov	 DWORD PTR _val$80753[ebp], edx
  004c6	66 d3 e2	 shl	 dx, cl
  004c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004cc	89 45 e4	 mov	 DWORD PTR tv1008[ebp], eax
  004cf	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  004d6	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  004d9	8a 80 b8 16 00
	00		 mov	 al, BYTE PTR [eax+5816]
  004df	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  004e2	8b 45 e4	 mov	 eax, DWORD PTR tv1008[ebp]
  004e5	01 58 14	 add	 DWORD PTR [eax+20], ebx
  004e8	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  004eb	8a 90 b9 16 00
	00		 mov	 dl, BYTE PTR [eax+5817]
  004f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004f4	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  004f7	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  004fd	8b 7d ec	 mov	 edi, DWORD PTR _val$80753[ebp]
  00500	01 58 14	 add	 DWORD PTR [eax+20], ebx
  00503	b1 10		 mov	 cl, 16			; 00000010H
  00505	2a ca		 sub	 cl, dl
  00507	66 d3 ef	 shr	 di, cl
  0050a	83 c2 f7	 add	 edx, -9			; fffffff7H
  0050d	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00513	66 89 b8 b8 16
	00 00		 mov	 WORD PTR [eax+5816], di
  0051a	eb 13		 jmp	 SHORT $LN5@send_tree
$LN6@send_tree:
  0051c	66 d3 e2	 shl	 dx, cl
  0051f	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00526	83 c1 07	 add	 ecx, 7
$LN45@send_tree:
  00529	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
$LN5@send_tree:

; 785  :         }
; 786  :         count = 0; prevlen = curlen;
; 787  :         if (nextlen == 0) {

  0052f	8b 4d f4	 mov	 ecx, DWORD PTR _nextlen$[ebp]
  00532	33 d2		 xor	 edx, edx
  00534	89 75 ec	 mov	 DWORD PTR _prevlen$[ebp], esi
  00537	85 c9		 test	 ecx, ecx
  00539	75 0e		 jne	 SHORT $LN4@send_tree

; 788  :             max_count = 138, min_count = 3;

  0053b	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  00540	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _min_count$[ebp], 3
  00547	eb 1e		 jmp	 SHORT $LN34@send_tree
$LN4@send_tree:

; 789  :         } else if (curlen == nextlen) {

  00549	3b f1		 cmp	 esi, ecx
  0054b	75 0e		 jne	 SHORT $LN2@send_tree

; 790  :             max_count = 6, min_count = 3;

  0054d	b9 06 00 00 00	 mov	 ecx, 6
  00552	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _min_count$[ebp], 3

; 791  :         } else {

  00559	eb 0c		 jmp	 SHORT $LN34@send_tree
$LN2@send_tree:

; 792  :             max_count = 7, min_count = 4;

  0055b	b9 07 00 00 00	 mov	 ecx, 7
  00560	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _min_count$[ebp], 4
$LN34@send_tree:

; 765  : 
; 766  :     for (n = 0; n <= max_code; n++) {

  00567	83 45 f0 04	 add	 DWORD PTR tv1196[ebp], 4
  0056b	29 5d e8	 sub	 DWORD PTR tv589[ebp], ebx
  0056e	0f 85 dc fa ff
	ff		 jne	 $LL35@send_tree
$LN33@send_tree:
  00574	5f		 pop	 edi
  00575	5e		 pop	 esi
  00576	5b		 pop	 ebx

; 793  :         }
; 794  :     }
; 795  : }

  00577	8b e5		 mov	 esp, ebp
  00579	5d		 pop	 ebp
  0057a	c3		 ret	 0
_send_tree ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _scan_tree
_TEXT	SEGMENT
_nextlen$ = -16						; size = 4
tv84 = -12						; size = 4
_prevlen$ = -8						; size = 4
tv295 = -4						; size = 4
_s$ = 8							; size = 4
_scan_tree PROC						; COMDAT
; _tree$ = ecx
; _max_code$ = eax

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b d8		 mov	 ebx, eax

; 710  :     int n;                     /* iterates over all tree elements */
; 711  :     int prevlen = -1;          /* last emitted length */
; 712  :     int curlen;                /* length of current code */
; 713  :     int nextlen = tree[0].Len; /* length of next code */

  0000d	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]

; 714  :     int count = 0;             /* repeat count of the current code */

  00011	33 d2		 xor	 edx, edx
  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _prevlen$[ebp], -1
  0001a	89 45 f0	 mov	 DWORD PTR _nextlen$[ebp], eax

; 715  :     int max_count = 7;         /* max repeat count */

  0001d	8d 4a 07	 lea	 ecx, DWORD PTR [edx+7]

; 716  :     int min_count = 4;         /* min repeat count */

  00020	8d 72 04	 lea	 esi, DWORD PTR [edx+4]

; 717  : 
; 718  :     if (nextlen == 0) max_count = 138, min_count = 3;

  00023	85 c0		 test	 eax, eax
  00025	75 08		 jne	 SHORT $LN17@scan_tree
  00027	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  0002c	8d 70 03	 lea	 esi, DWORD PTR [eax+3]
$LN17@scan_tree:

; 719  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  0002f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00034	66 89 44 9f 06	 mov	 WORD PTR [edi+ebx*4+6], ax

; 720  : 
; 721  :     for (n = 0; n <= max_code; n++) {

  00039	85 db		 test	 ebx, ebx
  0003b	0f 88 90 00 00
	00		 js	 $LN14@scan_tree

; 719  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00041	83 c7 06	 add	 edi, 6
  00044	43		 inc	 ebx
  00045	89 7d fc	 mov	 DWORD PTR tv295[ebp], edi
  00048	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
  0004b	89 5d f4	 mov	 DWORD PTR tv84[ebp], ebx
  0004e	8b 5d f0	 mov	 ebx, DWORD PTR _nextlen$[ebp]
$LL16@scan_tree:

; 722  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00051	8b c3		 mov	 eax, ebx
  00053	8b 5d fc	 mov	 ebx, DWORD PTR tv295[ebp]
  00056	0f b7 1b	 movzx	 ebx, WORD PTR [ebx]

; 723  :         if (++count < max_count && curlen == nextlen) {

  00059	42		 inc	 edx
  0005a	3b d1		 cmp	 edx, ecx
  0005c	7d 04		 jge	 SHORT $LN13@scan_tree
  0005e	3b c3		 cmp	 eax, ebx
  00060	74 66		 je	 SHORT $LN15@scan_tree
$LN13@scan_tree:

; 724  :             continue;
; 725  :         } else if (count < min_count) {

  00062	3b d6		 cmp	 edx, esi
  00064	7d 0a		 jge	 SHORT $LN11@scan_tree

; 726  :             s->bl_tree[curlen].Freq += count;

  00066	66 01 94 87 7c
	0a 00 00	 add	 WORD PTR [edi+eax*4+2684], dx
  0006e	eb 2f		 jmp	 SHORT $LN5@scan_tree
$LN11@scan_tree:

; 727  :         } else if (curlen != 0) {

  00070	85 c0		 test	 eax, eax
  00072	74 16		 je	 SHORT $LN9@scan_tree

; 728  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  00074	3b 45 f8	 cmp	 eax, DWORD PTR _prevlen$[ebp]
  00077	74 08		 je	 SHORT $LN23@scan_tree
  00079	66 ff 84 87 7c
	0a 00 00	 inc	 WORD PTR [edi+eax*4+2684]
$LN23@scan_tree:

; 729  :             s->bl_tree[REP_3_6].Freq++;

  00081	66 ff 87 bc 0a
	00 00		 inc	 WORD PTR [edi+2748]
  00088	eb 15		 jmp	 SHORT $LN5@scan_tree
$LN9@scan_tree:

; 730  :         } else if (count <= 10) {

  0008a	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0008d	7f 09		 jg	 SHORT $LN6@scan_tree

; 731  :             s->bl_tree[REPZ_3_10].Freq++;

  0008f	66 ff 87 c0 0a
	00 00		 inc	 WORD PTR [edi+2752]

; 732  :         } else {

  00096	eb 07		 jmp	 SHORT $LN5@scan_tree
$LN6@scan_tree:

; 733  :             s->bl_tree[REPZ_11_138].Freq++;

  00098	66 ff 87 c4 0a
	00 00		 inc	 WORD PTR [edi+2756]
$LN5@scan_tree:

; 734  :         }
; 735  :         count = 0; prevlen = curlen;

  0009f	33 d2		 xor	 edx, edx
  000a1	89 45 f8	 mov	 DWORD PTR _prevlen$[ebp], eax

; 736  :         if (nextlen == 0) {

  000a4	85 db		 test	 ebx, ebx
  000a6	75 0a		 jne	 SHORT $LN4@scan_tree

; 737  :             max_count = 138, min_count = 3;

  000a8	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  000ad	8d 72 03	 lea	 esi, DWORD PTR [edx+3]
  000b0	eb 16		 jmp	 SHORT $LN15@scan_tree
$LN4@scan_tree:

; 738  :         } else if (curlen == nextlen) {

  000b2	3b c3		 cmp	 eax, ebx
  000b4	75 0a		 jne	 SHORT $LN2@scan_tree

; 739  :             max_count = 6, min_count = 3;

  000b6	b9 06 00 00 00	 mov	 ecx, 6
  000bb	8d 71 fd	 lea	 esi, DWORD PTR [ecx-3]

; 740  :         } else {

  000be	eb 08		 jmp	 SHORT $LN15@scan_tree
$LN2@scan_tree:

; 741  :             max_count = 7, min_count = 4;

  000c0	b9 07 00 00 00	 mov	 ecx, 7
  000c5	8d 71 fd	 lea	 esi, DWORD PTR [ecx-3]
$LN15@scan_tree:

; 720  : 
; 721  :     for (n = 0; n <= max_code; n++) {

  000c8	83 45 fc 04	 add	 DWORD PTR tv295[ebp], 4
  000cc	ff 4d f4	 dec	 DWORD PTR tv84[ebp]
  000cf	75 80		 jne	 SHORT $LL16@scan_tree
$LN14@scan_tree:
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 742  :         }
; 743  :     }
; 744  : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_scan_tree ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gen_codes
_TEXT	SEGMENT
_next_code$ = -32					; size = 32
_gen_codes PROC						; COMDAT
; _tree$ = edi
; _max_code$ = ebx
; _bl_count$ = edx

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 580  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 581  :     ush code = 0;              /* running code value */
; 582  :     int bits;                  /* bit index */
; 583  :     int n;                     /* code index */
; 584  : 
; 585  :     /* The distribution counts are first used to generate the code values
; 586  :      * without bit reversal.
; 587  :      */
; 588  :     for (bits = 1; bits <= MAX_BITS; bits++) {

  00007	8d 75 e2	 lea	 esi, DWORD PTR _next_code$[ebp+2]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	2b d6		 sub	 edx, esi
$LL7@gen_codes:
  00013	8d 34 42	 lea	 esi, DWORD PTR [edx+eax*2]

; 589  :         next_code[bits] = code = (code + bl_count[bits-1]) << 1;

  00016	66 8b 74 35 e0	 mov	 si, WORD PTR _next_code$[ebp+esi]
  0001b	66 03 f1	 add	 si, cx
  0001e	66 03 f6	 add	 si, si
  00021	0f b7 ce	 movzx	 ecx, si
  00024	66 89 4c 45 e0	 mov	 WORD PTR _next_code$[ebp+eax*2], cx
  00029	40		 inc	 eax
  0002a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0002d	7e e4		 jle	 SHORT $LL7@gen_codes

; 590  :     }
; 591  :     /* Check that the bit counts in bl_count are consistent. The last code
; 592  :      * must be all ones.
; 593  :      */
; 594  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 595  :             "inconsistent bit counts");
; 596  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 597  : 
; 598  :     for (n = 0;  n <= max_code; n++) {

  0002f	33 f6		 xor	 esi, esi
  00031	85 db		 test	 ebx, ebx
  00033	78 24		 js	 SHORT $LN2@gen_codes
$LL14@gen_codes:

; 599  :         int len = tree[n].Len;

  00035	0f b7 54 b7 02	 movzx	 edx, WORD PTR [edi+esi*4+2]

; 600  :         if (len == 0) continue;

  0003a	85 d2		 test	 edx, edx
  0003c	74 16		 je	 SHORT $LN3@gen_codes

; 601  :         /* Now reverse the bits */
; 602  :         tree[n].Code = bi_reverse(next_code[len]++, len);

  0003e	0f b7 44 55 e0	 movzx	 eax, WORD PTR _next_code$[ebp+edx*2]
  00043	8b c8		 mov	 ecx, eax
  00045	40		 inc	 eax
  00046	66 89 44 55 e0	 mov	 WORD PTR _next_code$[ebp+edx*2], ax
  0004b	e8 00 00 00 00	 call	 _bi_reverse
  00050	66 89 04 b7	 mov	 WORD PTR [edi+esi*4], ax
$LN3@gen_codes:

; 590  :     }
; 591  :     /* Check that the bit counts in bl_count are consistent. The last code
; 592  :      * must be all ones.
; 593  :      */
; 594  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 595  :             "inconsistent bit counts");
; 596  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 597  : 
; 598  :     for (n = 0;  n <= max_code; n++) {

  00054	46		 inc	 esi
  00055	3b f3		 cmp	 esi, ebx
  00057	7e dc		 jle	 SHORT $LL14@gen_codes
$LN2@gen_codes:
  00059	5e		 pop	 esi

; 603  : 
; 604  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 605  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 606  :     }
; 607  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_gen_codes ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gen_bitlen
_TEXT	SEGMENT
_tree$ = -40						; size = 4
tv643 = -36						; size = 4
_stree$ = -36						; size = 4
tv671 = -32						; size = 4
_extra$ = -32						; size = 4
_base$ = -28						; size = 4
_max_code$ = -24					; size = 4
tv709 = -20						; size = 4
tv277 = -20						; size = 4
_h$ = -16						; size = 4
tv597 = -12						; size = 4
_n$ = -12						; size = 4
_overflow$ = -8						; size = 4
_max_length$ = -4					; size = 4
_gen_bitlen PROC					; COMDAT
; _s$ = eax
; _desc$ = ecx

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 492  :     ct_data *tree        = desc->dyn_tree;
; 493  :     int max_code         = desc->max_code;

  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	53		 push	 ebx
  0000a	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 494  :     const ct_data *stree = desc->stat_desc->static_tree;

  0000c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000f	89 55 e8	 mov	 DWORD PTR _max_code$[ebp], edx
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 55 dc	 mov	 DWORD PTR _stree$[ebp], edx

; 495  :     const intf *extra    = desc->stat_desc->extra_bits;

  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	56		 push	 esi
  0001b	89 55 e0	 mov	 DWORD PTR _extra$[ebp], edx

; 496  :     int base             = desc->stat_desc->extra_base;

  0001e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00021	57		 push	 edi

; 497  :     int max_length       = desc->stat_desc->max_length;

  00022	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]

; 498  :     int h;              /* heap index */
; 499  :     int n, m;           /* iterate over the tree elements */
; 500  :     int bits;           /* bit length */
; 501  :     int xbits;          /* extra bits */
; 502  :     ush f;              /* frequency */
; 503  :     int overflow = 0;   /* number of elements with bit length too large */
; 504  : 
; 505  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

  00025	33 c9		 xor	 ecx, ecx
  00027	89 55 e4	 mov	 DWORD PTR _base$[ebp], edx
  0002a	0f b7 d1	 movzx	 edx, cx
  0002d	8b ca		 mov	 ecx, edx
  0002f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00032	0b ca		 or	 ecx, edx
  00034	89 88 3c 0b 00
	00		 mov	 DWORD PTR [eax+2876], ecx
  0003a	89 88 40 0b 00
	00		 mov	 DWORD PTR [eax+2880], ecx
  00040	89 88 44 0b 00
	00		 mov	 DWORD PTR [eax+2884], ecx
  00046	89 88 48 0b 00
	00		 mov	 DWORD PTR [eax+2888], ecx
  0004c	89 88 4c 0b 00
	00		 mov	 DWORD PTR [eax+2892], ecx
  00052	89 88 50 0b 00
	00		 mov	 DWORD PTR [eax+2896], ecx
  00058	89 88 54 0b 00
	00		 mov	 DWORD PTR [eax+2900], ecx
  0005e	89 88 58 0b 00
	00		 mov	 DWORD PTR [eax+2904], ecx

; 506  : 
; 507  :     /* In a first pass, compute the optimal bit lengths (which may
; 508  :      * overflow in the case of the bit length tree).
; 509  :      */
; 510  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  00064	8b 88 54 14 00
	00		 mov	 ecx, DWORD PTR [eax+5204]
  0006a	8b 94 88 5c 0b
	00 00		 mov	 edx, DWORD PTR [eax+ecx*4+2908]
  00071	33 c9		 xor	 ecx, ecx
  00073	66 89 4c 93 02	 mov	 WORD PTR [ebx+edx*4+2], cx

; 511  : 
; 512  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00078	8b 88 54 14 00
	00		 mov	 ecx, DWORD PTR [eax+5204]
  0007e	33 f6		 xor	 esi, esi
  00080	41		 inc	 ecx
  00081	89 5d d8	 mov	 DWORD PTR _tree$[ebp], ebx
  00084	89 7d fc	 mov	 DWORD PTR _max_length$[ebp], edi
  00087	89 75 f8	 mov	 DWORD PTR _overflow$[ebp], esi
  0008a	81 f9 3d 02 00
	00		 cmp	 ecx, 573		; 0000023dH
  00090	0f 8d 5a 01 00
	00		 jge	 $LN5@gen_bitlen

; 506  : 
; 507  :     /* In a first pass, compute the optimal bit lengths (which may
; 508  :      * overflow in the case of the bit length tree).
; 509  :      */
; 510  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  00096	8d 94 88 5c 0b
	00 00		 lea	 edx, DWORD PTR [eax+ecx*4+2908]
  0009d	89 55 f4	 mov	 DWORD PTR tv597[ebp], edx
  000a0	ba 3d 02 00 00	 mov	 edx, 573		; 0000023dH
  000a5	2b d1		 sub	 edx, ecx

; 511  : 
; 512  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  000a7	03 ca		 add	 ecx, edx
  000a9	89 55 ec	 mov	 DWORD PTR tv277[ebp], edx
  000ac	89 4d f0	 mov	 DWORD PTR _h$[ebp], ecx
  000af	90		 npad	 1
$LL41@gen_bitlen:

; 513  :         n = s->heap[h];

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR tv597[ebp]
  000b3	8b 11		 mov	 edx, DWORD PTR [ecx]

; 514  :         bits = tree[tree[n].Dad].Len + 1;

  000b5	0f b7 4c 93 02	 movzx	 ecx, WORD PTR [ebx+edx*4+2]
  000ba	0f b7 4c 8b 02	 movzx	 ecx, WORD PTR [ebx+ecx*4+2]
  000bf	41		 inc	 ecx

; 515  :         if (bits > max_length) bits = max_length, overflow++;

  000c0	3b cf		 cmp	 ecx, edi
  000c2	7e 06		 jle	 SHORT $LN17@gen_bitlen
  000c4	46		 inc	 esi
  000c5	8b cf		 mov	 ecx, edi
  000c7	89 75 f8	 mov	 DWORD PTR _overflow$[ebp], esi
$LN17@gen_bitlen:

; 516  :         tree[n].Len = (ush)bits;

  000ca	66 89 4c 93 02	 mov	 WORD PTR [ebx+edx*4+2], cx

; 517  :         /* We overwrite tree[n].Dad which is no longer needed */
; 518  : 
; 519  :         if (n > max_code) continue; /* not a leaf node */

  000cf	3b 55 e8	 cmp	 edx, DWORD PTR _max_code$[ebp]
  000d2	7f 47		 jg	 SHORT $LN19@gen_bitlen

; 520  : 
; 521  :         s->bl_count[bits]++;
; 522  :         xbits = 0;
; 523  :         if (n >= base) xbits = extra[n-base];

  000d4	8b 7d e4	 mov	 edi, DWORD PTR _base$[ebp]
  000d7	66 ff 84 48 3c
	0b 00 00	 inc	 WORD PTR [eax+ecx*2+2876]
  000df	33 f6		 xor	 esi, esi
  000e1	3b d7		 cmp	 edx, edi
  000e3	7c 0a		 jl	 SHORT $LN15@gen_bitlen
  000e5	8b f2		 mov	 esi, edx
  000e7	2b f7		 sub	 esi, edi
  000e9	8b 7d e0	 mov	 edi, DWORD PTR _extra$[ebp]
  000ec	8b 34 b7	 mov	 esi, DWORD PTR [edi+esi*4]
$LN15@gen_bitlen:

; 524  :         f = tree[n].Freq;

  000ef	0f b7 3c 93	 movzx	 edi, WORD PTR [ebx+edx*4]

; 525  :         s->opt_len += (ulg)f * (bits + xbits);

  000f3	03 ce		 add	 ecx, esi
  000f5	0f af cf	 imul	 ecx, edi
  000f8	01 88 a8 16 00
	00		 add	 DWORD PTR [eax+5800], ecx

; 526  :         if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);

  000fe	8b 4d dc	 mov	 ecx, DWORD PTR _stree$[ebp]
  00101	85 c9		 test	 ecx, ecx
  00103	74 10		 je	 SHORT $LN38@gen_bitlen
  00105	0f b7 54 91 02	 movzx	 edx, WORD PTR [ecx+edx*4+2]
  0010a	03 d6		 add	 edx, esi
  0010c	0f af d7	 imul	 edx, edi
  0010f	01 90 ac 16 00
	00		 add	 DWORD PTR [eax+5804], edx
$LN38@gen_bitlen:
  00115	8b 7d fc	 mov	 edi, DWORD PTR _max_length$[ebp]
  00118	8b 75 f8	 mov	 esi, DWORD PTR _overflow$[ebp]
$LN19@gen_bitlen:

; 511  : 
; 512  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  0011b	83 45 f4 04	 add	 DWORD PTR tv597[ebp], 4
  0011f	ff 4d ec	 dec	 DWORD PTR tv277[ebp]
  00122	75 8c		 jne	 SHORT $LL41@gen_bitlen

; 527  :     }
; 528  :     if (overflow == 0) return;

  00124	85 f6		 test	 esi, esi
  00126	0f 84 c4 00 00
	00		 je	 $LN5@gen_bitlen
  0012c	8d bc 78 3c 0b
	00 00		 lea	 edi, DWORD PTR [eax+edi*2+2876]
$LL12@gen_bitlen:

; 529  : 
; 530  :     Trace((stderr,"\nbit length overflow\n"));
; 531  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 532  : 
; 533  :     /* Find the first bit length which could increase: */
; 534  :     do {
; 535  :         bits = max_length-1;

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _max_length$[ebp]
  00136	49		 dec	 ecx

; 536  :         while (s->bl_count[bits] == 0) bits--;

  00137	66 83 bc 48 3c
	0b 00 00 00	 cmp	 WORD PTR [eax+ecx*2+2876], 0
  00140	8d 94 48 3c 0b
	00 00		 lea	 edx, DWORD PTR [eax+ecx*2+2876]
  00147	75 11		 jne	 SHORT $LN8@gen_bitlen
  00149	8d a4 24 00 00
	00 00		 npad	 7
$LL9@gen_bitlen:
  00150	83 ea 02	 sub	 edx, 2
  00153	49		 dec	 ecx
  00154	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00158	74 f6		 je	 SHORT $LL9@gen_bitlen
$LN8@gen_bitlen:

; 537  :         s->bl_count[bits]--;      /* move one leaf down the tree */
; 538  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */

  0015a	66 83 84 48 3e
	0b 00 00 02	 add	 WORD PTR [eax+ecx*2+2878], 2
  00163	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00168	66 01 94 48 3c
	0b 00 00	 add	 WORD PTR [eax+ecx*2+2876], dx

; 539  :         s->bl_count[max_length]--;

  00170	8b ca		 mov	 ecx, edx
  00172	66 01 0f	 add	 WORD PTR [edi], cx

; 540  :         /* The brother of the overflow item also moves one step up,
; 541  :          * but this does not affect bl_count[max_length]
; 542  :          */
; 543  :         overflow -= 2;

  00175	83 ee 02	 sub	 esi, 2

; 544  :     } while (overflow > 0);

  00178	85 f6		 test	 esi, esi
  0017a	7f b7		 jg	 SHORT $LL12@gen_bitlen

; 545  : 
; 546  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 547  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 548  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 549  :      * from 'ar' written by Haruhiko Okumura.)
; 550  :      */
; 551  :     for (bits = max_length; bits != 0; bits--) {

  0017c	8b 55 fc	 mov	 edx, DWORD PTR _max_length$[ebp]
  0017f	85 d2		 test	 edx, edx
  00181	74 6d		 je	 SHORT $LN5@gen_bitlen
  00183	89 7d ec	 mov	 DWORD PTR tv709[ebp], edi
$LL7@gen_bitlen:

; 552  :         n = s->bl_count[bits];

  00186	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  00189	89 7d f4	 mov	 DWORD PTR _n$[ebp], edi

; 553  :         while (n != 0) {

  0018c	85 ff		 test	 edi, edi
  0018e	74 54		 je	 SHORT $LN6@gen_bitlen

; 552  :         n = s->bl_count[bits];

  00190	8b 4d f0	 mov	 ecx, DWORD PTR _h$[ebp]
  00193	8d b4 88 5c 0b
	00 00		 lea	 esi, DWORD PTR [eax+ecx*4+2908]
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL4@gen_bitlen:

; 554  :             m = s->heap[--h];

  001a0	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  001a3	ff 4d f0	 dec	 DWORD PTR _h$[ebp]
  001a6	83 ee 04	 sub	 esi, 4
  001a9	89 75 e0	 mov	 DWORD PTR tv671[ebp], esi

; 555  :             if (m > max_code) continue;

  001ac	3b 4d e8	 cmp	 ecx, DWORD PTR _max_code$[ebp]
  001af	7f 2f		 jg	 SHORT $LN39@gen_bitlen

; 556  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  001b1	0f b7 7c 8b 02	 movzx	 edi, WORD PTR [ebx+ecx*4+2]
  001b6	8d 74 8b 02	 lea	 esi, DWORD PTR [ebx+ecx*4+2]
  001ba	3b fa		 cmp	 edi, edx
  001bc	74 19		 je	 SHORT $LN1@gen_bitlen

; 557  :                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 558  :                 s->opt_len += ((long)bits - (long)tree[m].Len)
; 559  :                               *(long)tree[m].Freq;

  001be	8b da		 mov	 ebx, edx
  001c0	2b df		 sub	 ebx, edi
  001c2	8b fb		 mov	 edi, ebx
  001c4	8b 5d d8	 mov	 ebx, DWORD PTR _tree$[ebp]
  001c7	0f b7 0c 8b	 movzx	 ecx, WORD PTR [ebx+ecx*4]
  001cb	0f af f9	 imul	 edi, ecx
  001ce	01 b8 a8 16 00
	00		 add	 DWORD PTR [eax+5800], edi

; 560  :                 tree[m].Len = (ush)bits;

  001d4	66 89 16	 mov	 WORD PTR [esi], dx
$LN1@gen_bitlen:

; 561  :             }
; 562  :             n--;

  001d7	ff 4d f4	 dec	 DWORD PTR _n$[ebp]
  001da	8b 7d f4	 mov	 edi, DWORD PTR _n$[ebp]
  001dd	8b 75 e0	 mov	 esi, DWORD PTR tv671[ebp]
$LN39@gen_bitlen:

; 553  :         while (n != 0) {

  001e0	85 ff		 test	 edi, edi
  001e2	75 bc		 jne	 SHORT $LL4@gen_bitlen
$LN6@gen_bitlen:

; 545  : 
; 546  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 547  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 548  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 549  :      * from 'ar' written by Haruhiko Okumura.)
; 550  :      */
; 551  :     for (bits = max_length; bits != 0; bits--) {

  001e4	8b 7d ec	 mov	 edi, DWORD PTR tv709[ebp]
  001e7	83 ef 02	 sub	 edi, 2
  001ea	4a		 dec	 edx
  001eb	89 7d ec	 mov	 DWORD PTR tv709[ebp], edi
  001ee	75 96		 jne	 SHORT $LL7@gen_bitlen
$LN5@gen_bitlen:
  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
  001f2	5b		 pop	 ebx

; 563  :         }
; 564  :     }
; 565  : }

  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
_gen_bitlen ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _pqdownheap
_TEXT	SEGMENT
_v$ = -4						; size = 4
_k$ = 8							; size = 4
_pqdownheap PROC					; COMDAT
; _s$ = eax
; _tree$ = edi

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 458  :     int v = s->heap[k];
; 459  :     int j = k << 1;  /* left son of k */
; 460  :     while (j <= s->heap_len) {

  00004	8b 90 50 14 00
	00		 mov	 edx, DWORD PTR [eax+5200]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _k$[ebp]
  0000f	8b 9c b0 5c 0b
	00 00		 mov	 ebx, DWORD PTR [eax+esi*4+2908]
  00016	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  00019	89 5d fc	 mov	 DWORD PTR _v$[ebp], ebx
  0001c	3b ca		 cmp	 ecx, edx
  0001e	0f 8f a1 00 00
	00		 jg	 $LN14@pqdownheap
$LN17@pqdownheap:

; 461  :         /* Set j to the smallest of the two sons: */
; 462  :         if (j < s->heap_len &&
; 463  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {

  00024	7d 35		 jge	 SHORT $LN16@pqdownheap
  00026	8b b4 88 60 0b
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+2912]
  0002d	8b 9c 88 5c 0b
	00 00		 mov	 ebx, DWORD PTR [eax+ecx*4+2908]
  00034	0f b7 14 b7	 movzx	 edx, WORD PTR [edi+esi*4]
  00038	0f b7 1c 9f	 movzx	 ebx, WORD PTR [edi+ebx*4]
  0003c	66 3b d3	 cmp	 dx, bx
  0003f	72 19		 jb	 SHORT $LN3@pqdownheap
  00041	75 18		 jne	 SHORT $LN16@pqdownheap
  00043	8a 94 06 58 14
	00 00		 mov	 dl, BYTE PTR [esi+eax+5208]
  0004a	8b b4 88 5c 0b
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+2908]
  00051	3a 94 06 58 14
	00 00		 cmp	 dl, BYTE PTR [esi+eax+5208]
  00058	77 01		 ja	 SHORT $LN16@pqdownheap
$LN3@pqdownheap:

; 464  :             j++;

  0005a	41		 inc	 ecx
$LN16@pqdownheap:

; 465  :         }
; 466  :         /* Exit if v is smaller than both sons */
; 467  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  0005b	8b b4 88 5c 0b
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+2908]
  00062	8b 55 fc	 mov	 edx, DWORD PTR _v$[ebp]
  00065	0f b7 14 97	 movzx	 edx, WORD PTR [edi+edx*4]
  00069	0f b7 1c b7	 movzx	 ebx, WORD PTR [edi+esi*4]
  0006d	66 3b d3	 cmp	 dx, bx
  00070	72 40		 jb	 SHORT $LN13@pqdownheap
  00072	75 13		 jne	 SHORT $LN15@pqdownheap
  00074	8b 55 fc	 mov	 edx, DWORD PTR _v$[ebp]
  00077	8a 9c 02 58 14
	00 00		 mov	 bl, BYTE PTR [edx+eax+5208]
  0007e	3a 9c 06 58 14
	00 00		 cmp	 bl, BYTE PTR [esi+eax+5208]
  00085	76 2e		 jbe	 SHORT $LN12@pqdownheap
$LN15@pqdownheap:

; 468  : 
; 469  :         /* Exchange v with the smallest son */
; 470  :         s->heap[k] = s->heap[j];  k = j;

  00087	8b 55 08	 mov	 edx, DWORD PTR _k$[ebp]
  0008a	89 b4 90 5c 0b
	00 00		 mov	 DWORD PTR [eax+edx*4+2908], esi
  00091	8b 90 50 14 00
	00		 mov	 edx, DWORD PTR [eax+5200]
  00097	8b f1		 mov	 esi, ecx

; 471  : 
; 472  :         /* And continue down the tree, setting j to the left son of k */
; 473  :         j <<= 1;

  00099	03 c9		 add	 ecx, ecx
  0009b	89 75 08	 mov	 DWORD PTR _k$[ebp], esi
  0009e	3b ca		 cmp	 ecx, edx
  000a0	7e 82		 jle	 SHORT $LN17@pqdownheap

; 474  :     }
; 475  :     s->heap[k] = v;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp]
  000a5	89 8c b0 5c 0b
	00 00		 mov	 DWORD PTR [eax+esi*4+2908], ecx
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 476  : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN13@pqdownheap:

; 474  :     }
; 475  :     s->heap[k] = v;

  000b2	8b 55 fc	 mov	 edx, DWORD PTR _v$[ebp]
$LN12@pqdownheap:
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _k$[ebp]
  000b8	5e		 pop	 esi
  000b9	89 94 88 5c 0b
	00 00		 mov	 DWORD PTR [eax+ecx*4+2908], edx
  000c0	5b		 pop	 ebx

; 476  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN14@pqdownheap:

; 474  :     }
; 475  :     s->heap[k] = v;

  000c5	89 9c b0 5c 0b
	00 00		 mov	 DWORD PTR [eax+esi*4+2908], ebx
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 476  : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_pqdownheap ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _init_block
_TEXT	SEGMENT
_init_block PROC					; COMDAT
; _s$ = edx

; 412  :     int n; /* iterates over tree elements */
; 413  : 
; 414  :     /* Initialize the trees. */
; 415  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00000	8d 82 94 00 00
	00		 lea	 eax, DWORD PTR [edx+148]
  00006	b9 1e 01 00 00	 mov	 ecx, 286		; 0000011eH
  0000b	56		 push	 esi
  0000c	8d 64 24 00	 npad	 4
$LL9@init_block:
  00010	33 f6		 xor	 esi, esi
  00012	66 89 30	 mov	 WORD PTR [eax], si
  00015	83 c0 04	 add	 eax, 4
  00018	49		 dec	 ecx
  00019	75 f5		 jne	 SHORT $LL9@init_block

; 416  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0001b	8d 82 88 09 00
	00		 lea	 eax, DWORD PTR [edx+2440]
  00021	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
$LL6@init_block:
  00026	33 f6		 xor	 esi, esi
  00028	66 89 30	 mov	 WORD PTR [eax], si
  0002b	83 c0 04	 add	 eax, 4
  0002e	49		 dec	 ecx
  0002f	75 f5		 jne	 SHORT $LL6@init_block

; 417  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  00031	8d 82 7c 0a 00
	00		 lea	 eax, DWORD PTR [edx+2684]
  00037	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  0003c	8d 64 24 00	 npad	 4
$LL3@init_block:
  00040	33 f6		 xor	 esi, esi
  00042	66 89 30	 mov	 WORD PTR [eax], si
  00045	83 c0 04	 add	 eax, 4
  00048	49		 dec	 ecx
  00049	75 f5		 jne	 SHORT $LL3@init_block

; 418  : 
; 419  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	66 89 82 94 04
	00 00		 mov	 WORD PTR [edx+1172], ax

; 420  :     s->opt_len = s->static_len = 0L;

  00057	33 c0		 xor	 eax, eax
  00059	89 82 ac 16 00
	00		 mov	 DWORD PTR [edx+5804], eax
  0005f	89 82 a8 16 00
	00		 mov	 DWORD PTR [edx+5800], eax

; 421  :     s->last_lit = s->matches = 0;

  00065	89 82 b0 16 00
	00		 mov	 DWORD PTR [edx+5808], eax
  0006b	89 82 a0 16 00
	00		 mov	 DWORD PTR [edx+5792], eax
  00071	5e		 pop	 esi

; 422  : }

  00072	c3		 ret	 0
_init_block ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tr_static_init
_TEXT	SEGMENT
_tr_static_init PROC					; COMDAT

; 236  : #if defined(GEN_TREES_H) || !defined(STDC)
; 237  :     static int static_init_done = 0;
; 238  :     int n;        /* iterates over tree elements */
; 239  :     int bits;     /* bit counter */
; 240  :     int length;   /* length value */
; 241  :     int code;     /* code value */
; 242  :     int dist;     /* distance index */
; 243  :     ush bl_count[MAX_BITS+1];
; 244  :     /* number of codes at each bit length for an optimal tree */
; 245  : 
; 246  :     if (static_init_done) return;
; 247  : 
; 248  :     /* For some embedded targets, global variables are not initialized: */
; 249  : #ifdef NO_INIT_GLOBAL_POINTERS
; 250  :     static_l_desc.static_tree = static_ltree;
; 251  :     static_l_desc.extra_bits = extra_lbits;
; 252  :     static_d_desc.static_tree = static_dtree;
; 253  :     static_d_desc.extra_bits = extra_dbits;
; 254  :     static_bl_desc.extra_bits = extra_blbits;
; 255  : #endif
; 256  : 
; 257  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 258  :     length = 0;
; 259  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 260  :         base_length[code] = length;
; 261  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 262  :             _length_code[length++] = (uch)code;
; 263  :         }
; 264  :     }
; 265  :     Assert (length == 256, "tr_static_init: length != 256");
; 266  :     /* Note that the length 255 (match length 258) can be represented
; 267  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 268  :      * overwrite length_code[255] to use the best encoding:
; 269  :      */
; 270  :     _length_code[length-1] = (uch)code;
; 271  : 
; 272  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 273  :     dist = 0;
; 274  :     for (code = 0 ; code < 16; code++) {
; 275  :         base_dist[code] = dist;
; 276  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 277  :             _dist_code[dist++] = (uch)code;
; 278  :         }
; 279  :     }
; 280  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 281  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 282  :     for ( ; code < D_CODES; code++) {
; 283  :         base_dist[code] = dist << 7;
; 284  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 285  :             _dist_code[256 + dist++] = (uch)code;
; 286  :         }
; 287  :     }
; 288  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 289  : 
; 290  :     /* Construct the codes of the static literal tree */
; 291  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 292  :     n = 0;
; 293  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 294  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 295  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 296  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 297  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 298  :      * tree construction to get a canonical Huffman tree (longest code
; 299  :      * all ones)
; 300  :      */
; 301  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 302  : 
; 303  :     /* The static distance tree is trivial: */
; 304  :     for (n = 0; n < D_CODES; n++) {
; 305  :         static_dtree[n].Len = 5;
; 306  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 307  :     }
; 308  :     static_init_done = 1;
; 309  : 
; 310  : #  ifdef GEN_TREES_H
; 311  :     gen_trees_header();
; 312  : #  endif
; 313  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 314  : }

  00000	c3		 ret	 0
_tr_static_init ENDP
; Function compile flags: /Ogtp
;	COMDAT _copy_block
_TEXT	SEGMENT
_copy_block PROC					; COMDAT
; _s$ = eax
; _buf$ = edx
; _len$ = ecx

; 1210 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b d9		 mov	 ebx, ecx
  00005	8b fa		 mov	 edi, edx

; 1211 :     bi_windup(s);        /* align on byte boundary */

  00007	e8 00 00 00 00	 call	 _bi_windup

; 1212 : 
; 1213 :     if (header) {
; 1214 :         put_short(s, (ush)len);

  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00012	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00015	ff 40 14	 inc	 DWORD PTR [eax+20]
  00018	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0001b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001e	8b cb		 mov	 ecx, ebx
  00020	c1 e9 08	 shr	 ecx, 8
  00023	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00026	ff 40 14	 inc	 DWORD PTR [eax+20]
  00029	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 1215 :         put_short(s, (ush)~len);

  0002c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002f	8a cb		 mov	 cl, bl
  00031	f6 d1		 not	 cl
  00033	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00036	ff 40 14	 inc	 DWORD PTR [eax+20]
  00039	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0003c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003f	8b cb		 mov	 ecx, ebx
  00041	f7 d1		 not	 ecx
  00043	c1 e9 08	 shr	 ecx, 8
  00046	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00049	ff 40 14	 inc	 DWORD PTR [eax+20]
  0004c	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 1216 : #ifdef DEBUG
; 1217 :         s->bits_sent += 2*16;
; 1218 : #endif
; 1219 :     }
; 1220 : #ifdef DEBUG
; 1221 :     s->bits_sent += (ulg)len<<3;
; 1222 : #endif
; 1223 :     while (len--) {

  0004f	85 db		 test	 ebx, ebx
  00051	74 12		 je	 SHORT $LN7@copy_block
$LL2@copy_block:

; 1224 :         put_byte(s, *buf++);

  00053	8a 17		 mov	 dl, BYTE PTR [edi]
  00055	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00058	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl
  0005b	ff 40 14	 inc	 DWORD PTR [eax+20]
  0005e	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00061	47		 inc	 edi
  00062	4b		 dec	 ebx
  00063	75 ee		 jne	 SHORT $LL2@copy_block
$LN7@copy_block:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 1225 :     }
; 1226 : }

  00068	c3		 ret	 0
_copy_block ENDP
_TEXT	ENDS
PUBLIC	__tr_stored_block
; Function compile flags: /Ogtp
;	COMDAT __tr_stored_block
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_stored_len$ = 12					; size = 4
__tr_stored_block PROC					; COMDAT
; _s$ = eax
; _last$ = ecx

; 870  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 871  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

  00006	8b 88 bc 16 00
	00		 mov	 ecx, DWORD PTR [eax+5820]
  0000c	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0000f	7e 5f		 jle	 SHORT $LN2@tr_stored_
  00011	66 8b d6	 mov	 dx, si
  00014	66 d3 e2	 shl	 dx, cl
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	53		 push	 ebx
  0001b	66 09 90 b8 16
	00 00		 or	 WORD PTR [eax+5816], dx
  00022	0f b6 98 b8 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5816]
  00029	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0002c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0002f	ff 40 14	 inc	 DWORD PTR [eax+20]
  00032	0f b6 98 b9 16
	00 00		 movzx	 ebx, BYTE PTR [eax+5817]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003f	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00042	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00048	ff 40 14	 inc	 DWORD PTR [eax+20]
  0004b	b1 10		 mov	 cl, 16			; 00000010H
  0004d	2a ca		 sub	 cl, dl
  0004f	66 d3 ee	 shr	 si, cl

; 872  : #ifdef DEBUG
; 873  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 874  :     s->compressed_len += (stored_len + 4) << 3;
; 875  : #endif
; 876  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _stored_len$[ebp]
  00055	83 c2 f3	 add	 edx, -13		; fffffff3H
  00058	5b		 pop	 ebx
  00059	66 89 b0 b8 16
	00 00		 mov	 WORD PTR [eax+5816], si
  00060	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00066	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00069	5e		 pop	 esi

; 877  : }

  0006a	5d		 pop	 ebp

; 872  : #ifdef DEBUG
; 873  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 874  :     s->compressed_len += (stored_len + 4) << 3;
; 875  : #endif
; 876  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  0006b	e9 00 00 00 00	 jmp	 _copy_block
$LN2@tr_stored_:
  00070	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00073	66 d3 e6	 shl	 si, cl
  00076	66 09 b0 b8 16
	00 00		 or	 WORD PTR [eax+5816], si
  0007d	83 c1 03	 add	 ecx, 3
  00080	89 88 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], ecx
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _stored_len$[ebp]
  00089	5e		 pop	 esi

; 877  : }

  0008a	5d		 pop	 ebp

; 872  : #ifdef DEBUG
; 873  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 874  :     s->compressed_len += (stored_len + 4) << 3;
; 875  : #endif
; 876  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  0008b	e9 00 00 00 00	 jmp	 _copy_block
__tr_stored_block ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _send_all_trees
_TEXT	SEGMENT
tv556 = -4						; size = 4
tv555 = -4						; size = 4
tv554 = -4						; size = 4
_lcodes$ = 8						; size = 4
_dcodes$ = 12						; size = 4
_blcodes$ = 16						; size = 4
_send_all_trees PROC					; COMDAT
; _s$ = esi

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 840  :     int rank;                    /* index in bl_order */
; 841  : 
; 842  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 843  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 844  :             "too many codes");
; 845  :     Tracev((stderr, "\nbl counts: "));
; 846  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00004	8b 45 08	 mov	 eax, DWORD PTR _lcodes$[ebp]
  00007	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  0000d	53		 push	 ebx
  0000e	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  00013	57		 push	 edi
  00014	bb 01 00 00 00	 mov	 ebx, 1
  00019	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0001c	7e 56		 jle	 SHORT $LN11@send_all_t
  0001e	66 8b d0	 mov	 dx, ax
  00021	66 d3 e2	 shl	 dx, cl
  00024	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00027	89 45 fc	 mov	 DWORD PTR tv556[ebp], eax
  0002a	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  00031	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00034	8a 86 b8 16 00
	00		 mov	 al, BYTE PTR [esi+5816]
  0003a	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0003d	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  00040	8a 96 b9 16 00
	00		 mov	 dl, BYTE PTR [esi+5817]
  00046	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00049	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004c	8b 45 fc	 mov	 eax, DWORD PTR tv556[ebp]
  0004f	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00052	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  00058	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  0005b	b1 10		 mov	 cl, 16			; 00000010H
  0005d	2a ca		 sub	 cl, dl
  0005f	66 d3 e8	 shr	 ax, cl
  00062	83 c2 f5	 add	 edx, -11		; fffffff5H
  00065	89 96 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], edx
  0006b	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  00072	eb 13		 jmp	 SHORT $LN10@send_all_t
$LN11@send_all_t:
  00074	66 d3 e0	 shl	 ax, cl
  00077	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  0007e	83 c1 05	 add	 ecx, 5
  00081	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN10@send_all_t:

; 847  :     send_bits(s, dcodes-1,   5);

  00087	8b 45 0c	 mov	 eax, DWORD PTR _dcodes$[ebp]
  0008a	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  00090	48		 dec	 eax
  00091	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00094	7e 56		 jle	 SHORT $LN9@send_all_t
  00096	66 8b d0	 mov	 dx, ax
  00099	66 d3 e2	 shl	 dx, cl
  0009c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0009f	89 45 fc	 mov	 DWORD PTR tv555[ebp], eax
  000a2	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  000a9	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000ac	8a 86 b8 16 00
	00		 mov	 al, BYTE PTR [esi+5816]
  000b2	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  000b5	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000b8	8a 96 b9 16 00
	00		 mov	 dl, BYTE PTR [esi+5817]
  000be	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  000c1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c4	8b 45 fc	 mov	 eax, DWORD PTR tv555[ebp]
  000c7	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  000ca	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  000d0	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000d3	b1 10		 mov	 cl, 16			; 00000010H
  000d5	2a ca		 sub	 cl, dl
  000d7	66 d3 e8	 shr	 ax, cl
  000da	83 c2 f5	 add	 edx, -11		; fffffff5H
  000dd	89 96 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], edx
  000e3	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  000ea	eb 13		 jmp	 SHORT $LN8@send_all_t
$LN9@send_all_t:
  000ec	66 d3 e0	 shl	 ax, cl
  000ef	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  000f6	83 c1 05	 add	 ecx, 5
  000f9	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN8@send_all_t:

; 848  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  000ff	8b 45 10	 mov	 eax, DWORD PTR _blcodes$[ebp]
  00102	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  00108	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010b	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0010e	7e 56		 jle	 SHORT $LN7@send_all_t
  00110	66 8b d0	 mov	 dx, ax
  00113	66 d3 e2	 shl	 dx, cl
  00116	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00119	89 45 fc	 mov	 DWORD PTR tv554[ebp], eax
  0011c	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  00123	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00126	8a 86 b8 16 00
	00		 mov	 al, BYTE PTR [esi+5816]
  0012c	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0012f	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  00132	8a 96 b9 16 00
	00		 mov	 dl, BYTE PTR [esi+5817]
  00138	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0013b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013e	8b 45 fc	 mov	 eax, DWORD PTR tv554[ebp]
  00141	88 14 0f	 mov	 BYTE PTR [edi+ecx], dl
  00144	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  0014a	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  0014d	b1 10		 mov	 cl, 16			; 00000010H
  0014f	2a ca		 sub	 cl, dl
  00151	66 d3 e8	 shr	 ax, cl
  00154	83 c2 f4	 add	 edx, -12		; fffffff4H
  00157	89 96 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], edx
  0015d	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  00164	eb 13		 jmp	 SHORT $LN6@send_all_t
$LN7@send_all_t:
  00166	66 d3 e0	 shl	 ax, cl
  00169	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  00170	83 c1 04	 add	 ecx, 4
  00173	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN6@send_all_t:

; 849  :     for (rank = 0; rank < blcodes; rank++) {

  00179	33 ff		 xor	 edi, edi
  0017b	39 7d 10	 cmp	 DWORD PTR _blcodes$[ebp], edi
  0017e	0f 8e 9e 00 00
	00		 jle	 $LN3@send_all_t
$LL5@send_all_t:

; 850  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 851  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  00184	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  0018a	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0018d	7e 66		 jle	 SHORT $LN2@send_all_t
  0018f	0f b6 97 00 00
	00 00		 movzx	 edx, BYTE PTR _bl_order[edi]
  00196	0f b7 84 96 7e
	0a 00 00	 movzx	 eax, WORD PTR [esi+edx*4+2686]
  0019e	66 8b d0	 mov	 dx, ax
  001a1	66 d3 e2	 shl	 dx, cl
  001a4	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001a7	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  001ae	0f b6 9e b8 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5816]
  001b5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001b8	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001bb	ff 46 14	 inc	 DWORD PTR [esi+20]
  001be	0f b6 9e b9 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5817]
  001c5	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001c8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001cb	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001ce	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  001d4	b1 10		 mov	 cl, 16			; 00000010H
  001d6	2a ca		 sub	 cl, dl
  001d8	66 d3 e8	 shr	 ax, cl
  001db	bb 01 00 00 00	 mov	 ebx, 1
  001e0	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  001e3	83 c2 f3	 add	 edx, -13		; fffffff3H
  001e6	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  001ed	89 96 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], edx
  001f3	eb 22		 jmp	 SHORT $LN4@send_all_t
$LN2@send_all_t:
  001f5	0f b6 87 00 00
	00 00		 movzx	 eax, BYTE PTR _bl_order[edi]
  001fc	66 8b 94 86 7e
	0a 00 00	 mov	 dx, WORD PTR [esi+eax*4+2686]
  00204	66 d3 e2	 shl	 dx, cl
  00207	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  0020e	83 c1 03	 add	 ecx, 3
  00211	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN4@send_all_t:

; 849  :     for (rank = 0; rank < blcodes; rank++) {

  00217	03 fb		 add	 edi, ebx
  00219	3b 7d 10	 cmp	 edi, DWORD PTR _blcodes$[ebp]
  0021c	0f 8c 62 ff ff
	ff		 jl	 $LL5@send_all_t
$LN3@send_all_t:

; 852  :     }
; 853  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 854  : 
; 855  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  00222	8b 4d 08	 mov	 ecx, DWORD PTR _lcodes$[ebp]
  00225	49		 dec	 ecx
  00226	8d 96 94 00 00
	00		 lea	 edx, DWORD PTR [esi+148]
  0022c	8b c6		 mov	 eax, esi
  0022e	e8 00 00 00 00	 call	 _send_tree

; 856  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 857  : 
; 858  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  00233	8b 4d 0c	 mov	 ecx, DWORD PTR _dcodes$[ebp]
  00236	49		 dec	 ecx
  00237	8d 96 88 09 00
	00		 lea	 edx, DWORD PTR [esi+2440]
  0023d	8b c6		 mov	 eax, esi
  0023f	e8 00 00 00 00	 call	 _send_tree
  00244	5f		 pop	 edi
  00245	5b		 pop	 ebx

; 859  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 860  : }

  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
_send_all_trees ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _build_tree
_TEXT	SEGMENT
_node$ = -8						; size = 4
_elems$ = -8						; size = 4
_max_code$ = -4						; size = 4
_desc$ = 8						; size = 4
_build_tree PROC					; COMDAT
; _s$ = esi

; 620  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 621  :     ct_data *tree         = desc->dyn_tree;

  00006	8b 45 08	 mov	 eax, DWORD PTR _desc$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 38		 mov	 edi, DWORD PTR [eax]

; 622  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 623  :     int elems             = desc->stat_desc->elems;

  00010	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00013	8b 18		 mov	 ebx, DWORD PTR [eax]

; 624  :     int n, m;          /* iterate over heap elements */
; 625  :     int max_code = -1; /* largest code with non zero frequency */

  00015	83 c9 ff	 or	 ecx, -1

; 626  :     int node;          /* new node being created */
; 627  : 
; 628  :     /* Construct the initial heap, with least frequent element in
; 629  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 630  :      * heap[0] is not used.
; 631  :      */
; 632  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;
; 633  : 
; 634  :     for (n = 0; n < elems; n++) {

  00018	33 c0		 xor	 eax, eax
  0001a	89 55 f8	 mov	 DWORD PTR _elems$[ebp], edx
  0001d	89 4d fc	 mov	 DWORD PTR _max_code$[ebp], ecx
  00020	c7 86 50 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5200], 0
  0002a	c7 86 54 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [esi+5204], 573 ; 0000023dH
  00034	85 d2		 test	 edx, edx
  00036	7e 36		 jle	 SHORT $LN22@build_tree
$LL14@build_tree:

; 635  :         if (tree[n].Freq != 0) {

  00038	66 83 3c 87 00	 cmp	 WORD PTR [edi+eax*4], 0
  0003d	74 22		 je	 SHORT $LN11@build_tree

; 636  :             s->heap[++(s->heap_len)] = max_code = n;

  0003f	ff 86 50 14 00
	00		 inc	 DWORD PTR [esi+5200]
  00045	8b 96 50 14 00
	00		 mov	 edx, DWORD PTR [esi+5200]
  0004b	89 84 96 5c 0b
	00 00		 mov	 DWORD PTR [esi+edx*4+2908], eax
  00052	89 45 fc	 mov	 DWORD PTR _max_code$[ebp], eax

; 637  :             s->depth[n] = 0;

  00055	c6 84 30 58 14
	00 00 00	 mov	 BYTE PTR [eax+esi+5208], 0

; 638  :         } else {

  0005d	8b c8		 mov	 ecx, eax
  0005f	eb 07		 jmp	 SHORT $LN13@build_tree
$LN11@build_tree:

; 639  :             tree[n].Len = 0;

  00061	33 d2		 xor	 edx, edx
  00063	66 89 54 87 02	 mov	 WORD PTR [edi+eax*4+2], dx
$LN13@build_tree:

; 626  :     int node;          /* new node being created */
; 627  : 
; 628  :     /* Construct the initial heap, with least frequent element in
; 629  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 630  :      * heap[0] is not used.
; 631  :      */
; 632  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;
; 633  : 
; 634  :     for (n = 0; n < elems; n++) {

  00068	40		 inc	 eax
  00069	3b 45 f8	 cmp	 eax, DWORD PTR _elems$[ebp]
  0006c	7c ca		 jl	 SHORT $LL14@build_tree
$LN22@build_tree:

; 640  :         }
; 641  :     }
; 642  : 
; 643  :     /* The pkzip format requires that at least one distance code exists,
; 644  :      * and that at least one bit should be sent even if there is only one
; 645  :      * possible code. So to avoid special checks later on we force at least
; 646  :      * two codes of non zero frequency.
; 647  :      */
; 648  :     while (s->heap_len < 2) {

  0006e	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  00075	7d 51		 jge	 SHORT $LN8@build_tree
$LL9@build_tree:

; 649  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  00077	83 f9 02	 cmp	 ecx, 2
  0007a	7d 05		 jge	 SHORT $LN17@build_tree
  0007c	41		 inc	 ecx
  0007d	8b c1		 mov	 eax, ecx
  0007f	eb 02		 jmp	 SHORT $LN18@build_tree
$LN17@build_tree:
  00081	33 c0		 xor	 eax, eax
$LN18@build_tree:
  00083	ff 86 50 14 00
	00		 inc	 DWORD PTR [esi+5200]
  00089	8b 96 50 14 00
	00		 mov	 edx, DWORD PTR [esi+5200]
  0008f	89 84 96 5c 0b
	00 00		 mov	 DWORD PTR [esi+edx*4+2908], eax

; 650  :         tree[node].Freq = 1;

  00096	ba 01 00 00 00	 mov	 edx, 1
  0009b	66 89 14 87	 mov	 WORD PTR [edi+eax*4], dx

; 651  :         s->depth[node] = 0;

  0009f	c6 84 06 58 14
	00 00 00	 mov	 BYTE PTR [esi+eax+5208], 0

; 652  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000a7	ff 8e a8 16 00
	00		 dec	 DWORD PTR [esi+5800]
  000ad	85 db		 test	 ebx, ebx
  000af	74 0b		 je	 SHORT $LN7@build_tree
  000b1	0f b7 44 83 02	 movzx	 eax, WORD PTR [ebx+eax*4+2]
  000b6	29 86 ac 16 00
	00		 sub	 DWORD PTR [esi+5804], eax
$LN7@build_tree:

; 640  :         }
; 641  :     }
; 642  : 
; 643  :     /* The pkzip format requires that at least one distance code exists,
; 644  :      * and that at least one bit should be sent even if there is only one
; 645  :      * possible code. So to avoid special checks later on we force at least
; 646  :      * two codes of non zero frequency.
; 647  :      */
; 648  :     while (s->heap_len < 2) {

  000bc	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  000c3	7c b2		 jl	 SHORT $LL9@build_tree

; 649  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  000c5	89 4d fc	 mov	 DWORD PTR _max_code$[ebp], ecx
$LN8@build_tree:

; 653  :         /* node is 0 or 1 so it does not have extra bits */
; 654  :     }
; 655  :     desc->max_code = max_code;

  000c8	8b 55 08	 mov	 edx, DWORD PTR _desc$[ebp]
  000cb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 656  : 
; 657  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 658  :      * establish sub-heaps of increasing lengths:
; 659  :      */
; 660  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  000ce	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  000d4	99		 cdq
  000d5	2b c2		 sub	 eax, edx
  000d7	8b d8		 mov	 ebx, eax
  000d9	d1 fb		 sar	 ebx, 1
  000db	83 fb 01	 cmp	 ebx, 1
  000de	7c 11		 jl	 SHORT $LN4@build_tree
$LL6@build_tree:
  000e0	53		 push	 ebx
  000e1	8b c6		 mov	 eax, esi
  000e3	e8 00 00 00 00	 call	 _pqdownheap
  000e8	4b		 dec	 ebx
  000e9	83 c4 04	 add	 esp, 4
  000ec	83 fb 01	 cmp	 ebx, 1
  000ef	7d ef		 jge	 SHORT $LL6@build_tree
$LN4@build_tree:

; 661  : 
; 662  :     /* Construct the Huffman tree by repeatedly combining the least two
; 663  :      * frequent nodes.
; 664  :      */
; 665  :     node = elems;              /* next internal node of the tree */

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _elems$[ebp]
  000f4	89 45 f8	 mov	 DWORD PTR _node$[ebp], eax
  000f7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL3@build_tree:

; 666  :     do {
; 667  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00100	8b 86 50 14 00
	00		 mov	 eax, DWORD PTR [esi+5200]
  00106	8b 8c 86 5c 0b
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+2908]
  0010d	8b 9e 60 0b 00
	00		 mov	 ebx, DWORD PTR [esi+2912]
  00113	48		 dec	 eax
  00114	89 86 50 14 00
	00		 mov	 DWORD PTR [esi+5200], eax
  0011a	6a 01		 push	 1
  0011c	8b c6		 mov	 eax, esi
  0011e	89 8e 60 0b 00
	00		 mov	 DWORD PTR [esi+2912], ecx
  00124	e8 00 00 00 00	 call	 _pqdownheap

; 668  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */

  00129	8b 86 60 0b 00
	00		 mov	 eax, DWORD PTR [esi+2912]

; 669  : 
; 670  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  0012f	83 ca ff	 or	 edx, -1
  00132	01 96 54 14 00
	00		 add	 DWORD PTR [esi+5204], edx
  00138	8b 8e 54 14 00
	00		 mov	 ecx, DWORD PTR [esi+5204]
  0013e	89 9c 8e 5c 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2908], ebx

; 671  :         s->heap[--(s->heap_max)] = m;

  00145	01 96 54 14 00
	00		 add	 DWORD PTR [esi+5204], edx
  0014b	8b 8e 54 14 00
	00		 mov	 ecx, DWORD PTR [esi+5204]
  00151	89 84 8e 5c 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2908], eax

; 672  : 
; 673  :         /* Create a new node father of n and m */
; 674  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  00158	66 8b 14 87	 mov	 dx, WORD PTR [edi+eax*4]
  0015c	66 03 14 9f	 add	 dx, WORD PTR [edi+ebx*4]
  00160	8b 4d f8	 mov	 ecx, DWORD PTR _node$[ebp]
  00163	66 89 14 8f	 mov	 WORD PTR [edi+ecx*4], dx

; 675  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
; 676  :                                 s->depth[n] : s->depth[m]) + 1);

  00167	8a 94 1e 58 14
	00 00		 mov	 dl, BYTE PTR [esi+ebx+5208]
  0016e	8a 8c 06 58 14
	00 00		 mov	 cl, BYTE PTR [esi+eax+5208]
  00175	83 c4 04	 add	 esp, 4
  00178	3a d1		 cmp	 dl, cl
  0017a	0f b6 d2	 movzx	 edx, dl
  0017d	73 03		 jae	 SHORT $LN20@build_tree
  0017f	0f b6 d1	 movzx	 edx, cl
$LN20@build_tree:
  00182	8b 4d f8	 mov	 ecx, DWORD PTR _node$[ebp]
  00185	fe c2		 inc	 dl
  00187	88 94 0e 58 14
	00 00		 mov	 BYTE PTR [esi+ecx+5208], dl

; 677  :         tree[n].Dad = tree[m].Dad = (ush)node;

  0018e	0f b7 d1	 movzx	 edx, cx
  00191	66 89 54 87 02	 mov	 WORD PTR [edi+eax*4+2], dx
  00196	66 89 54 9f 02	 mov	 WORD PTR [edi+ebx*4+2], dx

; 678  : #ifdef DUMP_BL_TREE
; 679  :         if (tree == s->bl_tree) {
; 680  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 681  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 682  :         }
; 683  : #endif
; 684  :         /* and insert the new node in the heap */
; 685  :         s->heap[SMALLEST] = node++;

  0019b	89 8e 60 0b 00
	00		 mov	 DWORD PTR [esi+2912], ecx
  001a1	41		 inc	 ecx

; 686  :         pqdownheap(s, tree, SMALLEST);

  001a2	6a 01		 push	 1
  001a4	8b c6		 mov	 eax, esi
  001a6	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx
  001a9	e8 00 00 00 00	 call	 _pqdownheap
  001ae	83 c4 04	 add	 esp, 4

; 687  : 
; 688  :     } while (s->heap_len >= 2);

  001b1	83 be 50 14 00
	00 02		 cmp	 DWORD PTR [esi+5200], 2
  001b8	0f 8d 42 ff ff
	ff		 jge	 $LL3@build_tree

; 689  : 
; 690  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  001be	ff 8e 54 14 00
	00		 dec	 DWORD PTR [esi+5204]
  001c4	8b 86 54 14 00
	00		 mov	 eax, DWORD PTR [esi+5204]
  001ca	8b 96 60 0b 00
	00		 mov	 edx, DWORD PTR [esi+2912]

; 691  : 
; 692  :     /* At this point, the fields freq and dad are set. We can now
; 693  :      * generate the bit lengths.
; 694  :      */
; 695  :     gen_bitlen(s, (tree_desc *)desc);

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _desc$[ebp]
  001d3	89 94 86 5c 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2908], edx
  001da	8b c6		 mov	 eax, esi
  001dc	e8 00 00 00 00	 call	 _gen_bitlen

; 696  : 
; 697  :     /* The field len is now set, we can generate the bit codes */
; 698  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  001e1	8b 5d fc	 mov	 ebx, DWORD PTR _max_code$[ebp]
  001e4	8d 96 3c 0b 00
	00		 lea	 edx, DWORD PTR [esi+2876]
  001ea	e8 00 00 00 00	 call	 _gen_codes
  001ef	5f		 pop	 edi
  001f0	5b		 pop	 ebx

; 699  : }

  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
_build_tree ENDP
_TEXT	ENDS
PUBLIC	__tr_init
; Function compile flags: /Ogtp
;	COMDAT __tr_init
_TEXT	SEGMENT
__tr_init PROC						; COMDAT
; _s$ = edx

; 384  :     tr_static_init();
; 385  : 
; 386  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00000	8d 82 94 00 00
	00		 lea	 eax, DWORD PTR [edx+148]

; 387  :     s->l_desc.stat_desc = &static_l_desc;
; 388  : 
; 389  :     s->d_desc.dyn_tree = s->dyn_dtree;

  00006	8d 8a 88 09 00
	00		 lea	 ecx, DWORD PTR [edx+2440]
  0000c	89 82 18 0b 00
	00		 mov	 DWORD PTR [edx+2840], eax
  00012	89 8a 24 0b 00
	00		 mov	 DWORD PTR [edx+2852], ecx

; 390  :     s->d_desc.stat_desc = &static_d_desc;
; 391  : 
; 392  :     s->bl_desc.dyn_tree = s->bl_tree;
; 393  :     s->bl_desc.stat_desc = &static_bl_desc;
; 394  : 
; 395  :     s->bi_buf = 0;

  00018	33 c9		 xor	 ecx, ecx
  0001a	8d 82 7c 0a 00
	00		 lea	 eax, DWORD PTR [edx+2684]
  00020	c7 82 20 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2848], OFFSET _static_l_desc
  0002a	c7 82 2c 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2860], OFFSET _static_d_desc
  00034	89 82 30 0b 00
	00		 mov	 DWORD PTR [edx+2864], eax
  0003a	c7 82 38 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2872], OFFSET _static_bl_desc
  00044	66 89 8a b8 16
	00 00		 mov	 WORD PTR [edx+5816], cx

; 396  :     s->bi_valid = 0;

  0004b	89 8a bc 16 00
	00		 mov	 DWORD PTR [edx+5820], ecx

; 397  : #ifdef DEBUG
; 398  :     s->compressed_len = 0L;
; 399  :     s->bits_sent = 0L;
; 400  : #endif
; 401  : 
; 402  :     /* Initialize the first block of the first file: */
; 403  :     init_block(s);

  00051	e9 00 00 00 00	 jmp	 _init_block
__tr_init ENDP
; Function compile flags: /Ogtp
;	COMDAT _build_bl_tree
_TEXT	SEGMENT
_build_bl_tree PROC					; COMDAT
; _s$ = eax

; 803  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 804  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 805  : 
; 806  :     /* Determine the bit length frequencies for literal and distance trees */
; 807  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00003	8b 86 1c 0b 00
	00		 mov	 eax, DWORD PTR [esi+2844]
  00009	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _scan_tree

; 808  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  00015	8b 86 28 0b 00
	00		 mov	 eax, DWORD PTR [esi+2856]
  0001b	8d 8e 88 09 00
	00		 lea	 ecx, DWORD PTR [esi+2440]
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _scan_tree

; 809  : 
; 810  :     /* Build the bit length tree: */
; 811  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  00027	8d 86 30 0b 00
	00		 lea	 eax, DWORD PTR [esi+2864]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _build_tree
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 812  :     /* opt_len now includes the length of the tree representations, except
; 813  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 814  :      */
; 815  : 
; 816  :     /* Determine the number of bit length codes to send. The pkzip format
; 817  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 818  :      * 3 but the actual value used is 4.)
; 819  :      */
; 820  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  00036	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  0003b	eb 03 8d 49 00	 npad	 5
$LL4@build_bl_t:

; 821  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00040	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bl_order[eax]
  00047	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00050	75 69		 jne	 SHORT $LN8@build_bl_t
  00052	0f b6 90 ff ff
	ff ff		 movzx	 edx, BYTE PTR _bl_order[eax-1]
  00059	66 83 bc 96 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+edx*4+2686], 0
  00062	75 38		 jne	 SHORT $LN10@build_bl_t
  00064	0f b6 88 fe ff
	ff ff		 movzx	 ecx, BYTE PTR _bl_order[eax-2]
  0006b	66 83 bc 8e 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2686], 0
  00074	75 33		 jne	 SHORT $LN11@build_bl_t
  00076	0f b6 90 fd ff
	ff ff		 movzx	 edx, BYTE PTR _bl_order[eax-3]
  0007d	66 83 bc 96 7e
	0a 00 00 00	 cmp	 WORD PTR [esi+edx*4+2686], 0
  00086	75 30		 jne	 SHORT $LN12@build_bl_t

; 812  :     /* opt_len now includes the length of the tree representations, except
; 813  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 814  :      */
; 815  : 
; 816  :     /* Determine the number of bit length codes to send. The pkzip format
; 817  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 818  :      * 3 but the actual value used is 4.)
; 819  :      */
; 820  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  00088	83 e8 04	 sub	 eax, 4
  0008b	83 f8 03	 cmp	 eax, 3
  0008e	7d b0		 jge	 SHORT $LL4@build_bl_t

; 822  :     }
; 823  :     /* Update opt_len to include the bit length tree and counts */
; 824  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  00090	8d 4c 40 11	 lea	 ecx, DWORD PTR [eax+eax*2+17]
  00094	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  0009a	5e		 pop	 esi

; 825  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 826  :             s->opt_len, s->static_len));
; 827  : 
; 828  :     return max_blindex;
; 829  : }

  0009b	c3		 ret	 0
$LN10@build_bl_t:

; 821  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  0009c	48		 dec	 eax

; 822  :     }
; 823  :     /* Update opt_len to include the bit length tree and counts */
; 824  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  0009d	8d 4c 40 11	 lea	 ecx, DWORD PTR [eax+eax*2+17]
  000a1	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000a7	5e		 pop	 esi

; 825  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 826  :             s->opt_len, s->static_len));
; 827  : 
; 828  :     return max_blindex;
; 829  : }

  000a8	c3		 ret	 0
$LN11@build_bl_t:

; 821  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000a9	83 e8 02	 sub	 eax, 2

; 822  :     }
; 823  :     /* Update opt_len to include the bit length tree and counts */
; 824  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000ac	8d 4c 40 11	 lea	 ecx, DWORD PTR [eax+eax*2+17]
  000b0	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000b6	5e		 pop	 esi

; 825  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 826  :             s->opt_len, s->static_len));
; 827  : 
; 828  :     return max_blindex;
; 829  : }

  000b7	c3		 ret	 0
$LN12@build_bl_t:

; 821  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000b8	83 e8 03	 sub	 eax, 3
$LN8@build_bl_t:

; 822  :     }
; 823  :     /* Update opt_len to include the bit length tree and counts */
; 824  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  000bb	8d 4c 40 11	 lea	 ecx, DWORD PTR [eax+eax*2+17]
  000bf	01 8e a8 16 00
	00		 add	 DWORD PTR [esi+5800], ecx
  000c5	5e		 pop	 esi

; 825  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 826  :             s->opt_len, s->static_len));
; 827  : 
; 828  :     return max_blindex;
; 829  : }

  000c6	c3		 ret	 0
_build_bl_tree ENDP
PUBLIC	__tr_flush_block
; Function compile flags: /Ogtp
;	COMDAT __tr_flush_block
_TEXT	SEGMENT
_max_blindex$ = -4					; size = 4
_buf$ = 8						; size = 4
_last$ = 12						; size = 4
__tr_flush_block PROC					; COMDAT
; _s$ = ecx
; _stored_len$ = eax

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 913  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 914  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */
; 915  : 
; 916  :     /* Build the Huffman trees unless a stored block is forced */
; 917  :     if (s->level > 0) {

  00008	83 be 84 00 00
	00 00		 cmp	 DWORD PTR [esi+132], 0
  0000f	57		 push	 edi
  00010	8b d8		 mov	 ebx, eax
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _max_blindex$[ebp], 0
  00019	7e 53		 jle	 SHORT $LN14@tr_flush_b

; 918  : 
; 919  :         /* Check if the file is binary or text */
; 920  :         if (s->strm->data_type == Z_UNKNOWN)

  0001b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001d	83 7f 2c 02	 cmp	 DWORD PTR [edi+44], 2
  00021	75 08		 jne	 SHORT $LN13@tr_flush_b

; 921  :             s->strm->data_type = detect_data_type(s);

  00023	e8 00 00 00 00	 call	 _detect_data_type
  00028	89 47 2c	 mov	 DWORD PTR [edi+44], eax
$LN13@tr_flush_b:

; 922  : 
; 923  :         /* Construct the literal and distance trees */
; 924  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  0002b	8d 86 18 0b 00
	00		 lea	 eax, DWORD PTR [esi+2840]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _build_tree

; 925  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 926  :                 s->static_len));
; 927  : 
; 928  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  00037	8d 8e 24 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2852]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 _build_tree
  00043	83 c4 08	 add	 esp, 8

; 929  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 930  :                 s->static_len));
; 931  :         /* At this point, opt_len and static_len are the total bit lengths of
; 932  :          * the compressed block data, excluding the tree representations.
; 933  :          */
; 934  : 
; 935  :         /* Build the bit length tree for the above two trees, and get the index
; 936  :          * in bl_order of the last bit length code to send.
; 937  :          */
; 938  :         max_blindex = build_bl_tree(s);

  00046	8b c6		 mov	 eax, esi
  00048	e8 00 00 00 00	 call	 _build_bl_tree

; 939  : 
; 940  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 941  :         opt_lenb = (s->opt_len+3+7)>>3;

  0004d	8b 96 a8 16 00
	00		 mov	 edx, DWORD PTR [esi+5800]

; 942  :         static_lenb = (s->static_len+3+7)>>3;

  00053	8b 8e ac 16 00
	00		 mov	 ecx, DWORD PTR [esi+5804]
  00059	83 c2 0a	 add	 edx, 10			; 0000000aH
  0005c	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0005f	c1 ea 03	 shr	 edx, 3
  00062	c1 e9 03	 shr	 ecx, 3
  00065	89 45 fc	 mov	 DWORD PTR _max_blindex$[ebp], eax

; 943  : 
; 944  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 945  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 946  :                 s->last_lit));
; 947  : 
; 948  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

  00068	3b ca		 cmp	 ecx, edx
  0006a	77 07		 ja	 SHORT $LN17@tr_flush_b

; 949  : 
; 950  :     } else {

  0006c	eb 03		 jmp	 SHORT $LN18@tr_flush_b
$LN14@tr_flush_b:

; 951  :         Assert(buf != (char*)0, "lost buf");
; 952  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  0006e	8d 4b 05	 lea	 ecx, DWORD PTR [ebx+5]
$LN18@tr_flush_b:
  00071	8b d1		 mov	 edx, ecx
$LN17@tr_flush_b:

; 953  :     }
; 954  : 
; 955  : #ifdef FORCE_STORED
; 956  :     if (buf != (char*)0) { /* force stored block */
; 957  : #else
; 958  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  00073	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00076	3b c2		 cmp	 eax, edx
  00078	77 18		 ja	 SHORT $LN10@tr_flush_b
  0007a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 11		 je	 SHORT $LN10@tr_flush_b

; 959  :                        /* 4: two words for the lengths */
; 960  : #endif
; 961  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 962  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 963  :          * the last block flush, because compression would have been
; 964  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 965  :          * transform a block into a stored block.
; 966  :          */
; 967  :         _tr_stored_block(s, buf, stored_len, last);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00084	53		 push	 ebx
  00085	50		 push	 eax
  00086	8b c6		 mov	 eax, esi
  00088	e8 00 00 00 00	 call	 __tr_stored_block
  0008d	e9 55 01 00 00	 jmp	 $LN19@tr_flush_b
$LN10@tr_flush_b:

; 968  : 
; 969  : #ifdef FORCE_STATIC
; 970  :     } else if (static_lenb >= 0) { /* force static trees */
; 971  : #else
; 972  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

  00092	83 be 88 00 00
	00 04		 cmp	 DWORD PTR [esi+136], 4
  00099	0f 84 bc 00 00
	00		 je	 $LN7@tr_flush_b
  0009f	3b ca		 cmp	 ecx, edx
  000a1	0f 84 b4 00 00
	00		 je	 $LN7@tr_flush_b

; 977  : #ifdef DEBUG
; 978  :         s->compressed_len += 3 + s->static_len;
; 979  : #endif
; 980  :     } else {
; 981  :         send_bits(s, (DYN_TREES<<1)+last, 3);

  000a7	8b 55 0c	 mov	 edx, DWORD PTR _last$[ebp]
  000aa	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  000b0	83 c2 04	 add	 edx, 4
  000b3	bf 01 00 00 00	 mov	 edi, 1
  000b8	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000bb	7e 52		 jle	 SHORT $LN3@tr_flush_b
  000bd	66 8b c2	 mov	 ax, dx
  000c0	66 d3 e0	 shl	 ax, cl
  000c3	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000c6	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  000cd	0f b6 9e b8 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5816]
  000d4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d7	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000da	01 7e 14	 add	 DWORD PTR [esi+20], edi
  000dd	0f b6 9e b9 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5817]
  000e4	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000e7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ea	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000ed	8b 9e bc 16 00
	00		 mov	 ebx, DWORD PTR [esi+5820]
  000f3	01 7e 14	 add	 DWORD PTR [esi+20], edi
  000f6	b1 10		 mov	 cl, 16			; 00000010H
  000f8	2a cb		 sub	 cl, bl
  000fa	66 d3 ea	 shr	 dx, cl
  000fd	83 c3 f3	 add	 ebx, -13		; fffffff3H
  00100	89 9e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ebx
  00106	66 89 96 b8 16
	00 00		 mov	 WORD PTR [esi+5816], dx
  0010d	eb 13		 jmp	 SHORT $LN2@tr_flush_b
$LN3@tr_flush_b:
  0010f	66 d3 e2	 shl	 dx, cl
  00112	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  00119	83 c1 03	 add	 ecx, 3
  0011c	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN2@tr_flush_b:

; 982  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
; 983  :                        max_blindex+1);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _max_blindex$[ebp]
  00125	8b 8e 28 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2856]
  0012b	8b 96 1c 0b 00
	00		 mov	 edx, DWORD PTR [esi+2844]
  00131	40		 inc	 eax
  00132	50		 push	 eax
  00133	03 cf		 add	 ecx, edi
  00135	51		 push	 ecx
  00136	03 d7		 add	 edx, edi
  00138	52		 push	 edx
  00139	e8 00 00 00 00	 call	 _send_all_trees

; 984  :         compress_block(s, (const ct_data *)s->dyn_ltree,
; 985  :                        (const ct_data *)s->dyn_dtree);

  0013e	8d 86 88 09 00
	00		 lea	 eax, DWORD PTR [esi+2440]
  00144	50		 push	 eax
  00145	8d 8e 94 00 00
	00		 lea	 ecx, DWORD PTR [esi+148]
  0014b	51		 push	 ecx
  0014c	8b c6		 mov	 eax, esi
  0014e	e8 00 00 00 00	 call	 _compress_block
  00153	83 c4 14	 add	 esp, 20			; 00000014H
  00156	e9 8f 00 00 00	 jmp	 $LN4@tr_flush_b
$LN7@tr_flush_b:

; 973  : #endif
; 974  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

  0015b	8b 45 0c	 mov	 eax, DWORD PTR _last$[ebp]
  0015e	8b 8e bc 16 00
	00		 mov	 ecx, DWORD PTR [esi+5820]
  00164	83 c0 02	 add	 eax, 2
  00167	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0016a	7e 57		 jle	 SHORT $LN6@tr_flush_b
  0016c	66 8b d0	 mov	 dx, ax
  0016f	66 d3 e2	 shl	 dx, cl
  00172	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00175	bf 01 00 00 00	 mov	 edi, 1
  0017a	66 09 96 b8 16
	00 00		 or	 WORD PTR [esi+5816], dx
  00181	0f b6 9e b8 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5816]
  00188	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0018b	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0018e	01 7e 14	 add	 DWORD PTR [esi+20], edi
  00191	0f b6 9e b9 16
	00 00		 movzx	 ebx, BYTE PTR [esi+5817]
  00198	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0019b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0019e	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001a1	8b 96 bc 16 00
	00		 mov	 edx, DWORD PTR [esi+5820]
  001a7	01 7e 14	 add	 DWORD PTR [esi+20], edi
  001aa	b1 10		 mov	 cl, 16			; 00000010H
  001ac	2a ca		 sub	 cl, dl
  001ae	66 d3 e8	 shr	 ax, cl
  001b1	83 c2 f3	 add	 edx, -13		; fffffff3H
  001b4	89 96 bc 16 00
	00		 mov	 DWORD PTR [esi+5820], edx
  001ba	66 89 86 b8 16
	00 00		 mov	 WORD PTR [esi+5816], ax
  001c1	eb 13		 jmp	 SHORT $LN5@tr_flush_b
$LN6@tr_flush_b:
  001c3	66 d3 e0	 shl	 ax, cl
  001c6	66 09 86 b8 16
	00 00		 or	 WORD PTR [esi+5816], ax
  001cd	83 c1 03	 add	 ecx, 3
  001d0	89 8e bc 16 00
	00		 mov	 DWORD PTR [esi+5820], ecx
$LN5@tr_flush_b:

; 975  :         compress_block(s, (const ct_data *)static_ltree,
; 976  :                        (const ct_data *)static_dtree);

  001d6	68 00 00 00 00	 push	 OFFSET _static_dtree
  001db	68 00 00 00 00	 push	 OFFSET _static_ltree
  001e0	8b c6		 mov	 eax, esi
  001e2	e8 00 00 00 00	 call	 _compress_block
$LN19@tr_flush_b:
  001e7	83 c4 08	 add	 esp, 8
$LN4@tr_flush_b:

; 986  : #ifdef DEBUG
; 987  :         s->compressed_len += 3 + s->opt_len;
; 988  : #endif
; 989  :     }
; 990  :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 991  :     /* The above check is made mod 2^32, for files larger than 512 MB
; 992  :      * and uLong implemented on 32 bits.
; 993  :      */
; 994  :     init_block(s);

  001ea	8b d6		 mov	 edx, esi
  001ec	e8 00 00 00 00	 call	 _init_block

; 995  : 
; 996  :     if (last) {

  001f1	83 7d 0c 00	 cmp	 DWORD PTR _last$[ebp], 0
  001f5	74 07		 je	 SHORT $LN1@tr_flush_b

; 997  :         bi_windup(s);

  001f7	8b c6		 mov	 eax, esi
  001f9	e8 00 00 00 00	 call	 _bi_windup
$LN1@tr_flush_b:
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx

; 998  : #ifdef DEBUG
; 999  :         s->compressed_len += 7;  /* align on byte boundary */
; 1000 : #endif
; 1001 :     }
; 1002 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1003 :            s->compressed_len-7*last));
; 1004 : }

  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c3		 ret	 0
__tr_flush_block ENDP
END
