; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	_memchr:PROC
EXTRN	_strerror:PROC
EXTRN	__errno:PROC
EXTRN	_read:PROC
EXTRN	_close:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
PUBLIC	_gzclose_r@4
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\gzread.c
;	COMDAT _gzclose_r@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_r@4 PROC					; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 570  :     int ret, err;
; 571  :     gz_statep state;
; 572  : 
; 573  :     /* get internal structure */
; 574  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 0a		 jne	 SHORT $LN3@gzclose_r
$LN8@gzclose_r:

; 575  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 594  : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@gzclose_r:

; 576  :     state = (gz_statep)file;
; 577  : 
; 578  :     /* check that we're reading */
; 579  :     if (state->mode != GZ_READ)

  00015	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH

; 580  :         return Z_STREAM_ERROR;

  0001c	75 ed		 jne	 SHORT $LN8@gzclose_r

; 581  : 
; 582  :     /* free memory and close file */
; 583  :     if (state->size) {

  0001e	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00022	74 1e		 je	 SHORT $LN1@gzclose_r

; 584  :         inflateEnd(&(state->strm));

  00024	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _inflateEnd@4

; 585  :         free(state->out);

  0002d	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _free

; 586  :         free(state->in);

  00036	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _free
  0003f	83 c4 08	 add	 esp, 8
$LN1@gzclose_r:

; 587  :     }
; 588  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  00042	33 c0		 xor	 eax, eax
  00044	83 7e 5c fb	 cmp	 DWORD PTR [esi+92], -5	; fffffffbH
  00048	53		 push	 ebx
  00049	0f 95 c0	 setne	 al
  0004c	57		 push	 edi

; 589  :     gz_error(state, Z_OK, NULL);

  0004d	33 db		 xor	 ebx, ebx
  0004f	8b ce		 mov	 ecx, esi
  00051	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  00054	33 c0		 xor	 eax, eax
  00056	83 e7 fb	 and	 edi, -5			; fffffffbH
  00059	e8 00 00 00 00	 call	 _gz_error

; 590  :     free(state->path);

  0005e	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _free

; 591  :     ret = close(state->fd);

  00067	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _close

; 592  :     free(state);

  00070	56		 push	 esi
  00071	8b d8		 mov	 ebx, eax
  00073	e8 00 00 00 00	 call	 _free
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 593  :     return ret ? Z_ERRNO : err;

  0007b	85 db		 test	 ebx, ebx
  0007d	74 0a		 je	 SHORT $LN6@gzclose_r
  0007f	5f		 pop	 edi
  00080	5b		 pop	 ebx
  00081	83 c8 ff	 or	 eax, -1
  00084	5e		 pop	 esi

; 594  : }

  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
$LN6@gzclose_r:

; 593  :     return ret ? Z_ERRNO : err;

  00089	8b c7		 mov	 eax, edi
  0008b	5f		 pop	 edi
  0008c	5b		 pop	 ebx
  0008d	5e		 pop	 esi

; 594  : }

  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
_gzclose_r@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_load
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_gz_load PROC						; COMDAT
; _state$ = edi
; _len$ = eax
; _have$ = esi

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d8		 mov	 ebx, eax

; 26   :     int ret;
; 27   : 
; 28   :     *have = 0;

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000c	8d 64 24 00	 npad	 4
$LL6@gz_load:

; 29   :     do {
; 30   :         ret = read(state->fd, buf + *have, len - *have);

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	8b cb		 mov	 ecx, ebx
  00014	2b c8		 sub	 ecx, eax
  00016	03 45 08	 add	 eax, DWORD PTR _buf$[ebp]
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _read
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31   :         if (ret <= 0)

  00027	85 c0		 test	 eax, eax
  00029	7e 08		 jle	 SHORT $LN11@gz_load

; 32   :             break;
; 33   :         *have += ret;

  0002b	01 06		 add	 DWORD PTR [esi], eax

; 34   :     } while (*have < len);

  0002d	39 1e		 cmp	 DWORD PTR [esi], ebx
  0002f	72 df		 jb	 SHORT $LL6@gz_load

; 35   :     if (ret < 0) {

  00031	85 c0		 test	 eax, eax
$LN11@gz_load:
  00033	79 22		 jns	 SHORT $LN2@gz_load

; 36   :         gz_error(state, Z_ERRNO, zstrerror());

  00035	e8 00 00 00 00	 call	 __errno
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _strerror
  00042	8b d8		 mov	 ebx, eax
  00044	83 c4 04	 add	 esp, 4
  00047	83 c8 ff	 or	 eax, -1
  0004a	8b cf		 mov	 ecx, edi
  0004c	e8 00 00 00 00	 call	 _gz_error

; 37   :         return -1;

  00051	83 c8 ff	 or	 eax, -1
  00054	5b		 pop	 ebx

; 42   : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN2@gz_load:

; 38   :     }
; 39   :     if (ret == 0)

  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN1@gz_load

; 40   :         state->eof = 1;

  0005b	c7 47 40 01 00
	00 00		 mov	 DWORD PTR [edi+64], 1
$LN1@gz_load:

; 41   :     return 0;

  00062	33 c0		 xor	 eax, eax
  00064	5b		 pop	 ebx

; 42   : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_gz_load ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_avail
_TEXT	SEGMENT
_got$ = -4						; size = 4
_gz_avail PROC						; COMDAT
; _state$ = eax

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax

; 54   :     unsigned got;
; 55   :     z_streamp strm = &(state->strm);
; 56   : 
; 57   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00007	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0d		 je	 SHORT $LN7@gz_avail
  0000e	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  00011	74 08		 je	 SHORT $LN7@gz_avail
$LN11@gz_avail:

; 58   :         return -1;

  00013	83 c8 ff	 or	 eax, -1
  00016	5f		 pop	 edi

; 75   : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN7@gz_avail:

; 59   :     if (state->eof == 0) {

  0001b	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  0001f	75 43		 jne	 SHORT $LN6@gz_avail

; 60   :         if (strm->avail_in) {       /* copy what's there to the start */

  00021	56		 push	 esi
  00022	8b 77 68	 mov	 esi, DWORD PTR [edi+104]
  00025	85 f6		 test	 esi, esi
  00027	74 10		 je	 SHORT $LN2@gz_avail

; 61   :             unsigned char *p = state->in;

  00029	8b 47 24	 mov	 eax, DWORD PTR [edi+36]

; 62   :             unsigned const char *q = strm->next_in;

  0002c	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  0002f	90		 npad	 1
$LL4@gz_avail:

; 63   :             unsigned n = strm->avail_in;
; 64   :             do {
; 65   :                 *p++ = *q++;

  00030	8a 11		 mov	 dl, BYTE PTR [ecx]
  00032	88 10		 mov	 BYTE PTR [eax], dl
  00034	40		 inc	 eax
  00035	41		 inc	 ecx

; 66   :             } while (--n);

  00036	4e		 dec	 esi
  00037	75 f7		 jne	 SHORT $LL4@gz_avail
$LN2@gz_avail:

; 67   :         }
; 68   :         if (gz_load(state, state->in + strm->avail_in,
; 69   :                     state->size - strm->avail_in, &got) == -1)

  00039	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  0003c	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  0003f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00042	03 d1		 add	 edx, ecx
  00044	2b c1		 sub	 eax, ecx
  00046	52		 push	 edx
  00047	8d 75 fc	 lea	 esi, DWORD PTR _got$[ebp]
  0004a	e8 00 00 00 00	 call	 _gz_load
  0004f	83 c4 04	 add	 esp, 4
  00052	5e		 pop	 esi
  00053	83 f8 ff	 cmp	 eax, -1

; 70   :             return -1;

  00056	74 bb		 je	 SHORT $LN11@gz_avail

; 71   :         strm->avail_in += got;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _got$[ebp]
  0005b	01 47 68	 add	 DWORD PTR [edi+104], eax

; 72   :         strm->next_in = state->in;

  0005e	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00061	89 4f 64	 mov	 DWORD PTR [edi+100], ecx
$LN6@gz_avail:

; 73   :     }
; 74   :     return 0;

  00064	33 c0		 xor	 eax, eax
  00066	5f		 pop	 edi

; 75   : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_gz_avail ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_decomp
_TEXT	SEGMENT
_had$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_decomp PROC						; COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 175  :     int ret = Z_OK;
; 176  :     unsigned had;
; 177  :     z_streamp strm = &(state->strm);

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]

; 178  : 
; 179  :     /* fill output buffer up to end of deflate stream */
; 180  :     had = strm->avail_out;

  00008	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8d 7b 64	 lea	 edi, DWORD PTR [ebx+100]
  00010	33 f6		 xor	 esi, esi
  00012	89 45 fc	 mov	 DWORD PTR _had$[ebp], eax
$LL11@gz_decomp:

; 181  :     do {
; 182  :         /* get more input for inflate() */
; 183  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00015	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00019	75 16		 jne	 SHORT $LN22@gz_decomp
  0001b	8b c3		 mov	 eax, ebx
  0001d	e8 00 00 00 00	 call	 _gz_avail
  00022	83 f8 ff	 cmp	 eax, -1
  00025	0f 84 c6 00 00
	00		 je	 $LN17@gz_decomp

; 184  :             return -1;
; 185  :         if (strm->avail_in == 0) {

  0002b	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0002f	74 56		 je	 SHORT $LN18@gz_decomp
$LN22@gz_decomp:

; 188  :         }
; 189  : 
; 190  :         /* decompress and handle errors */
; 191  :         ret = inflate(strm, Z_NO_FLUSH);

  00031	6a 00		 push	 0
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 _inflate@8
  00039	8b f0		 mov	 esi, eax

; 192  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  0003b	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0003e	0f 84 9b 00 00
	00		 je	 $LN5@gz_decomp
  00044	83 fe 02	 cmp	 esi, 2
  00047	0f 84 92 00 00
	00		 je	 $LN5@gz_decomp

; 196  :         }
; 197  :         if (ret == Z_MEM_ERROR) {

  0004d	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00050	74 4c		 je	 SHORT $LN20@gz_decomp

; 199  :             return -1;
; 200  :         }
; 201  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  00052	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00055	74 63		 je	 SHORT $LN21@gz_decomp

; 204  :             return -1;
; 205  :         }
; 206  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00057	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0005b	74 05		 je	 SHORT $LN9@gz_decomp
  0005d	83 fe 01	 cmp	 esi, 1
  00060	75 b3		 jne	 SHORT $LL11@gz_decomp
$LN9@gz_decomp:

; 207  : 
; 208  :     /* update available output */
; 209  :     state->x.have = had - strm->avail_out;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _had$[ebp]
  00065	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  00068	89 03		 mov	 DWORD PTR [ebx], eax

; 210  :     state->x.next = strm->next_out - state->x.have;

  0006a	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0006d	2b c8		 sub	 ecx, eax
  0006f	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 211  : 
; 212  :     /* if the gzip stream completed successfully, look for another */
; 213  :     if (ret == Z_STREAM_END)

  00072	83 fe 01	 cmp	 esi, 1
  00075	75 07		 jne	 SHORT $LN1@gz_decomp

; 214  :         state->how = LOOK;

  00077	c7 43 30 00 00
	00 00		 mov	 DWORD PTR [ebx+48], 0
$LN1@gz_decomp:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 215  : 
; 216  :     /* good decompression */
; 217  :     return 0;

  00080	33 c0		 xor	 eax, eax
  00082	5b		 pop	 ebx

; 218  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN18@gz_decomp:

; 186  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  00087	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  0008f	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00094	e8 00 00 00 00	 call	 _gz_error

; 187  :             break;

  00099	8b 5d 08	 mov	 ebx, DWORD PTR _state$[ebp]
  0009c	eb c4		 jmp	 SHORT $LN9@gz_decomp
$LN20@gz_decomp:

; 193  :             gz_error(state, Z_STREAM_ERROR,
; 194  :                      "internal error: inflate stream corrupt");

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]

; 198  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000a1	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a6	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000ab	e8 00 00 00 00	 call	 _gz_error
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	83 c8 ff	 or	 eax, -1
  000b5	5b		 pop	 ebx

; 218  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN21@gz_decomp:

; 202  :             gz_error(state, Z_DATA_ERROR,
; 203  :                      strm->msg == NULL ? "compressed data error" : strm->msg);

  000ba	8b 7f 18	 mov	 edi, DWORD PTR [edi+24]
  000bd	85 ff		 test	 edi, edi
  000bf	75 05		 jne	 SHORT $LN14@gz_decomp
  000c1	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
$LN14@gz_decomp:

; 193  :             gz_error(state, Z_STREAM_ERROR,
; 194  :                      "internal error: inflate stream corrupt");

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]

; 202  :             gz_error(state, Z_DATA_ERROR,
; 203  :                      strm->msg == NULL ? "compressed data error" : strm->msg);

  000c9	8b df		 mov	 ebx, edi
  000cb	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000d0	e8 00 00 00 00	 call	 _gz_error
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	83 c8 ff	 or	 eax, -1
  000da	5b		 pop	 ebx

; 218  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
$LN5@gz_decomp:

; 193  :             gz_error(state, Z_STREAM_ERROR,
; 194  :                      "internal error: inflate stream corrupt");

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e2	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  000e7	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000ec	e8 00 00 00 00	 call	 _gz_error
$LN17@gz_decomp:

; 195  :             return -1;

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	83 c8 ff	 or	 eax, -1
  000f6	5b		 pop	 ebx

; 218  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_gz_decomp ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_look
_TEXT	SEGMENT
tv68 = -4						; size = 4
_gz_look PROC						; COMDAT
; _state$ = esi

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 89   :     z_streamp strm = &(state->strm);
; 90   : 
; 91   :     /* allocate read buffers and inflate memory */
; 92   :     if (state->size == 0) {

  00005	33 db		 xor	 ebx, ebx
  00007	57		 push	 edi
  00008	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  0000b	39 5e 1c	 cmp	 DWORD PTR [esi+28], ebx
  0000e	0f 85 c7 00 00
	00		 jne	 $LN7@gz_look

; 93   :         /* allocate buffers */
; 94   :         state->in = (unsigned char *)malloc(state->want);

  00014	8b 5e 20	 mov	 ebx, DWORD PTR [esi+32]
  00017	53		 push	 ebx
  00018	e8 00 00 00 00	 call	 _malloc
  0001d	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
  00020	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 95   :         state->out = (unsigned char *)malloc(state->want << 1);

  00023	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _malloc

; 96   :         if (state->in == NULL || state->out == NULL) {

  0002c	33 c9		 xor	 ecx, ecx
  0002e	83 c4 08	 add	 esp, 8
  00031	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00034	39 4d fc	 cmp	 DWORD PTR tv68[ebp], ecx
  00037	74 67		 je	 SHORT $LN10@gz_look
  00039	3b c1		 cmp	 eax, ecx
  0003b	74 72		 je	 SHORT $LN9@gz_look

; 103  :         }
; 104  :         state->size = state->want;
; 105  : 
; 106  :         /* allocate inflate memory */
; 107  :         state->strm.zalloc = Z_NULL;
; 108  :         state->strm.zfree = Z_NULL;
; 109  :         state->strm.opaque = Z_NULL;
; 110  :         state->strm.avail_in = 0;
; 111  :         state->strm.next_in = Z_NULL;
; 112  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  0003d	6a 38		 push	 56			; 00000038H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  00044	6a 1f		 push	 31			; 0000001fH
  00046	57		 push	 edi
  00047	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0004a	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  00050	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00056	89 8e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ecx
  0005c	89 4e 68	 mov	 DWORD PTR [esi+104], ecx
  0005f	89 0f		 mov	 DWORD PTR [edi], ecx
  00061	e8 00 00 00 00	 call	 _inflateInit2_@16
  00066	85 c0		 test	 eax, eax
  00068	74 6f		 je	 SHORT $LN15@gz_look

; 113  :             free(state->out);

  0006a	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _free

; 114  :             free(state->in);

  00073	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _free
  0007c	83 c4 08	 add	 esp, 8

; 115  :             state->size = 0;
; 116  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0007f	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00084	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00089	8b ce		 mov	 ecx, esi
  0008b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00092	e8 00 00 00 00	 call	 _gz_error
  00097	5f		 pop	 edi

; 117  :             return -1;

  00098	83 c8 ff	 or	 eax, -1
  0009b	5b		 pop	 ebx

; 165  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN10@gz_look:

; 97   :             if (state->out != NULL)

  000a0	3b c1		 cmp	 eax, ecx
  000a2	74 0b		 je	 SHORT $LN9@gz_look

; 98   :                 free(state->out);

  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _free
  000aa	83 c4 04	 add	 esp, 4
  000ad	33 c9		 xor	 ecx, ecx
$LN9@gz_look:

; 99   :             if (state->in != NULL)

  000af	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000b2	3b c1		 cmp	 eax, ecx
  000b4	74 09		 je	 SHORT $LN8@gz_look

; 100  :                 free(state->in);

  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _free
  000bc	83 c4 04	 add	 esp, 4
$LN8@gz_look:

; 101  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000bf	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000c4	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000c9	8b ce		 mov	 ecx, esi
  000cb	e8 00 00 00 00	 call	 _gz_error
$LN17@gz_look:

; 102  :             return -1;

  000d0	5f		 pop	 edi
  000d1	83 c8 ff	 or	 eax, -1
  000d4	5b		 pop	 ebx

; 165  : }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN15@gz_look:

; 99   :             if (state->in != NULL)

  000d9	33 db		 xor	 ebx, ebx
$LN7@gz_look:

; 118  :         }
; 119  :     }
; 120  : 
; 121  :     /* get at least the magic bytes in the input buffer */
; 122  :     if (strm->avail_in < 2) {

  000db	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000de	83 f8 02	 cmp	 eax, 2
  000e1	73 13		 jae	 SHORT $LN4@gz_look

; 123  :         if (gz_avail(state) == -1)

  000e3	8b c6		 mov	 eax, esi
  000e5	e8 00 00 00 00	 call	 _gz_avail
  000ea	83 f8 ff	 cmp	 eax, -1

; 124  :             return -1;

  000ed	74 e1		 je	 SHORT $LN17@gz_look

; 125  :         if (strm->avail_in == 0)

  000ef	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000f2	3b c3		 cmp	 eax, ebx

; 126  :             return 0;

  000f4	74 70		 je	 SHORT $LN16@gz_look
$LN4@gz_look:

; 127  :     }
; 128  : 
; 129  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 130  :        a logical dilemma here when considering the case of a partially written
; 131  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 132  :        whether this is a single-byte file, or just a partially written gzip
; 133  :        file -- for here we assume that if a gzip file is being written, then
; 134  :        the header will be written in a single operation, so that reading a
; 135  :        single byte is sufficient indication that it is not a gzip file) */
; 136  :     if (strm->avail_in > 1 &&
; 137  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  000f6	ba 01 00 00 00	 mov	 edx, 1
  000fb	3b c2		 cmp	 eax, edx
  000fd	76 25		 jbe	 SHORT $LN3@gz_look
  000ff	8b 07		 mov	 eax, DWORD PTR [edi]
  00101	80 38 1f	 cmp	 BYTE PTR [eax], 31	; 0000001fH
  00104	75 1e		 jne	 SHORT $LN3@gz_look
  00106	80 78 01 8b	 cmp	 BYTE PTR [eax+1], 139	; 0000008bH
  0010a	75 18		 jne	 SHORT $LN3@gz_look

; 138  :         inflateReset(strm);

  0010c	57		 push	 edi
  0010d	e8 00 00 00 00	 call	 _inflateReset@4
  00112	5f		 pop	 edi

; 139  :         state->how = GZIP;
; 140  :         state->direct = 0;

  00113	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  00116	c7 46 30 02 00
	00 00		 mov	 DWORD PTR [esi+48], 2

; 164  :     return 0;

  0011d	33 c0		 xor	 eax, eax
  0011f	5b		 pop	 ebx

; 165  : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
$LN3@gz_look:

; 141  :         return 0;
; 142  :     }
; 143  : 
; 144  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 145  :        garbage.  Ignore the trailing garbage and finish. */
; 146  :     if (state->direct == 0) {

  00124	39 5e 2c	 cmp	 DWORD PTR [esi+44], ebx
  00127	75 10		 jne	 SHORT $LN2@gz_look

; 147  :         strm->avail_in = 0;

  00129	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0012c	5f		 pop	 edi

; 148  :         state->eof = 1;
; 149  :         state->x.have = 0;

  0012d	89 1e		 mov	 DWORD PTR [esi], ebx
  0012f	89 56 40	 mov	 DWORD PTR [esi+64], edx

; 164  :     return 0;

  00132	33 c0		 xor	 eax, eax
  00134	5b		 pop	 ebx

; 165  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN2@gz_look:

; 150  :         return 0;
; 151  :     }
; 152  : 
; 153  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 154  :        the output buffer is larger than the input buffer, which also assures
; 155  :        space for gzungetc() */
; 156  :     state->x.next = state->out;

  00139	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0013c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 157  :     if (strm->avail_in) {

  0013f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00142	3b cb		 cmp	 ecx, ebx
  00144	74 1a		 je	 SHORT $LN1@gz_look

; 158  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00146	51		 push	 ecx
  00147	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00149	51		 push	 ecx
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _memcpy

; 159  :         state->x.have = strm->avail_in;

  00150	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00153	89 16		 mov	 DWORD PTR [esi], edx
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 160  :         strm->avail_in = 0;

  00158	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0015b	ba 01 00 00 00	 mov	 edx, 1
$LN1@gz_look:

; 161  :     }
; 162  :     state->how = COPY;

  00160	89 56 30	 mov	 DWORD PTR [esi+48], edx

; 163  :     state->direct = 1;

  00163	89 56 2c	 mov	 DWORD PTR [esi+44], edx
$LN16@gz_look:

; 164  :     return 0;

  00166	5f		 pop	 edi
  00167	33 c0		 xor	 eax, eax
  00169	5b		 pop	 ebx

; 165  : }

  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
_gz_look ENDP
PUBLIC	_gzdirect@4
; Function compile flags: /Ogtp
;	COMDAT _gzdirect@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzdirect@4 PROC					; COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 550  :     gz_statep state;
; 551  : 
; 552  :     /* get internal structure */
; 553  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@gzdirect

; 554  :         return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 564  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
$LN2@gzdirect:

; 555  :     state = (gz_statep)file;
; 556  : 
; 557  :     /* if the state is not known, but we can find out, then do so (this is
; 558  :        mainly for right after a gzopen() or gzdopen()) */
; 559  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00012	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  00019	75 10		 jne	 SHORT $LN1@gzdirect
  0001b	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  0001f	75 0a		 jne	 SHORT $LN1@gzdirect
  00021	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00024	75 05		 jne	 SHORT $LN1@gzdirect

; 560  :         (void)gz_look(state);

  00026	e8 00 00 00 00	 call	 _gz_look
$LN1@gzdirect:

; 561  : 
; 562  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 563  :     return state->direct;

  0002b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002e	5e		 pop	 esi

; 564  : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
_gzdirect@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_fetch
_TEXT	SEGMENT
_gz_fetch PROC						; COMDAT
; _state$ = eax

; 228  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
$LL13@gz_fetch:

; 229  :     z_streamp strm = &(state->strm);
; 230  : 
; 231  :     do {
; 232  :         switch(state->how) {

  00003	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00006	83 e8 00	 sub	 eax, 0
  00009	74 27		 je	 SHORT $LN8@gz_fetch
  0000b	48		 dec	 eax
  0000c	74 49		 je	 SHORT $LN5@gz_fetch
  0000e	48		 dec	 eax
  0000f	75 31		 jne	 SHORT $LN12@gz_fetch

; 244  :             return 0;
; 245  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 246  :             strm->avail_out = state->size << 1;

  00011	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00014	03 c0		 add	 eax, eax
  00016	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 247  :             strm->next_out = state->out;

  00019	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]

; 248  :             if (gz_decomp(state) == -1)

  0001c	56		 push	 esi
  0001d	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  00020	e8 00 00 00 00	 call	 _gz_decomp
  00025	83 c4 04	 add	 esp, 4
  00028	83 f8 ff	 cmp	 eax, -1
  0002b	75 15		 jne	 SHORT $LN12@gz_fetch
$LN19@gz_fetch:

; 235  :                 return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	5e		 pop	 esi

; 253  : }

  00031	c3		 ret	 0
$LN8@gz_fetch:

; 233  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 234  :             if (gz_look(state) == -1)

  00032	e8 00 00 00 00	 call	 _gz_look
  00037	83 f8 ff	 cmp	 eax, -1
  0003a	74 f1		 je	 SHORT $LN19@gz_fetch

; 236  :             if (state->how == LOOK)

  0003c	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00040	74 11		 je	 SHORT $LN1@gz_fetch
$LN12@gz_fetch:

; 249  :                 return -1;
; 250  :         }
; 251  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  00042	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00045	75 0c		 jne	 SHORT $LN1@gz_fetch
  00047	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  0004b	74 b6		 je	 SHORT $LL13@gz_fetch
  0004d	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00051	75 b0		 jne	 SHORT $LL13@gz_fetch
$LN1@gz_fetch:

; 252  :     return 0;

  00053	33 c0		 xor	 eax, eax
  00055	5e		 pop	 esi

; 253  : }

  00056	c3		 ret	 0
$LN5@gz_fetch:

; 237  :                 return 0;
; 238  :             break;
; 239  :         case COPY:      /* -> COPY */
; 240  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 241  :                     == -1)

  00057	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005a	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0005d	57		 push	 edi
  0005e	03 c0		 add	 eax, eax
  00060	52		 push	 edx
  00061	8b fe		 mov	 edi, esi
  00063	e8 00 00 00 00	 call	 _gz_load
  00068	83 c4 04	 add	 esp, 4
  0006b	5f		 pop	 edi
  0006c	83 f8 ff	 cmp	 eax, -1

; 242  :                 return -1;

  0006f	74 bc		 je	 SHORT $LN19@gz_fetch

; 243  :             state->x.next = state->out;

  00071	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00074	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 252  :     return 0;

  00077	33 c0		 xor	 eax, eax
  00079	5e		 pop	 esi

; 253  : }

  0007a	c3		 ret	 0
_gz_fetch ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_skip
_TEXT	SEGMENT
_len$ = 8						; size = 8
_gz_skip PROC						; COMDAT
; _state$ = esi

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 260  :     unsigned n;
; 261  : 
; 262  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 263  :     while (len)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp+4]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000b	8b c7		 mov	 eax, edi
  0000d	0b c3		 or	 eax, ebx
  0000f	74 4b		 je	 SHORT $LN6@gz_skip
$LL7@gz_skip:

; 264  :         /* skip over whatever is in output buffer */
; 265  :         if (state->x.have) {

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	85 c9		 test	 ecx, ecx
  00015	74 27		 je	 SHORT $LN5@gz_skip

; 266  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
; 267  :                 (unsigned)len : state->x.have;

  00017	33 c0		 xor	 eax, eax
  00019	3b c3		 cmp	 eax, ebx
  0001b	7f 0a		 jg	 SHORT $LN10@gz_skip
  0001d	7c 04		 jl	 SHORT $LN15@gz_skip
  0001f	3b cf		 cmp	 ecx, edi
  00021	77 04		 ja	 SHORT $LN10@gz_skip
$LN15@gz_skip:
  00023	8b c1		 mov	 eax, ecx
  00025	eb 02		 jmp	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  00027	8b c7		 mov	 eax, edi
$LN11@gz_skip:

; 268  :             state->x.have -= n;
; 269  :             state->x.next += n;

  00029	01 46 04	 add	 DWORD PTR [esi+4], eax
  0002c	2b c8		 sub	 ecx, eax
  0002e	89 0e		 mov	 DWORD PTR [esi], ecx

; 270  :             state->x.pos += n;

  00030	33 c9		 xor	 ecx, ecx
  00032	01 46 08	 add	 DWORD PTR [esi+8], eax
  00035	11 4e 0c	 adc	 DWORD PTR [esi+12], ecx

; 271  :             len -= n;

  00038	2b f8		 sub	 edi, eax
  0003a	1b d9		 sbb	 ebx, ecx
  0003c	eb 18		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 272  :         }
; 273  : 
; 274  :         /* output buffer empty -- return if we're at the end of the input */
; 275  :         else if (state->eof && state->strm.avail_in == 0)

  0003e	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  00042	74 06		 je	 SHORT $LN3@gz_skip
  00044	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00048	74 12		 je	 SHORT $LN6@gz_skip
$LN3@gz_skip:

; 276  :             break;
; 277  : 
; 278  :         /* need more data to skip -- load up output buffer */
; 279  :         else {
; 280  :             /* get more output, looking for header if required */
; 281  :             if (gz_fetch(state) == -1)

  0004a	8b c6		 mov	 eax, esi
  0004c	e8 00 00 00 00	 call	 _gz_fetch
  00051	83 f8 ff	 cmp	 eax, -1
  00054	74 0c		 je	 SHORT $LN14@gz_skip
$LN1@gz_skip:

; 260  :     unsigned n;
; 261  : 
; 262  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 263  :     while (len)

  00056	8b cf		 mov	 ecx, edi
  00058	0b cb		 or	 ecx, ebx
  0005a	75 b5		 jne	 SHORT $LL7@gz_skip
$LN6@gz_skip:
  0005c	5f		 pop	 edi

; 283  :         }
; 284  :     return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	5b		 pop	 ebx

; 285  : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN14@gz_skip:
  00062	5f		 pop	 edi

; 282  :                 return -1;

  00063	83 c8 ff	 or	 eax, -1
  00066	5b		 pop	 ebx

; 285  : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_gz_skip ENDP
PUBLIC	_gzgets@12
; Function compile flags: /Ogtp
;	COMDAT _gzgets@12
_TEXT	SEGMENT
_left$ = 8						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_str$ = 16						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 488  :     unsigned left, n;
; 489  :     char *str;
; 490  :     unsigned char *eol;
; 491  :     gz_statep state;
; 492  : 
; 493  :     /* check parameters and get internal structure */
; 494  :     if (file == NULL || buf == NULL || len < 1)

  00005	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00008	57		 push	 edi
  00009	85 f6		 test	 esi, esi
  0000b	0f 84 ef 00 00
	00		 je	 $LN14@gzgets
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  00014	85 ff		 test	 edi, edi
  00016	0f 84 e4 00 00
	00		 je	 $LN14@gzgets
  0001c	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0001f	83 fb 01	 cmp	 ebx, 1
  00022	0f 8c d8 00 00
	00		 jl	 $LN14@gzgets

; 496  :     state = (gz_statep)file;
; 497  : 
; 498  :     /* check that we're reading and that there's no (serious) error */
; 499  :     if (state->mode != GZ_READ ||
; 500  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00028	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0002f	0f 85 cb 00 00
	00		 jne	 $LN14@gzgets
  00035	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00038	85 c0		 test	 eax, eax
  0003a	74 09		 je	 SHORT $LN13@gzgets
  0003c	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  0003f	0f 85 bb 00 00
	00		 jne	 $LN14@gzgets
$LN13@gzgets:

; 501  :         return NULL;
; 502  : 
; 503  :     /* process a skip request */
; 504  :     if (state->seek) {

  00045	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00049	74 20		 je	 SHORT $LN25@gzgets

; 505  :         state->seek = 0;
; 506  :         if (gz_skip(state, state->skip) == -1)

  0004b	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0004e	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00051	50		 push	 eax
  00052	51		 push	 ecx
  00053	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0005a	e8 00 00 00 00	 call	 _gz_skip
  0005f	83 c4 08	 add	 esp, 8
  00062	83 f8 ff	 cmp	 eax, -1

; 507  :             return NULL;

  00065	0f 84 95 00 00
	00		 je	 $LN14@gzgets
$LN25@gzgets:

; 508  :     }
; 509  : 
; 510  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 511  :        append a terminating zero to the string (we don't check for a zero in
; 512  :        the contents, let the user worry about that) */
; 513  :     str = buf;
; 514  :     left = (unsigned)len - 1;

  0006b	4b		 dec	 ebx
  0006c	89 7d 10	 mov	 DWORD PTR _str$[ebp], edi
  0006f	89 5d 08	 mov	 DWORD PTR _left$[ebp], ebx

; 515  :     if (left) do {

  00072	0f 84 88 00 00
	00		 je	 $LN14@gzgets
$LL8@gzgets:

; 516  :         /* assure that something is in the output buffer */
; 517  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00078	8b 3e		 mov	 edi, DWORD PTR [esi]
  0007a	85 ff		 test	 edi, edi
  0007c	75 12		 jne	 SHORT $LN24@gzgets
  0007e	8b c6		 mov	 eax, esi
  00080	e8 00 00 00 00	 call	 _gz_fetch
  00085	83 f8 ff	 cmp	 eax, -1
  00088	74 76		 je	 SHORT $LN14@gzgets

; 518  :             return NULL;                /* error */
; 519  :         if (state->x.have == 0) {       /* end of file */

  0008a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0008c	85 ff		 test	 edi, edi
  0008e	74 55		 je	 SHORT $LN22@gzgets
$LN24@gzgets:

; 521  :             break;                      /* return what we have */
; 522  :         }
; 523  : 
; 524  :         /* look for end-of-line in current output buffer */
; 525  :         n = state->x.have > left ? left : state->x.have;

  00090	3b fb		 cmp	 edi, ebx
  00092	76 02		 jbe	 SHORT $LN18@gzgets
  00094	8b fb		 mov	 edi, ebx
$LN18@gzgets:

; 526  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	57		 push	 edi
  0009a	6a 0a		 push	 10			; 0000000aH
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _memchr
  000a2	8b d8		 mov	 ebx, eax
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 527  :         if (eol != NULL)

  000a7	85 db		 test	 ebx, ebx
  000a9	74 06		 je	 SHORT $LN3@gzgets

; 528  :             n = (unsigned)(eol - state->x.next) + 1;

  000ab	8b fb		 mov	 edi, ebx
  000ad	2b 7e 04	 sub	 edi, DWORD PTR [esi+4]
  000b0	47		 inc	 edi
$LN3@gzgets:

; 529  : 
; 530  :         /* copy through end-of-line, or remainder if not found */
; 531  :         memcpy(buf, state->x.next, n);

  000b1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000b7	57		 push	 edi
  000b8	50		 push	 eax
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _memcpy

; 532  :         state->x.have -= n;

  000bf	29 3e		 sub	 DWORD PTR [esi], edi

; 533  :         state->x.next += n;

  000c1	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 534  :         state->x.pos += n;
; 535  :         left -= n;

  000c4	8b 45 08	 mov	 eax, DWORD PTR _left$[ebp]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	01 7e 08	 add	 DWORD PTR [esi+8], edi
  000cd	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 536  :         buf += n;

  000d1	01 7d 0c	 add	 DWORD PTR _buf$[ebp], edi
  000d4	2b c7		 sub	 eax, edi
  000d6	89 45 08	 mov	 DWORD PTR _left$[ebp], eax

; 537  :     } while (left && eol == NULL);

  000d9	85 c0		 test	 eax, eax
  000db	74 0f		 je	 SHORT $LN2@gzgets
  000dd	85 db		 test	 ebx, ebx
  000df	75 0b		 jne	 SHORT $LN2@gzgets
  000e1	8b d8		 mov	 ebx, eax
  000e3	eb 93		 jmp	 SHORT $LL8@gzgets
$LN22@gzgets:

; 520  :             state->past = 1;            /* read past end */

  000e5	c7 46 44 01 00
	00 00		 mov	 DWORD PTR [esi+68], 1
$LN2@gzgets:

; 538  : 
; 539  :     /* return terminated string, or if nothing, end of file */
; 540  :     if (buf == str)

  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000ef	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]
  000f2	3b c8		 cmp	 ecx, eax

; 541  :         return NULL;

  000f4	74 0a		 je	 SHORT $LN14@gzgets

; 542  :     buf[0] = 0;

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000fb	5b		 pop	 ebx

; 543  :     return str;
; 544  : }

  000fc	5d		 pop	 ebp
  000fd	c2 0c 00	 ret	 12			; 0000000cH
$LN14@gzgets:
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi

; 495  :         return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	5b		 pop	 ebx

; 543  :     return str;
; 544  : }

  00105	5d		 pop	 ebp
  00106	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
PUBLIC	_gzungetc@8
; Function compile flags: /Ogtp
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 427  :     gz_statep state;
; 428  : 
; 429  :     /* get internal structure */
; 430  :     if (file == NULL)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _file$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	3b f3		 cmp	 esi, ebx
  0000c	75 09		 jne	 SHORT $LN11@gzungetc
$LN9@gzungetc:
  0000e	5e		 pop	 esi

; 431  :         return -1;

  0000f	83 c8 ff	 or	 eax, -1
  00012	5b		 pop	 ebx

; 479  :     return c;
; 480  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN11@gzungetc:

; 432  :     state = (gz_statep)file;
; 433  : 
; 434  :     /* check that we're reading and that there's no (serious) error */
; 435  :     if (state->mode != GZ_READ ||
; 436  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0001e	75 ee		 jne	 SHORT $LN9@gzungetc
  00020	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00023	3b c3		 cmp	 eax, ebx
  00025	74 05		 je	 SHORT $LN10@gzungetc
  00027	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  0002a	75 e2		 jne	 SHORT $LN9@gzungetc
$LN10@gzungetc:
  0002c	57		 push	 edi

; 437  :         return -1;
; 438  : 
; 439  :     /* process a skip request */
; 440  :     if (state->seek) {

  0002d	83 cf ff	 or	 edi, -1
  00030	39 5e 58	 cmp	 DWORD PTR [esi+88], ebx
  00033	74 17		 je	 SHORT $LN7@gzungetc

; 441  :         state->seek = 0;
; 442  :         if (gz_skip(state, state->skip) == -1)

  00035	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00038	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0003b	50		 push	 eax
  0003c	51		 push	 ecx
  0003d	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  00040	e8 00 00 00 00	 call	 _gz_skip
  00045	83 c4 08	 add	 esp, 8
  00048	3b c7		 cmp	 eax, edi

; 443  :             return -1;

  0004a	74 4a		 je	 SHORT $LN17@gzungetc
$LN7@gzungetc:

; 444  :     }
; 445  : 
; 446  :     /* can't push EOF */
; 447  :     if (c < 0)

  0004c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0004f	3b c3		 cmp	 eax, ebx

; 448  :         return -1;

  00051	7c 43		 jl	 SHORT $LN17@gzungetc

; 449  : 
; 450  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 451  :     if (state->x.have == 0) {

  00053	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 452  :         state->x.have = 1;
; 453  :         state->x.next = state->out + (state->size << 1) - 1;

  00055	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00058	3b cb		 cmp	 ecx, ebx
  0005a	75 22		 jne	 SHORT $LN5@gzungetc
  0005c	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0005f	8d 4c 51 ff	 lea	 ecx, DWORD PTR [ecx+edx*2-1]
  00063	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1
  00069	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 454  :         state->x.next[0] = c;

  0006c	88 01		 mov	 BYTE PTR [ecx], al

; 477  :     state->x.pos--;

  0006e	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00071	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00074	11 7e 0c	 adc	 DWORD PTR [esi+12], edi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 479  :     return c;
; 480  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN5@gzungetc:

; 455  :         state->x.pos--;
; 456  :         state->past = 0;
; 457  :         return c;
; 458  :     }
; 459  : 
; 460  :     /* if no room, give up (must have already done a gzungetc()) */
; 461  :     if (state->x.have == (state->size << 1)) {

  0007e	8d 1c 12	 lea	 ebx, DWORD PTR [edx+edx]
  00081	3b cb		 cmp	 ecx, ebx
  00083	75 1a		 jne	 SHORT $LN4@gzungetc

; 462  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00085	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  0008a	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0008f	8b ce		 mov	 ecx, esi
  00091	e8 00 00 00 00	 call	 _gz_error
$LN17@gzungetc:

; 463  :         return -1;

  00096	8b c7		 mov	 eax, edi
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 479  :     return c;
; 480  : }

  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
$LN4@gzungetc:

; 464  :     }
; 465  : 
; 466  :     /* slide output data if needed and insert byte before existing data */
; 467  :     if (state->x.next == state->out) {

  0009f	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  000a2	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  000a5	75 18		 jne	 SHORT $LN3@gzungetc

; 468  :         unsigned char *src = state->out + state->x.have;

  000a7	03 cb		 add	 ecx, ebx

; 469  :         unsigned char *dest = state->out + (state->size << 1);

  000a9	8d 14 53	 lea	 edx, DWORD PTR [ebx+edx*2]

; 470  :         while (src > state->out)

  000ac	3b cb		 cmp	 ecx, ebx
  000ae	76 0c		 jbe	 SHORT $LN1@gzungetc
$LL2@gzungetc:

; 471  :             *--dest = *--src;

  000b0	8a 59 ff	 mov	 bl, BYTE PTR [ecx-1]
  000b3	49		 dec	 ecx
  000b4	4a		 dec	 edx
  000b5	88 1a		 mov	 BYTE PTR [edx], bl
  000b7	3b 4e 28	 cmp	 ecx, DWORD PTR [esi+40]
  000ba	77 f4		 ja	 SHORT $LL2@gzungetc
$LN1@gzungetc:

; 472  :         state->x.next = dest;

  000bc	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN3@gzungetc:

; 473  :     }
; 474  :     state->x.have++;
; 475  :     state->x.next--;

  000bf	01 7e 04	 add	 DWORD PTR [esi+4], edi
  000c2	ff 06		 inc	 DWORD PTR [esi]
  000c4	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 476  :     state->x.next[0] = c;

  000c7	88 01		 mov	 BYTE PTR [ecx], al

; 477  :     state->x.pos--;

  000c9	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 478  :     state->past = 0;

  000cc	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  000d3	11 7e 0c	 adc	 DWORD PTR [esi+12], edi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 479  :     return c;
; 480  : }

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8
_gzungetc@8 ENDP
_TEXT	ENDS
PUBLIC	_gzread@12
; Function compile flags: /Ogtp
;	COMDAT _gzread@12
_TEXT	SEGMENT
_n$ = 8							; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_got$ = 16						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 293  :     unsigned got, n;
; 294  :     gz_statep state;
; 295  :     z_streamp strm;
; 296  : 
; 297  :     /* get internal structure */
; 298  :     if (file == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 08		 jne	 SHORT $LN22@gzread
$LN20@gzread:

; 299  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5f		 pop	 edi

; 379  : }

  0000f	5d		 pop	 ebp
  00010	c2 0c 00	 ret	 12			; 0000000cH
$LN22@gzread:

; 300  :     state = (gz_statep)file;
; 301  :     strm = &(state->strm);
; 302  : 
; 303  :     /* check that we're reading and that there's no (serious) error */
; 304  :     if (state->mode != GZ_READ ||
; 305  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00013	81 7f 10 4f 1c
	00 00		 cmp	 DWORD PTR [edi+16], 7247 ; 00001c4fH
  0001a	75 ef		 jne	 SHORT $LN20@gzread
  0001c	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  0001f	85 c0		 test	 eax, eax
  00021	74 05		 je	 SHORT $LN21@gzread
  00023	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  00026	75 e3		 jne	 SHORT $LN20@gzread
$LN21@gzread:
  00028	53		 push	 ebx

; 306  :         return -1;
; 307  : 
; 308  :     /* since an int is returned, make sure len fits in one, otherwise return
; 309  :        with an error (this avoids the flaw in the interface) */
; 310  :     if ((int)len < 0) {

  00029	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0002c	85 db		 test	 ebx, ebx
  0002e	79 1a		 jns	 SHORT $LN36@gzread

; 311  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00030	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00035	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0003a	8b cf		 mov	 ecx, edi
  0003c	e8 00 00 00 00	 call	 _gz_error
  00041	5b		 pop	 ebx

; 312  :         return -1;

  00042	83 c8 ff	 or	 eax, -1
  00045	5f		 pop	 edi

; 379  : }

  00046	5d		 pop	 ebp
  00047	c2 0c 00	 ret	 12			; 0000000cH
$LN36@gzread:

; 313  :     }
; 314  : 
; 315  :     /* if len is zero, avoid unnecessary operations */
; 316  :     if (len == 0)

  0004a	75 08		 jne	 SHORT $LN18@gzread

; 317  :         return 0;

  0004c	5b		 pop	 ebx
  0004d	33 c0		 xor	 eax, eax
  0004f	5f		 pop	 edi

; 379  : }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN18@gzread:

; 318  : 
; 319  :     /* process a skip request */
; 320  :     if (state->seek) {

  00054	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0
  00058	56		 push	 esi
  00059	74 22		 je	 SHORT $LN32@gzread

; 321  :         state->seek = 0;
; 322  :         if (gz_skip(state, state->skip) == -1)

  0005b	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005e	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00061	50		 push	 eax
  00062	51		 push	 ecx
  00063	8b f7		 mov	 esi, edi
  00065	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  0006c	e8 00 00 00 00	 call	 _gz_skip
  00071	83 c4 08	 add	 esp, 8
  00074	83 f8 ff	 cmp	 eax, -1

; 323  :             return -1;

  00077	0f 84 f1 00 00
	00		 je	 $LN31@gzread
$LN32@gzread:

; 324  :     }
; 325  : 
; 326  :     /* get len bytes to buf, or less than len if at the end */
; 327  :     got = 0;

  0007d	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0
$LL15@gzread:

; 328  :     do {
; 329  :         /* first just try copying data from the output buffer */
; 330  :         if (state->x.have) {

  00084	8b 37		 mov	 esi, DWORD PTR [edi]
  00086	85 f6		 test	 esi, esi
  00088	74 33		 je	 SHORT $LN12@gzread

; 331  :             n = state->x.have > len ? len : state->x.have;

  0008a	3b f3		 cmp	 esi, ebx
  0008c	76 02		 jbe	 SHORT $LN25@gzread
  0008e	8b f3		 mov	 esi, ebx
$LN25@gzread:

; 332  :             memcpy(buf, state->x.next, n);

  00090	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00093	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00096	56		 push	 esi
  00097	52		 push	 edx
  00098	50		 push	 eax
  00099	89 75 08	 mov	 DWORD PTR _n$[ebp], esi
  0009c	e8 00 00 00 00	 call	 _memcpy

; 333  :             state->x.next += n;

  000a1	01 77 04	 add	 DWORD PTR [edi+4], esi

; 334  :             state->x.have -= n;

  000a4	29 37		 sub	 DWORD PTR [edi], esi

; 367  :             state->x.have = 0;
; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  000a6	01 75 0c	 add	 DWORD PTR _buf$[ebp], esi

; 373  :         got += n;

  000a9	01 75 10	 add	 DWORD PTR _got$[ebp], esi
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	2b de		 sub	 ebx, esi

; 374  :         state->x.pos += n;

  000b1	01 77 08	 add	 DWORD PTR [edi+8], esi
  000b4	83 57 0c 00	 adc	 DWORD PTR [edi+12], 0
  000b8	e9 8e 00 00 00	 jmp	 $LN14@gzread
$LN12@gzread:

; 335  :         }
; 336  : 
; 337  :         /* output buffer empty -- return if we're at the end of the input */
; 338  :         else if (state->eof && strm->avail_in == 0) {

  000bd	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  000c1	74 0a		 je	 SHORT $LN10@gzread
  000c3	83 7f 68 00	 cmp	 DWORD PTR [edi+104], 0
  000c7	0f 84 90 00 00
	00		 je	 $LN28@gzread
$LN10@gzread:

; 339  :             state->past = 1;        /* tried to read past end */
; 340  :             break;
; 341  :         }
; 342  : 
; 343  :         /* need output data -- for small len or new stream load up our output
; 344  :            buffer */
; 345  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000cd	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000d0	85 c0		 test	 eax, eax
  000d2	74 6b		 je	 SHORT $LN7@gzread
  000d4	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000d7	03 c9		 add	 ecx, ecx
  000d9	3b d9		 cmp	 ebx, ecx
  000db	72 62		 jb	 SHORT $LN7@gzread

; 349  :             continue;       /* no progress yet -- go back to copy above */
; 350  :             /* the copy above assures that we will leave with space in the
; 351  :                output buffer, allowing at least one gzungetc() to succeed */
; 352  :         }
; 353  : 
; 354  :         /* large len -- read directly into user buffer */
; 355  :         else if (state->how == COPY) {      /* read directly */

  000dd	83 f8 01	 cmp	 eax, 1
  000e0	75 2a		 jne	 SHORT $LN4@gzread

; 356  :             if (gz_load(state, (unsigned char *)buf, len, &n) == -1)

  000e2	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000e5	52		 push	 edx
  000e6	8d 75 08	 lea	 esi, DWORD PTR _n$[ebp]
  000e9	8b c3		 mov	 eax, ebx
  000eb	e8 00 00 00 00	 call	 _gz_load
  000f0	83 c4 04	 add	 esp, 4
  000f3	83 f8 ff	 cmp	 eax, -1
  000f6	74 76		 je	 SHORT $LN31@gzread

; 357  :                 return -1;
; 358  :         }
; 359  : 
; 360  :         /* large len -- decompress directly into user buffer */
; 361  :         else {  /* state->how == GZIP */

  000f8	8b 75 08	 mov	 esi, DWORD PTR _n$[ebp]

; 367  :             state->x.have = 0;
; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  000fb	01 75 0c	 add	 DWORD PTR _buf$[ebp], esi

; 373  :         got += n;

  000fe	01 75 10	 add	 DWORD PTR _got$[ebp], esi
  00101	2b de		 sub	 ebx, esi

; 374  :         state->x.pos += n;

  00103	01 77 08	 add	 DWORD PTR [edi+8], esi
  00106	83 57 0c 00	 adc	 DWORD PTR [edi+12], 0
  0010a	eb 3f		 jmp	 SHORT $LN14@gzread
$LN4@gzread:

; 362  :             strm->avail_out = len;
; 363  :             strm->next_out = (unsigned char *)buf;

  0010c	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 364  :             if (gz_decomp(state) == -1)

  0010f	57		 push	 edi
  00110	89 5f 74	 mov	 DWORD PTR [edi+116], ebx
  00113	89 47 70	 mov	 DWORD PTR [edi+112], eax
  00116	e8 00 00 00 00	 call	 _gz_decomp
  0011b	83 c4 04	 add	 esp, 4
  0011e	83 f8 ff	 cmp	 eax, -1
  00121	74 4b		 je	 SHORT $LN31@gzread

; 365  :                 return -1;
; 366  :             n = state->x.have;

  00123	8b 37		 mov	 esi, DWORD PTR [edi]

; 367  :             state->x.have = 0;
; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;
; 372  :         buf = (char *)buf + n;

  00125	01 75 0c	 add	 DWORD PTR _buf$[ebp], esi

; 373  :         got += n;

  00128	01 75 10	 add	 DWORD PTR _got$[ebp], esi
  0012b	2b de		 sub	 ebx, esi

; 374  :         state->x.pos += n;

  0012d	01 77 08	 add	 DWORD PTR [edi+8], esi
  00130	89 75 08	 mov	 DWORD PTR _n$[ebp], esi
  00133	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00139	83 57 0c 00	 adc	 DWORD PTR [edi+12], 0
  0013d	eb 0c		 jmp	 SHORT $LN14@gzread
$LN7@gzread:

; 346  :             /* get more output, looking for header if required */
; 347  :             if (gz_fetch(state) == -1)

  0013f	8b c7		 mov	 eax, edi
  00141	e8 00 00 00 00	 call	 _gz_fetch
  00146	83 f8 ff	 cmp	 eax, -1
  00149	74 23		 je	 SHORT $LN31@gzread
$LN14@gzread:

; 375  :     } while (len);

  0014b	85 db		 test	 ebx, ebx
  0014d	0f 85 31 ff ff
	ff		 jne	 $LL15@gzread

; 376  : 
; 377  :     /* return number of bytes read into user buffer (will fit in int) */
; 378  :     return (int)got;

  00153	8b 45 10	 mov	 eax, DWORD PTR _got$[ebp]
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx
  00158	5f		 pop	 edi

; 379  : }

  00159	5d		 pop	 ebp
  0015a	c2 0c 00	 ret	 12			; 0000000cH
$LN28@gzread:

; 376  : 
; 377  :     /* return number of bytes read into user buffer (will fit in int) */
; 378  :     return (int)got;

  0015d	8b 45 10	 mov	 eax, DWORD PTR _got$[ebp]
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	c7 47 44 01 00
	00 00		 mov	 DWORD PTR [edi+68], 1
  00169	5f		 pop	 edi

; 379  : }

  0016a	5d		 pop	 ebp
  0016b	c2 0c 00	 ret	 12			; 0000000cH
$LN31@gzread:
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx

; 348  :                 return -1;

  00170	83 c8 ff	 or	 eax, -1
  00173	5f		 pop	 edi

; 379  : }

  00174	5d		 pop	 ebp
  00175	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
PUBLIC	_gzgetc@4
; Function compile flags: /Ogtp
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_gzgetc@4 PROC						; COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 390  :     int ret;
; 391  :     unsigned char buf[1];
; 392  :     gz_statep state;
; 393  : 
; 394  :     /* get internal structure */
; 395  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax

; 396  :         return -1;

  00008	74 4f		 je	 SHORT $LN2@gzgetc

; 397  :     state = (gz_statep)file;
; 398  : 
; 399  :     /* check that we're reading and that there's no (serious) error */
; 400  :     if (state->mode != GZ_READ ||
; 401  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000a	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00011	75 46		 jne	 SHORT $LN2@gzgetc
  00013	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00016	85 c9		 test	 ecx, ecx
  00018	74 05		 je	 SHORT $LN3@gzgetc
  0001a	83 f9 fb	 cmp	 ecx, -5			; fffffffbH
  0001d	75 3a		 jne	 SHORT $LN2@gzgetc
$LN3@gzgetc:

; 403  : 
; 404  :     /* try output buffer (no need to check for skip request) */
; 405  :     if (state->x.have) {

  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	85 c9		 test	 ecx, ecx
  00023	74 1b		 je	 SHORT $LN1@gzgetc

; 406  :         state->x.have--;

  00025	49		 dec	 ecx

; 407  :         state->x.pos++;

  00026	83 40 08 01	 add	 DWORD PTR [eax+8], 1
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 408  :         return *(state->x.next)++;

  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	83 50 0c 00	 adc	 DWORD PTR [eax+12], 0
  00033	8a 11		 mov	 dl, BYTE PTR [ecx]
  00035	41		 inc	 ecx
  00036	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00039	0f b6 c2	 movzx	 eax, dl

; 414  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN1@gzgetc:

; 409  :     }
; 410  : 
; 411  :     /* nothing there -- try gzread() */
; 412  :     ret = gzread(file, buf, 1);

  00040	6a 01		 push	 1
  00042	8d 4d 0b	 lea	 ecx, DWORD PTR _buf$[ebp]
  00045	51		 push	 ecx
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _gzread@12

; 413  :     return ret < 1 ? -1 : buf[0];

  0004c	83 f8 01	 cmp	 eax, 1
  0004f	7c 08		 jl	 SHORT $LN2@gzgetc
  00051	0f b6 45 0b	 movzx	 eax, BYTE PTR _buf$[ebp]

; 414  : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN2@gzgetc:

; 402  :         return -1;

  00059	83 c8 ff	 or	 eax, -1

; 414  : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_gzgetc@4 ENDP
_TEXT	ENDS
PUBLIC	_gzgetc_@4
; Function compile flags: /Ogtp
;	COMDAT _gzgetc_@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzgetc_@4 PROC						; COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  : }

  00003	5d		 pop	 ebp

; 419  :     return gzgetc(file);

  00004	e9 00 00 00 00	 jmp	 _gzgetc@4
_gzgetc_@4 ENDP
_TEXT	ENDS
END
