; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress@16
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\uncompr.c
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H

; 30   :     z_stream stream;
; 31   :     int err;
; 32   : 
; 33   :     stream.next_in = (z_const Bytef *)source;
; 34   :     stream.avail_in = (uInt)sourceLen;

  00009	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  0000c	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]

; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : 
; 38   :     stream.next_out = dest;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00012	56		 push	 esi
  00013	57		 push	 edi

; 39   :     stream.avail_out = (uInt)*destLen;

  00014	8b 7d 0c	 mov	 edi, DWORD PTR _destLen$[ebp]

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;
; 43   :     stream.zfree = (free_func)0;
; 44   : 
; 45   :     err = inflateInit(&stream);

  00017	6a 38		 push	 56			; 00000038H
  00019	89 4c 24 10	 mov	 DWORD PTR _stream$[esp+72], ecx
  0001d	89 44 24 0c	 mov	 DWORD PTR _stream$[esp+68], eax
  00021	8b 07		 mov	 eax, DWORD PTR [edi]
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  00028	8d 4c 24 10	 lea	 ecx, DWORD PTR _stream$[esp+72]
  0002c	51		 push	 ecx
  0002d	89 54 24 20	 mov	 DWORD PTR _stream$[esp+88], edx
  00031	89 44 24 24	 mov	 DWORD PTR _stream$[esp+92], eax
  00035	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+108], 0
  0003d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+112], 0
  00045	e8 00 00 00 00	 call	 _inflateInit_@12

; 46   :     if (err != Z_OK) return err;

  0004a	85 c0		 test	 eax, eax
  0004c	75 55		 jne	 SHORT $LN7@uncompress

; 47   : 
; 48   :     err = inflate(&stream, Z_FINISH);

  0004e	6a 04		 push	 4
  00050	8d 54 24 0c	 lea	 edx, DWORD PTR _stream$[esp+68]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _inflate@8
  0005a	8b f0		 mov	 esi, eax

; 49   :     if (err != Z_STREAM_END) {

  0005c	83 fe 01	 cmp	 esi, 1
  0005f	74 32		 je	 SHORT $LN3@uncompress

; 50   :         inflateEnd(&stream);

  00061	8d 44 24 08	 lea	 eax, DWORD PTR _stream$[esp+64]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _inflateEnd@4

; 51   :         if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))

  0006b	83 fe 02	 cmp	 esi, 2
  0006e	74 16		 je	 SHORT $LN1@uncompress
  00070	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00073	75 07		 jne	 SHORT $LN2@uncompress
  00075	83 7c 24 0c 00	 cmp	 DWORD PTR _stream$[esp+68], 0
  0007a	74 0a		 je	 SHORT $LN1@uncompress
$LN2@uncompress:

; 53   :         return err;

  0007c	8b c6		 mov	 eax, esi

; 58   :     return err;
; 59   : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 10 00	 ret	 16			; 00000010H
$LN1@uncompress:

; 52   :             return Z_DATA_ERROR;

  00086	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 58   :     return err;
; 59   : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 10 00	 ret	 16			; 00000010H
$LN3@uncompress:

; 54   :     }
; 55   :     *destLen = stream.total_out;

  00093	8b 4c 24 1c	 mov	 ecx, DWORD PTR _stream$[esp+84]

; 56   : 
; 57   :     err = inflateEnd(&stream);

  00097	8d 54 24 08	 lea	 edx, DWORD PTR _stream$[esp+64]
  0009b	52		 push	 edx
  0009c	89 0f		 mov	 DWORD PTR [edi], ecx
  0009e	e8 00 00 00 00	 call	 _inflateEnd@4
$LN7@uncompress:

; 58   :     return err;
; 59   : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
END
