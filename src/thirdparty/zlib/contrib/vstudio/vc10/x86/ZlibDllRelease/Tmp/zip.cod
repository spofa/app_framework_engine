; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\zip.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_zip_copyright
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
EXTRN	_rand:PROC
EXTRN	_srand:PROC
EXTRN	__time64:PROC
?calls@?1??crypthead@@9@9 DD 01H DUP (?)		; `crypthead'::`2'::calls
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
_zip_copyright DB ' zip 1.01 Copyright 1998-2004 Gilles Vollant - http://'
	DB	'www.winimage.com/zLibDll', 00H
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\zip.c
;	COMDAT _zip64local_getByte
_TEXT	SEGMENT
_c$ = -1						; size = 1
_pi$ = 8						; size = 4
_zip64local_getByte PROC				; COMDAT
; _pzlib_filefunc_def$ = esi
; _filestream$ = edi

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 351  :     unsigned char c;
; 352  :     int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);

  00004	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00007	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000a	6a 01		 push	 1
  0000c	8d 45 ff	 lea	 eax, DWORD PTR _c$[ebp]
  0000f	50		 push	 eax
  00010	57		 push	 edi
  00011	51		 push	 ecx
  00012	ff d2		 call	 edx
  00014	83 c4 10	 add	 esp, 16			; 00000010H

; 353  :     if (err==1)

  00017	83 f8 01	 cmp	 eax, 1
  0001a	75 0f		 jne	 SHORT $LN4@zip64local

; 354  :     {
; 355  :         *pi = (int)c;

  0001c	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pi$[ebp]
  00023	89 01		 mov	 DWORD PTR [ecx], eax

; 356  :         return ZIP_OK;

  00025	33 c0		 xor	 eax, eax

; 361  :             return ZIP_ERRNO;
; 362  :         else
; 363  :             return ZIP_EOF;
; 364  :     }
; 365  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@zip64local:

; 357  :     }
; 358  :     else
; 359  :     {
; 360  :         if (ZERROR64(*pzlib_filefunc_def,filestream))

  0002b	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0002e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00031	57		 push	 edi
  00032	52		 push	 edx
  00033	ff d0		 call	 eax
  00035	83 c4 08	 add	 esp, 8
  00038	f7 d8		 neg	 eax
  0003a	1b c0		 sbb	 eax, eax

; 361  :             return ZIP_ERRNO;
; 362  :         else
; 363  :             return ZIP_EOF;
; 364  :     }
; 365  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_zip64local_getByte ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_TmzDateToDosDate
_TEXT	SEGMENT
_zip64local_TmzDateToDosDate PROC			; COMDAT
; _ptm$ = edx

; 334  :     uLong year = (uLong)ptm->tm_year;

  00000	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]

; 335  :     if (year>=1980)

  00003	81 f9 bc 07 00
	00		 cmp	 ecx, 1980		; 000007bcH
  00009	72 08		 jb	 SHORT $LN3@zip64local@2

; 336  :         year-=1980;

  0000b	81 e9 bc 07 00
	00		 sub	 ecx, 1980		; 000007bcH
  00011	eb 08		 jmp	 SHORT $LN1@zip64local@2
$LN3@zip64local@2:

; 337  :     else if (year>=80)

  00013	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00016	72 03		 jb	 SHORT $LN1@zip64local@2

; 338  :         year-=80;

  00018	83 e9 50	 sub	 ecx, 80			; 00000050H
$LN1@zip64local@2:

; 339  :     return
; 340  :       (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
; 341  :         ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));

  0001b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001e	c1 e0 06	 shl	 eax, 6
  00021	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00024	56		 push	 esi
  00025	8b 32		 mov	 esi, DWORD PTR [edx]
  00027	d1 ee		 shr	 esi, 1
  00029	c1 e0 05	 shl	 eax, 5
  0002c	03 c6		 add	 eax, esi
  0002e	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00031	03 c9		 add	 ecx, ecx
  00033	8d 4c ce 01	 lea	 ecx, DWORD PTR [esi+ecx*8+1]
  00037	c1 e1 05	 shl	 ecx, 5
  0003a	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  0003d	5e		 pop	 esi
  0003e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00041	0b c1		 or	 eax, ecx

; 342  : }

  00043	c3		 ret	 0
_zip64local_TmzDateToDosDate ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _zip64local_putValue_inmemory
_TEXT	SEGMENT
_x$ = 8							; size = 8
_zip64local_putValue_inmemory PROC			; COMDAT
; _dest$ = edi
; _nbByte$ = esi

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     unsigned char* buf=(unsigned char*)dest;
; 314  :     int n;
; 315  :     for (n = 0; n < nbByte; n++) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	7e 10		 jle	 SHORT $LN5@zip64local@3
  0000f	90		 npad	 1
$LL7@zip64local@3:

; 316  :         buf[n] = (unsigned char)(x & 0xff);

  00010	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 317  :         x >>= 8;

  00013	0f ac d0 08	 shrd	 eax, edx, 8
  00017	41		 inc	 ecx
  00018	c1 ea 08	 shr	 edx, 8
  0001b	3b ce		 cmp	 ecx, esi
  0001d	7c f1		 jl	 SHORT $LL7@zip64local@3
$LN5@zip64local@3:

; 318  :     }
; 319  : 
; 320  :     if (x != 0)

  0001f	0b c2		 or	 eax, edx
  00021	74 13		 je	 SHORT $LN3@zip64local@3

; 321  :     {     /* data overflow - hack for ZIP64 */
; 322  :        for (n = 0; n < nbByte; n++)

  00023	85 f6		 test	 esi, esi
  00025	7e 0f		 jle	 SHORT $LN3@zip64local@3
  00027	56		 push	 esi
  00028	68 ff 00 00 00	 push	 255			; 000000ffH
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 _memset
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@zip64local@3:

; 323  :        {
; 324  :           buf[n] = 0xff;
; 325  :        }
; 326  :     }
; 327  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_zip64local_putValue_inmemory ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_putValue
_TEXT	SEGMENT
_filestream$ = 8					; size = 4
_buf$ = 12						; size = 8
_x$ = 12						; size = 8
_zip64local_putValue PROC				; COMDAT
; _pzlib_filefunc_def$ = edi
; _nbByte$ = esi

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  :     unsigned char buf[8];
; 290  :     int n;
; 291  :     for (n = 0; n < nbByte; n++)

  00003	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp+4]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	7e 11		 jle	 SHORT $LN7@zip64local@4
  0000f	90		 npad	 1
$LL9@zip64local@4:

; 292  :     {
; 293  :         buf[n] = (unsigned char)(x & 0xff);

  00010	88 44 0d 0c	 mov	 BYTE PTR _buf$[ebp+ecx], al

; 294  :         x >>= 8;

  00014	0f ac d0 08	 shrd	 eax, edx, 8
  00018	41		 inc	 ecx
  00019	c1 ea 08	 shr	 edx, 8
  0001c	3b ce		 cmp	 ecx, esi
  0001e	7c f0		 jl	 SHORT $LL9@zip64local@4
$LN7@zip64local@4:

; 295  :     }
; 296  :     if (x != 0)

  00020	0b c2		 or	 eax, edx
  00022	74 16		 je	 SHORT $LN5@zip64local@4

; 297  :       {     /* data overflow - hack for ZIP64 (X Roche) */
; 298  :       for (n = 0; n < nbByte; n++)

  00024	85 f6		 test	 esi, esi
  00026	7e 12		 jle	 SHORT $LN5@zip64local@4
  00028	56		 push	 esi
  00029	8d 45 0c	 lea	 eax, DWORD PTR _buf$[ebp]
  0002c	68 ff 00 00 00	 push	 255			; 000000ffH
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memset
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@zip64local@4:

; 299  :         {
; 300  :           buf[n] = 0xff;
; 301  :         }
; 302  :       }
; 303  : 
; 304  :     if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)

  0003a	8b 55 08	 mov	 edx, DWORD PTR _filestream$[ebp]
  0003d	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00040	56		 push	 esi
  00041	8d 4d 0c	 lea	 ecx, DWORD PTR _buf$[ebp]
  00044	51		 push	 ecx
  00045	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	ff d1		 call	 ecx
  0004c	2b c6		 sub	 eax, esi
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	f7 d8		 neg	 eax
  00053	1b c0		 sbb	 eax, eax

; 305  :         return ZIP_ERRNO;
; 306  :     else
; 307  :         return ZIP_OK;
; 308  : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_zip64local_putValue ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _init_linkedlist
_TEXT	SEGMENT
_init_linkedlist PROC					; COMDAT
; _ll$ = eax

; 215  :     ll->first_block = ll->last_block = NULL;

  00000	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00007	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 216  : }

  0000d	c3		 ret	 0
_init_linkedlist ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _free_datablock
_TEXT	SEGMENT
_free_datablock PROC					; COMDAT
; _ldi$ = eax

; 205  :     while (ldi!=NULL)

  00000	85 c0		 test	 eax, eax
  00002	74 13		 je	 SHORT $LN2@free_datab
  00004	56		 push	 esi
$LL3@free_datab:

; 206  :     {
; 207  :         linkedlist_datablock_internal* ldinext = ldi->next_datablock;

  00005	8b 30		 mov	 esi, DWORD PTR [eax]

; 208  :         TRYFREE(ldi);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	83 c4 04	 add	 esp, 4

; 209  :         ldi = ldinext;

  00010	8b c6		 mov	 eax, esi
  00012	85 f6		 test	 esi, esi
  00014	75 ef		 jne	 SHORT $LL3@free_datab
  00016	5e		 pop	 esi
$LN2@free_datab:

; 210  :     }
; 211  : }

  00017	c3		 ret	 0
_free_datablock ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _allocate_new_datablock
_TEXT	SEGMENT
_allocate_new_datablock PROC				; COMDAT

; 191  :     linkedlist_datablock_internal* ldi;
; 192  :     ldi = (linkedlist_datablock_internal*)
; 193  :                  ALLOC(sizeof(linkedlist_datablock_internal));

  00000	68 00 10 00 00	 push	 4096			; 00001000H
  00005	e8 00 00 00 00	 call	 _malloc
  0000a	83 c4 04	 add	 esp, 4

; 194  :     if (ldi!=NULL)

  0000d	85 c0		 test	 eax, eax
  0000f	74 14		 je	 SHORT $LN1@allocate_n

; 195  :     {
; 196  :         ldi->next_datablock = NULL ;

  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 197  :         ldi->filled_in_this_block = 0 ;

  00017	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 198  :         ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;

  0001e	c7 40 04 f0 0f
	00 00		 mov	 DWORD PTR [eax+4], 4080	; 00000ff0H
$LN1@allocate_n:

; 199  :     }
; 200  :     return ldi;
; 201  : }

  00025	c3		 ret	 0
_allocate_new_datablock ENDP
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\crypt.h
_TEXT	ENDS
;	COMDAT _update_keys
_TEXT	SEGMENT
_update_keys PROC					; COMDAT
; _pkeys$ = esi
; _pcrc_32_tab$ = edi
; _c$ = eax

; 50   :     (*(pkeys+0)) = CRC32((*(pkeys+0)), c);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b d1		 mov	 edx, ecx
  00004	33 d0		 xor	 edx, eax
  00006	c1 e9 08	 shr	 ecx, 8
  00009	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0000f	8b 14 97	 mov	 edx, DWORD PTR [edi+edx*4]
  00012	33 d1		 xor	 edx, ecx

; 51   :     (*(pkeys+1)) += (*(pkeys+0)) & 0xff;

  00014	0f b6 ca	 movzx	 ecx, dl

; 52   :     (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;

  00017	03 4e 04	 add	 ecx, DWORD PTR [esi+4]
  0001a	89 16		 mov	 DWORD PTR [esi], edx

; 53   :     {
; 54   :       register int keyshift = (int)((*(pkeys+1)) >> 24);
; 55   :       (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);

  0001c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0001f	69 c9 05 84 08
	08		 imul	 ecx, 134775813		; 08088405H
  00025	41		 inc	 ecx
  00026	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00029	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0002c	33 ca		 xor	 ecx, edx
  0002e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00034	c1 ea 08	 shr	 edx, 8
  00037	33 14 8f	 xor	 edx, DWORD PTR [edi+ecx*4]
  0003a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 56   :     }
; 57   :     return c;
; 58   : }

  0003d	c3		 ret	 0
_update_keys ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _decrypt_byte
_TEXT	SEGMENT
_decrypt_byte PROC					; COMDAT
; _pkeys$ = eax

; 37   :     unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
; 38   :                      * unpredictable manner on 16-bit systems; not a problem
; 39   :                      * with any known compiler so far, though */
; 40   : 
; 41   :     temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	81 e1 fd ff 00
	00		 and	 ecx, 65533		; 0000fffdH
  00009	83 c9 02	 or	 ecx, 2

; 42   :     return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);

  0000c	8b c1		 mov	 eax, ecx
  0000e	83 f0 01	 xor	 eax, 1
  00011	0f af c1	 imul	 eax, ecx
  00014	c1 e8 08	 shr	 eax, 8
  00017	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 43   : }

  0001c	c3		 ret	 0
_decrypt_byte ENDP
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	ENDS
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	83 c4 04	 add	 esp, 4

; 134  : }

  0000a	c3		 ret	 0
_time	ENDP
PUBLIC	_Write_GlobalComment
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\zip.c
;	COMDAT _Write_GlobalComment
_TEXT	SEGMENT
_global_comment$ = 8					; size = 4
_Write_GlobalComment PROC				; COMDAT
; _zi$ = eax

; 1865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f8		 mov	 edi, eax

; 1866 :   int err = ZIP_OK;
; 1867 :   uInt size_global_comment = 0;
; 1868 : 
; 1869 :   if(global_comment != NULL)

  00008	8b 45 08	 mov	 eax, DWORD PTR _global_comment$[ebp]
  0000b	33 db		 xor	 ebx, ebx
  0000d	85 c0		 test	 eax, eax
  0000f	74 0e		 je	 SHORT $LN3@Write_Glob

; 1870 :     size_global_comment = (uInt)strlen(global_comment);

  00011	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL6@Write_Glob:
  00014	8a 08		 mov	 cl, BYTE PTR [eax]
  00016	40		 inc	 eax
  00017	84 c9		 test	 cl, cl
  00019	75 f9		 jne	 SHORT $LL6@Write_Glob
  0001b	2b c2		 sub	 eax, edx
  0001d	8b d8		 mov	 ebx, eax
$LN3@Write_Glob:

; 1871 : 
; 1872 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);

  0001f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00022	6a 00		 push	 0
  00024	53		 push	 ebx
  00025	50		 push	 eax
  00026	be 02 00 00 00	 mov	 esi, 2
  0002b	e8 00 00 00 00	 call	 _zip64local_putValue
  00030	8b f0		 mov	 esi, eax
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1873 : 
; 1874 :   if (err == ZIP_OK && size_global_comment > 0)

  00035	85 f6		 test	 esi, esi
  00037	75 25		 jne	 SHORT $LN9@Write_Glob
  00039	85 db		 test	 ebx, ebx
  0003b	74 21		 je	 SHORT $LN9@Write_Glob

; 1875 :   {
; 1876 :     if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _global_comment$[ebp]
  00040	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00043	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00046	53		 push	 ebx
  00047	51		 push	 ecx
  00048	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	ff d1		 call	 ecx
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	3b c3		 cmp	 eax, ebx
  00054	74 08		 je	 SHORT $LN9@Write_Glob

; 1877 :       err = ZIP_ERRNO;

  00056	83 c8 ff	 or	 eax, -1

; 1878 :   }
; 1879 :   return err;
; 1880 : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN9@Write_Glob:
  0005e	5f		 pop	 edi
  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_Write_GlobalComment ENDP
_TEXT	ENDS
PUBLIC	_Write_EndOfCentralDirectoryRecord
; Function compile flags: /Ogtp
;	COMDAT _Write_EndOfCentralDirectoryRecord
_TEXT	SEGMENT
tv145 = -8						; size = 8
_size_centraldir$ = 8					; size = 4
_centraldir_pos_inzip$ = 12				; size = 8
_Write_EndOfCentralDirectoryRecord PROC			; COMDAT
; _zi$ = eax

; 1817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax

; 1818 :   int err = ZIP_OK;
; 1819 : 
; 1820 :   /*signature*/
; 1821 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);

  0000a	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0000d	6a 00		 push	 0
  0000f	68 50 4b 05 06	 push	 101010256		; 06054b50H
  00014	50		 push	 eax
  00015	be 04 00 00 00	 mov	 esi, 4
  0001a	e8 00 00 00 00	 call	 _zip64local_putValue
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1822 : 
; 1823 :   if (err==ZIP_OK) /* number of this disk */

  00022	85 c0		 test	 eax, eax
  00024	0f 85 0f 01 00
	00		 jne	 $LN1@Write_EndO

; 1824 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);

  0002a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0002d	50		 push	 eax
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  00033	e8 00 00 00 00	 call	 _zip64local_putValue
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1825 : 
; 1826 :   if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 f6 00 00
	00		 jne	 $LN1@Write_EndO

; 1827 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);

  00043	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00046	50		 push	 eax
  00047	50		 push	 eax
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _zip64local_putValue
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1828 : 
; 1829 :   if (err==ZIP_OK) /* total number of entries in the central dir on this disk */

  00051	85 c0		 test	 eax, eax
  00053	0f 85 e0 00 00
	00		 jne	 $LN1@Write_EndO

; 1830 :   {
; 1831 :     {
; 1832 :       if(zi->number_entry >= 0xFFFF)

  00059	39 87 fc 00 01
	00		 cmp	 DWORD PTR [edi+65788], eax
  0005f	77 0c		 ja	 SHORT $LN15@Write_EndO
  00061	81 bf f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [edi+65784], 65535 ; 0000ffffH
  0006b	72 0d		 jb	 SHORT $LN9@Write_EndO
$LN15@Write_EndO:

; 1833 :         err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record

  0006d	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00070	6a 00		 push	 0
  00072	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00077	50		 push	 eax

; 1834 :       else

  00078	eb 0d		 jmp	 SHORT $LN24@Write_EndO
$LN9@Write_EndO:

; 1835 :         err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);

  0007a	8b 8f f8 00 01
	00		 mov	 ecx, DWORD PTR [edi+65784]
  00080	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00083	6a 00		 push	 0
  00085	51		 push	 ecx
  00086	52		 push	 edx
$LN24@Write_EndO:
  00087	e8 00 00 00 00	 call	 _zip64local_putValue
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1836 :     }
; 1837 :   }
; 1838 : 
; 1839 :   if (err==ZIP_OK) /* total number of entries in the central dir */

  0008f	85 c0		 test	 eax, eax
  00091	0f 85 a2 00 00
	00		 jne	 $LN1@Write_EndO

; 1840 :   {
; 1841 :     if(zi->number_entry >= 0xFFFF)

  00097	39 87 fc 00 01
	00		 cmp	 DWORD PTR [edi+65788], eax
  0009d	77 0c		 ja	 SHORT $LN16@Write_EndO
  0009f	81 bf f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [edi+65784], 65535 ; 0000ffffH
  000a9	72 0d		 jb	 SHORT $LN6@Write_EndO
$LN16@Write_EndO:

; 1842 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record

  000ab	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000ae	6a 00		 push	 0
  000b0	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000b5	50		 push	 eax

; 1843 :     else

  000b6	eb 0d		 jmp	 SHORT $LN25@Write_EndO
$LN6@Write_EndO:

; 1844 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);

  000b8	8b 8f f8 00 01
	00		 mov	 ecx, DWORD PTR [edi+65784]
  000be	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  000c1	6a 00		 push	 0
  000c3	51		 push	 ecx
  000c4	52		 push	 edx
$LN25@Write_EndO:
  000c5	be 02 00 00 00	 mov	 esi, 2
  000ca	e8 00 00 00 00	 call	 _zip64local_putValue
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1845 :   }
; 1846 : 
; 1847 :   if (err==ZIP_OK) /* size of the central directory */

  000d2	85 c0		 test	 eax, eax
  000d4	75 63		 jne	 SHORT $LN1@Write_EndO

; 1848 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);

  000d6	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000d9	50		 push	 eax
  000da	8b 45 08	 mov	 eax, DWORD PTR _size_centraldir$[ebp]
  000dd	50		 push	 eax
  000de	51		 push	 ecx
  000df	be 04 00 00 00	 mov	 esi, 4
  000e4	e8 00 00 00 00	 call	 _zip64local_putValue
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1849 : 
; 1850 :   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */

  000ec	85 c0		 test	 eax, eax
  000ee	75 49		 jne	 SHORT $LN1@Write_EndO

; 1851 :   {
; 1852 :     ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  000f0	8b 45 0c	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[ebp]
  000f3	8b 55 10	 mov	 edx, DWORD PTR _centraldir_pos_inzip$[ebp+4]
  000f6	8b c8		 mov	 ecx, eax
  000f8	2b 8f f0 00 01
	00		 sub	 ecx, DWORD PTR [edi+65776]
  000fe	1b 97 f4 00 01
	00		 sbb	 edx, DWORD PTR [edi+65780]

; 1853 :     if(pos >= 0xffffffff)

  00104	89 55 fc	 mov	 DWORD PTR tv145[ebp+4], edx
  00107	75 05		 jne	 SHORT $LN17@Write_EndO
  00109	83 f9 ff	 cmp	 ecx, -1
  0010c	72 16		 jb	 SHORT $LN2@Write_EndO
$LN17@Write_EndO:

; 1854 :     {
; 1855 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);

  0010e	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00111	6a 00		 push	 0
  00113	6a ff		 push	 -1
  00115	50		 push	 eax

; 1856 :     }
; 1857 :     else
; 1858 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);

  00116	e8 00 00 00 00	 call	 _zip64local_putValue
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1859 :   }
; 1860 : 
; 1861 :    return err;
; 1862 : }

  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
$LN2@Write_EndO:

; 1856 :     }
; 1857 :     else
; 1858 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);

  00124	2b 87 f0 00 01
	00		 sub	 eax, DWORD PTR [edi+65776]
  0012a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0012d	6a 00		 push	 0
  0012f	50		 push	 eax
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 _zip64local_putValue
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Write_EndO:

; 1859 :   }
; 1860 : 
; 1861 :    return err;
; 1862 : }

  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_Write_EndOfCentralDirectoryRecord ENDP
_TEXT	ENDS
PUBLIC	_Write_Zip64EndOfCentralDirectoryRecord
; Function compile flags: /Ogtp
;	COMDAT _Write_Zip64EndOfCentralDirectoryRecord
_TEXT	SEGMENT
_size_centraldir$ = 8					; size = 4
_centraldir_pos_inzip$ = 12				; size = 8
_Write_Zip64EndOfCentralDirectoryRecord PROC		; COMDAT
; _zi$ = eax

; 1778 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax

; 1779 :   int err = ZIP_OK;
; 1780 : 
; 1781 :   uLong Zip64DataSize = 44;
; 1782 : 
; 1783 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);

  00007	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0000a	6a 00		 push	 0
  0000c	68 50 4b 06 06	 push	 101075792		; 06064b50H
  00011	50		 push	 eax
  00012	be 04 00 00 00	 mov	 esi, 4
  00017	e8 00 00 00 00	 call	 _zip64local_putValue
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1784 : 
; 1785 :   if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */

  0001f	85 c0		 test	 eax, eax
  00021	0f 85 ec 00 00
	00		 jne	 $LN1@Write_Zip6

; 1786 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?

  00027	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0002a	50		 push	 eax
  0002b	6a 2c		 push	 44			; 0000002cH
  0002d	51		 push	 ecx
  0002e	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  00031	e8 00 00 00 00	 call	 _zip64local_putValue
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1787 : 
; 1788 :   if (err==ZIP_OK) /* version made by */

  00039	85 c0		 test	 eax, eax
  0003b	0f 85 d2 00 00
	00		 jne	 $LN1@Write_Zip6

; 1789 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);

  00041	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00044	50		 push	 eax
  00045	6a 2d		 push	 45			; 0000002dH
  00047	52		 push	 edx
  00048	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0004b	e8 00 00 00 00	 call	 _zip64local_putValue
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1790 : 
; 1791 :   if (err==ZIP_OK) /* version needed */

  00053	85 c0		 test	 eax, eax
  00055	0f 85 b8 00 00
	00		 jne	 $LN1@Write_Zip6

; 1792 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);

  0005b	50		 push	 eax
  0005c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0005f	6a 2d		 push	 45			; 0000002dH
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _zip64local_putValue
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1793 : 
; 1794 :   if (err==ZIP_OK) /* number of this disk */

  0006a	85 c0		 test	 eax, eax
  0006c	0f 85 a1 00 00
	00		 jne	 $LN1@Write_Zip6

; 1795 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  00072	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00075	50		 push	 eax
  00076	50		 push	 eax
  00077	51		 push	 ecx
  00078	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  0007b	e8 00 00 00 00	 call	 _zip64local_putValue
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1796 : 
; 1797 :   if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00083	85 c0		 test	 eax, eax
  00085	0f 85 88 00 00
	00		 jne	 $LN1@Write_Zip6

; 1798 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  0008b	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0008e	50		 push	 eax
  0008f	50		 push	 eax
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _zip64local_putValue
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1799 : 
; 1800 :   if (err==ZIP_OK) /* total number of entries in the central dir on this disk */

  00099	85 c0		 test	 eax, eax
  0009b	75 76		 jne	 SHORT $LN1@Write_Zip6

; 1801 :     err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  0009d	8b 87 fc 00 01
	00		 mov	 eax, DWORD PTR [edi+65788]
  000a3	8b 8f f8 00 01
	00		 mov	 ecx, DWORD PTR [edi+65784]
  000a9	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  000ac	50		 push	 eax
  000ad	51		 push	 ecx
  000ae	52		 push	 edx
  000af	be 08 00 00 00	 mov	 esi, 8
  000b4	e8 00 00 00 00	 call	 _zip64local_putValue
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1802 : 
; 1803 :   if (err==ZIP_OK) /* total number of entries in the central dir */

  000bc	85 c0		 test	 eax, eax
  000be	75 53		 jne	 SHORT $LN1@Write_Zip6

; 1804 :     err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  000c0	8b 87 fc 00 01
	00		 mov	 eax, DWORD PTR [edi+65788]
  000c6	8b 8f f8 00 01
	00		 mov	 ecx, DWORD PTR [edi+65784]
  000cc	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _zip64local_putValue
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1805 : 
; 1806 :   if (err==ZIP_OK) /* size of the central directory */

  000da	85 c0		 test	 eax, eax
  000dc	75 35		 jne	 SHORT $LN1@Write_Zip6

; 1807 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);

  000de	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000e1	50		 push	 eax
  000e2	8b 45 08	 mov	 eax, DWORD PTR _size_centraldir$[ebp]
  000e5	50		 push	 eax
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 _zip64local_putValue
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1808 : 
; 1809 :   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */

  000ef	85 c0		 test	 eax, eax
  000f1	75 20		 jne	 SHORT $LN1@Write_Zip6

; 1810 :   {
; 1811 :     ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[ebp]
  000f6	2b 87 f0 00 01
	00		 sub	 eax, DWORD PTR [edi+65776]
  000fc	8b 4d 10	 mov	 ecx, DWORD PTR _centraldir_pos_inzip$[ebp+4]
  000ff	1b 8f f4 00 01
	00		 sbb	 ecx, DWORD PTR [edi+65780]

; 1812 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);

  00105	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00108	51		 push	 ecx
  00109	50		 push	 eax
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 _zip64local_putValue
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Write_Zip6:

; 1813 :   }
; 1814 :   return err;
; 1815 : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_Write_Zip64EndOfCentralDirectoryRecord ENDP
_TEXT	ENDS
PUBLIC	_Write_Zip64EndOfCentralDirectoryLocator
; Function compile flags: /Ogtp
;	COMDAT _Write_Zip64EndOfCentralDirectoryLocator
_TEXT	SEGMENT
_pos$ = 8						; size = 8
_zip64eocd_pos_inzip$ = 8				; size = 8
_Write_Zip64EndOfCentralDirectoryLocator PROC		; COMDAT
; _zi$ = eax

; 1756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1757 :   int err = ZIP_OK;
; 1758 :   ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _zip64eocd_pos_inzip$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax
  0000b	2b 9f f0 00 01
	00		 sub	 ebx, DWORD PTR [edi+65776]
  00011	8b 45 0c	 mov	 eax, DWORD PTR _zip64eocd_pos_inzip$[ebp+4]
  00014	1b 87 f4 00 01
	00		 sbb	 eax, DWORD PTR [edi+65780]

; 1759 : 
; 1760 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);

  0001a	6a 00		 push	 0
  0001c	89 45 0c	 mov	 DWORD PTR _pos$[ebp+4], eax
  0001f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00022	68 50 4b 06 07	 push	 117853008		; 07064b50H
  00027	50		 push	 eax
  00028	be 04 00 00 00	 mov	 esi, 4
  0002d	e8 00 00 00 00	 call	 _zip64local_putValue
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1761 : 
; 1762 :   /*num disks*/
; 1763 :     if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00035	85 c0		 test	 eax, eax
  00037	75 3e		 jne	 SHORT $LN1@Write_Zip6@2

; 1764 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  00039	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0003c	50		 push	 eax
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _zip64local_putValue
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 : 
; 1766 :   /*relative offset*/
; 1767 :     if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */

  00047	85 c0		 test	 eax, eax
  00049	75 2c		 jne	 SHORT $LN1@Write_Zip6@2

; 1768 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);

  0004b	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp+4]
  0004e	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00051	52		 push	 edx
  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	be 08 00 00 00	 mov	 esi, 8
  00059	e8 00 00 00 00	 call	 _zip64local_putValue
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1769 : 
; 1770 :   /*total disks*/ /* Do not support spawning of disk so always say 1 here*/
; 1771 :     if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00061	85 c0		 test	 eax, eax
  00063	75 12		 jne	 SHORT $LN1@Write_Zip6@2

; 1772 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);

  00065	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00068	50		 push	 eax
  00069	6a 01		 push	 1
  0006b	51		 push	 ecx
  0006c	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  0006f	e8 00 00 00 00	 call	 _zip64local_putValue
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Write_Zip6@2:

; 1773 : 
; 1774 :     return err;
; 1775 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_Write_Zip64EndOfCentralDirectoryLocator ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64FlushWriteBuffer
_TEXT	SEGMENT
tv232 = -16						; size = 4
_t$83568 = -12						; size = 4
_err$ = -8						; size = 4
tv222 = -4						; size = 4
_zip64FlushWriteBuffer PROC				; COMDAT
; _zi$ = ebx

; 1364 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1365 :     int err=ZIP_OK;

  00008	33 ff		 xor	 edi, edi
  0000a	89 7d f8	 mov	 DWORD PTR _err$[ebp], edi

; 1366 : 
; 1367 :     if (zi->ci.encrypt != 0)

  0000d	39 bb ac 00 01
	00		 cmp	 DWORD PTR [ebx+65708], edi
  00013	74 51		 je	 SHORT $LN2@zip64Flush

; 1368 :     {
; 1369 : #ifndef NOCRYPT
; 1370 :         uInt i;
; 1371 :         int t;
; 1372 :         for (i=0;i<zi->ci.pos_in_buffered_data;i++)

  00015	39 7b 7c	 cmp	 DWORD PTR [ebx+124], edi
  00018	76 4c		 jbe	 SHORT $LN2@zip64Flush
  0001a	8d 83 a4 00 00
	00		 lea	 eax, DWORD PTR [ebx+164]
  00020	89 45 fc	 mov	 DWORD PTR tv222[ebp], eax
  00023	b8 5c ff ff ff	 mov	 eax, -164		; ffffff5cH
  00028	2b c3		 sub	 eax, ebx
  0002a	8d b3 d0 00 01
	00		 lea	 esi, DWORD PTR [ebx+65744]
  00030	89 45 f0	 mov	 DWORD PTR tv232[ebp], eax
$LL10@zip64Flush:

; 1373 :             zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);

  00033	8b c6		 mov	 eax, esi
  00035	e8 00 00 00 00	 call	 _decrypt_byte
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR tv222[ebp]
  0003d	8b bb dc 00 01
	00		 mov	 edi, DWORD PTR [ebx+65756]
  00043	89 45 f4	 mov	 DWORD PTR _t$83568[ebp], eax
  00046	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00049	e8 00 00 00 00	 call	 _update_keys
  0004e	8b 45 fc	 mov	 eax, DWORD PTR tv222[ebp]
  00051	8a 55 f4	 mov	 dl, BYTE PTR _t$83568[ebp]
  00054	30 10		 xor	 BYTE PTR [eax], dl
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv232[ebp]
  00059	40		 inc	 eax
  0005a	03 c8		 add	 ecx, eax
  0005c	89 45 fc	 mov	 DWORD PTR tv222[ebp], eax
  0005f	3b 4b 7c	 cmp	 ecx, DWORD PTR [ebx+124]
  00062	72 cf		 jb	 SHORT $LL10@zip64Flush

; 1368 :     {
; 1369 : #ifndef NOCRYPT
; 1370 :         uInt i;
; 1371 :         int t;
; 1372 :         for (i=0;i<zi->ci.pos_in_buffered_data;i++)

  00064	33 ff		 xor	 edi, edi
$LN2@zip64Flush:

; 1374 : #endif
; 1375 :     }
; 1376 : 
; 1377 :     if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)

  00066	8b 73 7c	 mov	 esi, DWORD PTR [ebx+124]
  00069	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  0006c	8b 53 1c	 mov	 edx, DWORD PTR [ebx+28]
  0006f	56		 push	 esi
  00070	8d 83 a4 00 00
	00		 lea	 eax, DWORD PTR [ebx+164]
  00076	50		 push	 eax
  00077	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007a	51		 push	 ecx
  0007b	52		 push	 edx
  0007c	ff d0		 call	 eax
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	3b c6		 cmp	 eax, esi
  00083	74 07		 je	 SHORT $LN1@zip64Flush

; 1378 :       err = ZIP_ERRNO;

  00085	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1
$LN1@zip64Flush:

; 1379 : 
; 1380 :     zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;

  0008c	01 b3 c0 00 01
	00		 add	 DWORD PTR [ebx+65728], esi

; 1381 : 
; 1382 : #ifdef HAVE_BZIP2
; 1383 :     if(zi->ci.method == Z_BZIP2ED)
; 1384 :     {
; 1385 :       zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
; 1386 :       zi->ci.bstream.total_in_lo32 = 0;
; 1387 :       zi->ci.bstream.total_in_hi32 = 0;
; 1388 :     }
; 1389 :     else
; 1390 : #endif
; 1391 :     {
; 1392 :       zi->ci.totalUncompressedData += zi->ci.stream.total_in;

  00092	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]

; 1393 :       zi->ci.stream.total_in = 0;
; 1394 :     }
; 1395 : 
; 1396 : 
; 1397 :     zi->ci.pos_in_buffered_data = 0;
; 1398 : 
; 1399 :     return err;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _err$[ebp]
  00098	11 bb c4 00 01
	00		 adc	 DWORD PTR [ebx+65732], edi
  0009e	01 8b c8 00 01
	00		 add	 DWORD PTR [ebx+65736], ecx
  000a4	89 7b 48	 mov	 DWORD PTR [ebx+72], edi
  000a7	89 7b 7c	 mov	 DWORD PTR [ebx+124], edi
  000aa	11 bb cc 00 01
	00		 adc	 DWORD PTR [ebx+65740], edi
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi

; 1400 : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_zip64FlushWriteBuffer ENDP
_TEXT	ENDS
PUBLIC	_Write_LocalFileHeader
; Function compile flags: /Ogtp
;	COMDAT _Write_LocalFileHeader
_TEXT	SEGMENT
_size_extrafield$ = -4					; size = 4
_filename$ = 8						; size = 4
_size_extrafield_local$ = 12				; size = 4
_extrafield_local$ = 16					; size = 4
_Write_LocalFileHeader PROC				; COMDAT
; _zi$ = eax

; 959  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 960  :   /* write the local header */
; 961  :   int err;
; 962  :   uInt size_filename = (uInt)strlen(filename);

  00009	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0000c	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL26@Write_Loca:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL26@Write_Loca
  00017	2b c1		 sub	 eax, ecx

; 963  :   uInt size_extrafield = size_extrafield_local;
; 964  : 
; 965  :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);

  00019	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001c	6a 00		 push	 0
  0001e	8b d8		 mov	 ebx, eax
  00020	8b 45 0c	 mov	 eax, DWORD PTR _size_extrafield_local$[ebp]
  00023	68 50 4b 03 04	 push	 67324752		; 04034b50H
  00028	51		 push	 ecx
  00029	be 04 00 00 00	 mov	 esi, 4
  0002e	89 45 fc	 mov	 DWORD PTR _size_extrafield$[ebp], eax
  00031	e8 00 00 00 00	 call	 _zip64local_putValue
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 966  : 
; 967  :   if (err==ZIP_OK)

  00039	85 c0		 test	 eax, eax
  0003b	0f 85 f1 00 00
	00		 jne	 $LN8@Write_Loca

; 968  :   {
; 969  :     if(zi->ci.zip64)
; 970  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */

  00041	50		 push	 eax
  00042	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  00045	39 87 b0 00 01
	00		 cmp	 DWORD PTR [edi+65712], eax
  0004b	74 08		 je	 SHORT $LN20@Write_Loca
  0004d	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00050	6a 2d		 push	 45			; 0000002dH
  00052	52		 push	 edx

; 971  :     else

  00053	eb 06		 jmp	 SHORT $LN34@Write_Loca
$LN20@Write_Loca:

; 972  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */

  00055	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00058	6a 14		 push	 20			; 00000014H
  0005a	50		 push	 eax
$LN34@Write_Loca:
  0005b	e8 00 00 00 00	 call	 _zip64local_putValue
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 973  :   }
; 974  : 
; 975  :   if (err==ZIP_OK)

  00063	85 c0		 test	 eax, eax
  00065	0f 85 c7 00 00
	00		 jne	 $LN8@Write_Loca

; 976  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);

  0006b	8b 8f 98 00 00
	00		 mov	 ecx, DWORD PTR [edi+152]
  00071	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00074	50		 push	 eax
  00075	51		 push	 ecx
  00076	52		 push	 edx
  00077	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0007a	e8 00 00 00 00	 call	 _zip64local_putValue
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 977  : 
; 978  :   if (err==ZIP_OK)

  00082	85 c0		 test	 eax, eax
  00084	0f 85 a8 00 00
	00		 jne	 $LN8@Write_Loca

; 979  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);

  0008a	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  00090	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00093	6a 00		 push	 0
  00095	50		 push	 eax
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _zip64local_putValue
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 980  : 
; 981  :   if (err==ZIP_OK)

  0009f	85 c0		 test	 eax, eax
  000a1	0f 85 8b 00 00
	00		 jne	 $LN8@Write_Loca

; 982  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);

  000a7	8b 97 a4 00 01
	00		 mov	 edx, DWORD PTR [edi+65700]
  000ad	50		 push	 eax
  000ae	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000b1	52		 push	 edx
  000b2	50		 push	 eax
  000b3	be 04 00 00 00	 mov	 esi, 4
  000b8	e8 00 00 00 00	 call	 _zip64local_putValue
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 983  : 
; 984  :   // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
; 985  :   if (err==ZIP_OK)

  000c0	85 c0		 test	 eax, eax
  000c2	75 6e		 jne	 SHORT $LN8@Write_Loca

; 986  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */

  000c4	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000c7	50		 push	 eax
  000c8	50		 push	 eax
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _zip64local_putValue
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 987  :   if (err==ZIP_OK)

  000d2	85 c0		 test	 eax, eax
  000d4	75 5c		 jne	 SHORT $LN8@Write_Loca

; 988  :   {
; 989  :     if(zi->ci.zip64)
; 990  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */

  000d6	50		 push	 eax
  000d7	39 87 b0 00 01
	00		 cmp	 DWORD PTR [edi+65712], eax
  000dd	74 08		 je	 SHORT $LN13@Write_Loca
  000df	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  000e2	6a ff		 push	 -1
  000e4	52		 push	 edx

; 991  :     else

  000e5	eb 06		 jmp	 SHORT $LN35@Write_Loca
$LN13@Write_Loca:

; 992  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */

  000e7	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000ea	6a 00		 push	 0
  000ec	50		 push	 eax
$LN35@Write_Loca:
  000ed	e8 00 00 00 00	 call	 _zip64local_putValue
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 993  :   }
; 994  :   if (err==ZIP_OK)

  000f5	85 c0		 test	 eax, eax
  000f7	75 39		 jne	 SHORT $LN8@Write_Loca

; 995  :   {
; 996  :     if(zi->ci.zip64)
; 997  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */

  000f9	50		 push	 eax
  000fa	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  000fd	39 87 b0 00 01
	00		 cmp	 DWORD PTR [edi+65712], eax
  00103	74 08		 je	 SHORT $LN10@Write_Loca
  00105	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00108	6a ff		 push	 -1
  0010a	51		 push	 ecx

; 998  :     else

  0010b	eb 06		 jmp	 SHORT $LN36@Write_Loca
$LN10@Write_Loca:

; 999  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */

  0010d	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00110	6a 00		 push	 0
  00112	52		 push	 edx
$LN36@Write_Loca:
  00113	e8 00 00 00 00	 call	 _zip64local_putValue
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1000 :   }
; 1001 : 
; 1002 :   if (err==ZIP_OK)

  0011b	85 c0		 test	 eax, eax
  0011d	75 13		 jne	 SHORT $LN8@Write_Loca

; 1003 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);

  0011f	50		 push	 eax
  00120	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00123	53		 push	 ebx
  00124	50		 push	 eax
  00125	be 02 00 00 00	 mov	 esi, 2
  0012a	e8 00 00 00 00	 call	 _zip64local_putValue
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@Write_Loca:

; 1004 : 
; 1005 :   if(zi->ci.zip64)

  00132	83 bf b0 00 01
	00 00		 cmp	 DWORD PTR [edi+65712], 0
  00139	74 08		 je	 SHORT $LN31@Write_Loca

; 1006 :   {
; 1007 :     size_extrafield += 20;

  0013b	8b 4d 0c	 mov	 ecx, DWORD PTR _size_extrafield_local$[ebp]
  0013e	83 c1 14	 add	 ecx, 20			; 00000014H
  00141	eb 03		 jmp	 SHORT $LN7@Write_Loca
$LN31@Write_Loca:
  00143	8b 4d fc	 mov	 ecx, DWORD PTR _size_extrafield$[ebp]
$LN7@Write_Loca:

; 1008 :   }
; 1009 : 
; 1010 :   if (err==ZIP_OK)

  00146	85 c0		 test	 eax, eax
  00148	0f 85 cb 00 00
	00		 jne	 $LN1@Write_Loca

; 1011 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);

  0014e	50		 push	 eax
  0014f	51		 push	 ecx
  00150	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00153	51		 push	 ecx
  00154	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  00157	e8 00 00 00 00	 call	 _zip64local_putValue
  0015c	8b f0		 mov	 esi, eax
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1012 : 
; 1013 :   if ((err==ZIP_OK) && (size_filename > 0))

  00161	85 f6		 test	 esi, esi
  00163	0f 85 ae 00 00
	00		 jne	 $LN28@Write_Loca
  00169	85 db		 test	 ebx, ebx
  0016b	74 23		 je	 SHORT $LN24@Write_Loca

; 1014 :   {
; 1015 :     if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)

  0016d	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  00170	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00173	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00176	53		 push	 ebx
  00177	52		 push	 edx
  00178	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0017b	50		 push	 eax
  0017c	51		 push	 ecx
  0017d	ff d2		 call	 edx
  0017f	83 c4 10	 add	 esp, 16			; 00000010H
  00182	3b c3		 cmp	 eax, ebx
  00184	74 0a		 je	 SHORT $LN24@Write_Loca
$LN37@Write_Loca:

; 1016 :       err = ZIP_ERRNO;

  00186	83 c8 ff	 or	 eax, -1

; 1045 : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
$LN24@Write_Loca:

; 1017 :   }
; 1018 : 
; 1019 :   if ((err==ZIP_OK) && (size_extrafield_local > 0))

  00190	8b 5d 0c	 mov	 ebx, DWORD PTR _size_extrafield_local$[ebp]
  00193	85 db		 test	 ebx, ebx
  00195	74 19		 je	 SHORT $LN25@Write_Loca

; 1020 :   {
; 1021 :     if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)

  00197	8b 45 10	 mov	 eax, DWORD PTR _extrafield_local$[ebp]
  0019a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0019d	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  001a0	53		 push	 ebx
  001a1	50		 push	 eax
  001a2	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001a5	51		 push	 ecx
  001a6	52		 push	 edx
  001a7	ff d0		 call	 eax
  001a9	83 c4 10	 add	 esp, 16			; 00000010H
  001ac	3b c3		 cmp	 eax, ebx

; 1022 :       err = ZIP_ERRNO;
; 1023 :   }
; 1024 : 
; 1025 : 
; 1026 :   if ((err==ZIP_OK) && (zi->ci.zip64))

  001ae	75 d6		 jne	 SHORT $LN37@Write_Loca
$LN25@Write_Loca:
  001b0	83 bf b0 00 01
	00 00		 cmp	 DWORD PTR [edi+65712], 0
  001b7	74 5e		 je	 SHORT $LN28@Write_Loca

; 1027 :   {
; 1028 :       // write the Zip64 extended info
; 1029 :       short HeaderID = 1;
; 1030 :       short DataSize = 16;
; 1031 :       ZPOS64_T CompressedSize = 0;
; 1032 :       ZPOS64_T UncompressedSize = 0;
; 1033 : 
; 1034 :       // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
; 1035 :       zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);

  001b9	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  001bc	8b c7		 mov	 eax, edi
  001be	e8 00 00 00 00	 call	 _call_ztell64

; 1036 : 
; 1037 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);

  001c3	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  001c6	6a 00		 push	 0
  001c8	6a 01		 push	 1
  001ca	51		 push	 ecx
  001cb	be 02 00 00 00	 mov	 esi, 2
  001d0	89 87 b8 00 01
	00		 mov	 DWORD PTR [edi+65720], eax
  001d6	89 97 bc 00 01
	00		 mov	 DWORD PTR [edi+65724], edx
  001dc	e8 00 00 00 00	 call	 _zip64local_putValue

; 1038 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);

  001e1	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  001e4	6a 00		 push	 0
  001e6	6a 10		 push	 16			; 00000010H
  001e8	52		 push	 edx
  001e9	e8 00 00 00 00	 call	 _zip64local_putValue

; 1039 : 
; 1040 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);

  001ee	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001f1	6a 00		 push	 0
  001f3	6a 00		 push	 0
  001f5	50		 push	 eax
  001f6	be 08 00 00 00	 mov	 esi, 8
  001fb	e8 00 00 00 00	 call	 _zip64local_putValue

; 1041 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);

  00200	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _zip64local_putValue
  0020d	83 c4 30	 add	 esp, 48			; 00000030H

; 1045 : }

  00210	5f		 pop	 edi
  00211	5e		 pop	 esi
  00212	5b		 pop	 ebx
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c3		 ret	 0
$LN28@Write_Loca:

; 1042 :   }
; 1043 : 
; 1044 :   return err;

  00217	8b c6		 mov	 eax, esi
$LN1@Write_Loca:

; 1045 : }

  00219	5f		 pop	 edi
  0021a	5e		 pop	 esi
  0021b	5b		 pop	 ebx
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	c3		 ret	 0
_Write_LocalFileHeader ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_SearchCentralDir
_TEXT	SEGMENT
_uSizeFile$ = -40					; size = 8
_uPosFound$ = -32					; size = 8
_uBackRead$ = -24					; size = 8
_uMaxBack$ = -16					; size = 8
_uReadSize$82954 = -8					; size = 4
_buf$ = -4						; size = 4
_pzlib_filefunc_def$ = 8				; size = 4
_filestream$ = 12					; size = 4
_zip64local_SearchCentralDir PROC			; COMDAT

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx

; 482  :   unsigned char* buf;
; 483  :   ZPOS64_T uSizeFile;
; 484  :   ZPOS64_T uBackRead;
; 485  :   ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
; 486  :   ZPOS64_T uPosFound=0;
; 487  : 
; 488  :   if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _pzlib_filefunc_def$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR _filestream$[ebp]
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	57		 push	 edi
  00012	57		 push	 edi
  00013	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  00016	8b c3		 mov	 eax, ebx
  00018	c7 45 f0 ff ff
	00 00		 mov	 DWORD PTR _uMaxBack$[ebp], 65535 ; 0000ffffH
  0001f	89 7d f4	 mov	 DWORD PTR _uMaxBack$[ebp+4], edi
  00022	89 7d e0	 mov	 DWORD PTR _uPosFound$[ebp], edi
  00025	89 7d e4	 mov	 DWORD PTR _uPosFound$[ebp+4], edi
  00028	e8 00 00 00 00	 call	 _call_zseek64
  0002d	83 c4 08	 add	 esp, 8
  00030	85 c0		 test	 eax, eax
  00032	74 0b		 je	 SHORT $LN14@zip64local@5
$LN40@zip64local@5:

; 489  :     return 0;

  00034	33 c0		 xor	 eax, eax
  00036	33 d2		 xor	 edx, edx

; 534  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN14@zip64local@5:

; 490  : 
; 491  : 
; 492  :   uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  0003f	8b ce		 mov	 ecx, esi
  00041	8b c3		 mov	 eax, ebx
  00043	e8 00 00 00 00	 call	 _call_ztell64
  00048	8b da		 mov	 ebx, edx
  0004a	8b f0		 mov	 esi, eax
  0004c	89 75 d8	 mov	 DWORD PTR _uSizeFile$[ebp], esi
  0004f	89 5d dc	 mov	 DWORD PTR _uSizeFile$[ebp+4], ebx

; 493  : 
; 494  :   if (uMaxBack>uSizeFile)

  00052	85 db		 test	 ebx, ebx
  00054	77 12		 ja	 SHORT $LN13@zip64local@5
  00056	72 08		 jb	 SHORT $LN27@zip64local@5
  00058	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  0005e	73 08		 jae	 SHORT $LN13@zip64local@5
$LN27@zip64local@5:

; 495  :     uMaxBack = uSizeFile;

  00060	89 75 f0	 mov	 DWORD PTR _uMaxBack$[ebp], esi
  00063	89 5d f4	 mov	 DWORD PTR _uMaxBack$[ebp+4], ebx
  00066	8b fb		 mov	 edi, ebx
$LN13@zip64local@5:

; 496  : 
; 497  :   buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);

  00068	68 04 04 00 00	 push	 1028			; 00000404H
  0006d	e8 00 00 00 00	 call	 _malloc
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 fc	 mov	 DWORD PTR _buf$[ebp], eax

; 498  :   if (buf==NULL)

  00078	85 c0		 test	 eax, eax

; 499  :     return 0;

  0007a	74 b8		 je	 SHORT $LN40@zip64local@5

; 500  : 
; 501  :   uBackRead = 4;

  0007c	33 c9		 xor	 ecx, ecx
  0007e	ba 04 00 00 00	 mov	 edx, 4

; 502  :   while (uBackRead<uMaxBack)

  00083	3b cf		 cmp	 ecx, edi
  00085	0f 87 03 01 00
	00		 ja	 $LN31@zip64local@5
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _uMaxBack$[ebp]
  0008e	72 22		 jb	 SHORT $LN11@zip64local@5
  00090	3b d0		 cmp	 edx, eax
  00092	0f 83 f6 00 00
	00		 jae	 $LN31@zip64local@5
  00098	eb 18		 jmp	 SHORT $LN11@zip64local@5
  0009a	8d 9b 00 00 00
	00		 npad	 6
$LL34@zip64local@5:
  000a0	8b 75 d8	 mov	 esi, DWORD PTR _uSizeFile$[ebp]
  000a3	8b 7d f4	 mov	 edi, DWORD PTR _uMaxBack$[ebp+4]
  000a6	8b 55 e8	 mov	 edx, DWORD PTR _uBackRead$[ebp]
  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _uBackRead$[ebp+4]
  000ac	8b 5d dc	 mov	 ebx, DWORD PTR _uSizeFile$[ebp+4]
  000af	8b 45 f0	 mov	 eax, DWORD PTR _uMaxBack$[ebp]
$LN11@zip64local@5:

; 503  :   {
; 504  :     uLong uReadSize;
; 505  :     ZPOS64_T uReadPos ;
; 506  :     int i;
; 507  :     if (uBackRead+BUFREADCOMMENT>uMaxBack)

  000b2	81 c2 00 04 00
	00		 add	 edx, 1024		; 00000400H
  000b8	83 d1 00	 adc	 ecx, 0
  000bb	3b cf		 cmp	 ecx, edi
  000bd	72 0e		 jb	 SHORT $LN9@zip64local@5
  000bf	77 04		 ja	 SHORT $LN29@zip64local@5
  000c1	3b d0		 cmp	 edx, eax
  000c3	76 08		 jbe	 SHORT $LN9@zip64local@5
$LN29@zip64local@5:

; 508  :       uBackRead = uMaxBack;

  000c5	89 45 e8	 mov	 DWORD PTR _uBackRead$[ebp], eax
  000c8	89 7d ec	 mov	 DWORD PTR _uBackRead$[ebp+4], edi

; 509  :     else

  000cb	eb 06		 jmp	 SHORT $LN8@zip64local@5
$LN9@zip64local@5:

; 510  :       uBackRead+=BUFREADCOMMENT;

  000cd	89 55 e8	 mov	 DWORD PTR _uBackRead$[ebp], edx
  000d0	89 4d ec	 mov	 DWORD PTR _uBackRead$[ebp+4], ecx
$LN8@zip64local@5:

; 511  :     uReadPos = uSizeFile-uBackRead ;
; 512  : 
; 513  :     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
; 514  :       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);

  000d3	8b 45 dc	 mov	 eax, DWORD PTR _uSizeFile$[ebp+4]
  000d6	8b fe		 mov	 edi, esi
  000d8	2b 7d e8	 sub	 edi, DWORD PTR _uBackRead$[ebp]
  000db	8b ce		 mov	 ecx, esi
  000dd	1b 5d ec	 sbb	 ebx, DWORD PTR _uBackRead$[ebp+4]
  000e0	2b cf		 sub	 ecx, edi
  000e2	1b c3		 sbb	 eax, ebx
  000e4	85 c0		 test	 eax, eax
  000e6	72 13		 jb	 SHORT $LN17@zip64local@5
  000e8	77 08		 ja	 SHORT $LN30@zip64local@5
  000ea	81 f9 04 04 00
	00		 cmp	 ecx, 1028		; 00000404H
  000f0	76 09		 jbe	 SHORT $LN17@zip64local@5
$LN30@zip64local@5:
  000f2	c7 45 f8 04 04
	00 00		 mov	 DWORD PTR _uReadSize$82954[ebp], 1028 ; 00000404H
  000f9	eb 05		 jmp	 SHORT $LN18@zip64local@5
$LN17@zip64local@5:
  000fb	2b f7		 sub	 esi, edi
  000fd	89 75 f8	 mov	 DWORD PTR _uReadSize$82954[ebp], esi
$LN18@zip64local@5:

; 515  :     if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  00100	8b 75 0c	 mov	 esi, DWORD PTR _filestream$[ebp]
  00103	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00106	53		 push	 ebx
  00107	57		 push	 edi
  00108	33 d2		 xor	 edx, edx
  0010a	e8 00 00 00 00	 call	 _call_zseek64
  0010f	83 c4 08	 add	 esp, 8
  00112	85 c0		 test	 eax, eax
  00114	75 78		 jne	 SHORT $LN31@zip64local@5

; 516  :       break;
; 517  : 
; 518  :     if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)

  00116	8b 75 f8	 mov	 esi, DWORD PTR _uReadSize$82954[ebp]
  00119	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]
  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _filestream$[ebp]
  0011f	56		 push	 esi
  00120	50		 push	 eax
  00121	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00124	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00127	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012a	51		 push	 ecx
  0012b	52		 push	 edx
  0012c	ff d0		 call	 eax
  0012e	83 c4 10	 add	 esp, 16			; 00000010H
  00131	3b c6		 cmp	 eax, esi
  00133	75 59		 jne	 SHORT $LN31@zip64local@5

; 519  :       break;
; 520  : 
; 521  :     for (i=(int)uReadSize-3; (i--)>0;)

  00135	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]
  00138	85 c0		 test	 eax, eax
  0013a	7e 38		 jle	 SHORT $LN26@zip64local@5
  0013c	8d 64 24 00	 npad	 4
$LL5@zip64local@5:

; 522  :       if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
; 523  :         ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))

  00140	8b 4d fc	 mov	 ecx, DWORD PTR _buf$[ebp]
  00143	48		 dec	 eax
  00144	80 3c 08 50	 cmp	 BYTE PTR [eax+ecx], 80	; 00000050H
  00148	75 15		 jne	 SHORT $LN3@zip64local@5
  0014a	80 7c 08 01 4b	 cmp	 BYTE PTR [eax+ecx+1], 75 ; 0000004bH
  0014f	75 0e		 jne	 SHORT $LN3@zip64local@5
  00151	80 7c 08 02 05	 cmp	 BYTE PTR [eax+ecx+2], 5
  00156	75 07		 jne	 SHORT $LN3@zip64local@5
  00158	80 7c 08 03 06	 cmp	 BYTE PTR [eax+ecx+3], 6
  0015d	74 06		 je	 SHORT $LN21@zip64local@5
$LN3@zip64local@5:

; 519  :       break;
; 520  : 
; 521  :     for (i=(int)uReadSize-3; (i--)>0;)

  0015f	85 c0		 test	 eax, eax
  00161	7f dd		 jg	 SHORT $LL5@zip64local@5

; 526  :         break;
; 527  :       }
; 528  : 
; 529  :       if (uPosFound!=0)

  00163	eb 0f		 jmp	 SHORT $LN26@zip64local@5
$LN21@zip64local@5:

; 524  :       {
; 525  :         uPosFound = uReadPos+i;

  00165	99		 cdq
  00166	03 c7		 add	 eax, edi
  00168	13 d3		 adc	 edx, ebx
  0016a	89 45 e0	 mov	 DWORD PTR _uPosFound$[ebp], eax

; 526  :         break;
; 527  :       }
; 528  : 
; 529  :       if (uPosFound!=0)

  0016d	0b c2		 or	 eax, edx
  0016f	89 55 e4	 mov	 DWORD PTR _uPosFound$[ebp+4], edx
  00172	75 1a		 jne	 SHORT $LN31@zip64local@5
$LN26@zip64local@5:

; 502  :   while (uBackRead<uMaxBack)

  00174	8b 4d f4	 mov	 ecx, DWORD PTR _uMaxBack$[ebp+4]
  00177	39 4d ec	 cmp	 DWORD PTR _uBackRead$[ebp+4], ecx
  0017a	0f 82 20 ff ff
	ff		 jb	 $LL34@zip64local@5
  00180	77 0c		 ja	 SHORT $LN31@zip64local@5
  00182	8b 55 f0	 mov	 edx, DWORD PTR _uMaxBack$[ebp]
  00185	39 55 e8	 cmp	 DWORD PTR _uBackRead$[ebp], edx
  00188	0f 82 12 ff ff
	ff		 jb	 $LL34@zip64local@5
$LN31@zip64local@5:

; 530  :         break;
; 531  :   }
; 532  :   TRYFREE(buf);

  0018e	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 _free

; 533  :   return uPosFound;

  00197	8b 45 e0	 mov	 eax, DWORD PTR _uPosFound$[ebp]
  0019a	8b 55 e4	 mov	 edx, DWORD PTR _uPosFound$[ebp+4]
  0019d	83 c4 04	 add	 esp, 4

; 534  : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
_zip64local_SearchCentralDir ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_getLong64
_TEXT	SEGMENT
_x$ = -16						; size = 8
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getLong64 PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = eax

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax

; 428  :   ZPOS64_T x;
; 429  :   int i = 0;
; 430  :   int err;
; 431  : 
; 432  :   err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  0000b	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	50		 push	 eax
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	e8 00 00 00 00	 call	 _zip64local_getByte
  0001d	8b c8		 mov	 ecx, eax

; 433  :   x = (ZPOS64_T)i;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00022	99		 cdq
  00023	83 c4 04	 add	 esp, 4
  00026	8b d8		 mov	 ebx, eax
  00028	89 55 f4	 mov	 DWORD PTR _x$[ebp+4], edx

; 434  : 
; 435  :   if (err==ZIP_OK)

  0002b	85 c9		 test	 ecx, ecx
  0002d	75 0e		 jne	 SHORT $LN9@zip64local@6

; 436  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  0002f	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _zip64local_getByte
  00038	83 c4 04	 add	 esp, 4
  0003b	8b c8		 mov	 ecx, eax
$LN9@zip64local@6:

; 437  :   x += ((ZPOS64_T)i)<<8;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00040	99		 cdq
  00041	0f a4 c2 08	 shld	 edx, eax, 8
  00045	c1 e0 08	 shl	 eax, 8
  00048	03 d8		 add	 ebx, eax
  0004a	11 55 f4	 adc	 DWORD PTR _x$[ebp+4], edx

; 438  : 
; 439  :   if (err==ZIP_OK)

  0004d	85 c9		 test	 ecx, ecx
  0004f	75 0e		 jne	 SHORT $LN8@zip64local@6

; 440  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00051	8d 55 fc	 lea	 edx, DWORD PTR _i$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _zip64local_getByte
  0005a	83 c4 04	 add	 esp, 4
  0005d	8b c8		 mov	 ecx, eax
$LN8@zip64local@6:

; 441  :   x += ((ZPOS64_T)i)<<16;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00062	99		 cdq
  00063	0f a4 c2 10	 shld	 edx, eax, 16
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	03 d8		 add	 ebx, eax
  0006c	11 55 f4	 adc	 DWORD PTR _x$[ebp+4], edx

; 442  : 
; 443  :   if (err==ZIP_OK)

  0006f	85 c9		 test	 ecx, ecx
  00071	75 0e		 jne	 SHORT $LN7@zip64local@6

; 444  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00073	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _zip64local_getByte
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b c8		 mov	 ecx, eax
$LN7@zip64local@6:

; 445  :   x += ((ZPOS64_T)i)<<24;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00084	99		 cdq
  00085	0f a4 c2 18	 shld	 edx, eax, 24
  00089	c1 e0 18	 shl	 eax, 24			; 00000018H
  0008c	03 d8		 add	 ebx, eax
  0008e	11 55 f4	 adc	 DWORD PTR _x$[ebp+4], edx

; 446  : 
; 447  :   if (err==ZIP_OK)

  00091	85 c9		 test	 ecx, ecx
  00093	75 0e		 jne	 SHORT $LN6@zip64local@6

; 448  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00095	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _zip64local_getByte
  0009e	83 c4 04	 add	 esp, 4
  000a1	8b c8		 mov	 ecx, eax
$LN6@zip64local@6:

; 449  :   x += ((ZPOS64_T)i)<<32;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a6	99		 cdq
  000a7	83 c3 00	 add	 ebx, 0
  000aa	11 45 f4	 adc	 DWORD PTR _x$[ebp+4], eax

; 450  : 
; 451  :   if (err==ZIP_OK)

  000ad	85 c9		 test	 ecx, ecx
  000af	75 0e		 jne	 SHORT $LN5@zip64local@6

; 452  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000b1	8d 55 fc	 lea	 edx, DWORD PTR _i$[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 _zip64local_getByte
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b c8		 mov	 ecx, eax
$LN5@zip64local@6:

; 453  :   x += ((ZPOS64_T)i)<<40;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c2	99		 cdq
  000c3	c1 e0 08	 shl	 eax, 8
  000c6	83 c3 00	 add	 ebx, 0
  000c9	11 45 f4	 adc	 DWORD PTR _x$[ebp+4], eax

; 454  : 
; 455  :   if (err==ZIP_OK)

  000cc	85 c9		 test	 ecx, ecx
  000ce	75 0e		 jne	 SHORT $LN4@zip64local@6

; 456  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000d0	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _zip64local_getByte
  000d9	83 c4 04	 add	 esp, 4
  000dc	8b c8		 mov	 ecx, eax
$LN4@zip64local@6:

; 457  :   x += ((ZPOS64_T)i)<<48;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e1	99		 cdq
  000e2	c1 e0 10	 shl	 eax, 16			; 00000010H
  000e5	83 c3 00	 add	 ebx, 0
  000e8	11 45 f4	 adc	 DWORD PTR _x$[ebp+4], eax

; 458  : 
; 459  :   if (err==ZIP_OK)

  000eb	85 c9		 test	 ecx, ecx
  000ed	75 33		 jne	 SHORT $LN2@zip64local@6

; 460  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000ef	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 _zip64local_getByte
  000f8	8b c8		 mov	 ecx, eax
  000fa	83 c4 04	 add	 esp, 4

; 461  :   x += ((ZPOS64_T)i)<<56;
; 462  : 
; 463  :   if (err==ZIP_OK)

  000fd	85 c9		 test	 ecx, ecx
  000ff	75 21		 jne	 SHORT $LN2@zip64local@6

; 464  :     *pX = x;

  00101	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00104	99		 cdq
  00105	8b d0		 mov	 edx, eax
  00107	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]
  0010a	33 f6		 xor	 esi, esi
  0010c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0010f	03 f3		 add	 esi, ebx
  00111	13 55 f4	 adc	 edx, DWORD PTR _x$[ebp+4]
  00114	89 30		 mov	 DWORD PTR [eax], esi
  00116	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 467  : 
; 468  :   return err;

  00119	8b c1		 mov	 eax, ecx

; 469  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN2@zip64local@6:

; 465  :   else
; 466  :     *pX = 0;

  00122	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]

; 469  : }

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0012d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00134	8b c1		 mov	 eax, ecx
  00136	5b		 pop	 ebx
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_zip64local_getLong64 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_getLong
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getLong PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = eax

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 397  :     uLong x ;
; 398  :     int i = 0;
; 399  :     int err;
; 400  : 
; 401  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00009	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	50		 push	 eax
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	e8 00 00 00 00	 call	 _zip64local_getByte

; 402  :     x = (uLong)i;

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001e	83 c4 04	 add	 esp, 4
  00021	8b d9		 mov	 ebx, ecx

; 403  : 
; 404  :     if (err==ZIP_OK)

  00023	85 c0		 test	 eax, eax
  00025	75 0f		 jne	 SHORT $LN5@zip64local@7

; 405  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00027	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _zip64local_getByte
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	83 c4 04	 add	 esp, 4
$LN5@zip64local@7:

; 406  :     x += ((uLong)i)<<8;

  00036	8b d1		 mov	 edx, ecx
  00038	c1 e2 08	 shl	 edx, 8
  0003b	03 da		 add	 ebx, edx

; 407  : 
; 408  :     if (err==ZIP_OK)

  0003d	85 c0		 test	 eax, eax
  0003f	75 0f		 jne	 SHORT $LN4@zip64local@7

; 409  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00041	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _zip64local_getByte
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0004d	83 c4 04	 add	 esp, 4
$LN4@zip64local@7:

; 410  :     x += ((uLong)i)<<16;

  00050	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00053	03 d9		 add	 ebx, ecx

; 411  : 
; 412  :     if (err==ZIP_OK)

  00055	85 c0		 test	 eax, eax
  00057	75 24		 jne	 SHORT $LN8@zip64local@7

; 413  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00059	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _zip64local_getByte
  00062	83 c4 04	 add	 esp, 4

; 414  :     x += ((uLong)i)<<24;
; 415  : 
; 416  :     if (err==ZIP_OK)

  00065	85 c0		 test	 eax, eax
  00067	75 14		 jne	 SHORT $LN8@zip64local@7

; 417  :         *pX = x;

  00069	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pX$[ebp]
  0006f	5f		 pop	 edi
  00070	c1 e2 18	 shl	 edx, 24			; 00000018H
  00073	03 d3		 add	 edx, ebx
  00075	5e		 pop	 esi
  00076	89 11		 mov	 DWORD PTR [ecx], edx
  00078	5b		 pop	 ebx

; 420  :     return err;
; 421  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN8@zip64local@7:

; 418  :     else
; 419  :         *pX = 0;

  0007d	8b 55 08	 mov	 edx, DWORD PTR _pX$[ebp]
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00088	5b		 pop	 ebx

; 420  :     return err;
; 421  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_zip64local_getLong ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _zip64local_getShort
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getShort PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = eax

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 375  :     uLong x ;
; 376  :     int i = 0;
; 377  :     int err;
; 378  : 
; 379  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00009	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	50		 push	 eax
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	e8 00 00 00 00	 call	 _zip64local_getByte

; 380  :     x = (uLong)i;

  0001b	8b 5d fc	 mov	 ebx, DWORD PTR _i$[ebp]
  0001e	83 c4 04	 add	 esp, 4

; 381  : 
; 382  :     if (err==ZIP_OK)

  00021	85 c0		 test	 eax, eax
  00023	75 24		 jne	 SHORT $LN6@zip64local@8

; 383  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00025	8d 4d fc	 lea	 ecx, DWORD PTR _i$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _zip64local_getByte
  0002e	83 c4 04	 add	 esp, 4

; 384  :     x += ((uLong)i)<<8;
; 385  : 
; 386  :     if (err==ZIP_OK)

  00031	85 c0		 test	 eax, eax
  00033	75 14		 jne	 SHORT $LN6@zip64local@8

; 387  :         *pX = x;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _pX$[ebp]
  0003b	5f		 pop	 edi
  0003c	c1 e2 08	 shl	 edx, 8
  0003f	03 d3		 add	 edx, ebx
  00041	5e		 pop	 esi
  00042	89 11		 mov	 DWORD PTR [ecx], edx
  00044	5b		 pop	 ebx

; 390  :     return err;
; 391  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN6@zip64local@8:

; 388  :     else
; 389  :         *pX = 0;

  00049	8b 55 08	 mov	 edx, DWORD PTR _pX$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00054	5b		 pop	 ebx

; 390  :     return err;
; 391  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_zip64local_getShort ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _add_data_in_datablock
_TEXT	SEGMENT
_from_copy$ = -4					; size = 4
_ll$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_add_data_in_datablock PROC				; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR _ll$[ebp]
  00008	57		 push	 edi
  00009	8b 7d 10	 mov	 edi, DWORD PTR _len$[ebp]

; 227  :     linkedlist_datablock_internal* ldi;
; 228  :     const unsigned char* from_copy;
; 229  : 
; 230  :     if (ll==NULL)

  0000c	85 db		 test	 ebx, ebx
  0000e	75 0b		 jne	 SHORT $LN12@add_data_i
$LN22@add_data_i:
  00010	5f		 pop	 edi

; 231  :         return ZIP_INTERNALERROR;

  00011	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  00016	5b		 pop	 ebx

; 274  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN12@add_data_i:

; 232  : 
; 233  :     if (ll->last_block == NULL)

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 0e		 jne	 SHORT $LN10@add_data_i

; 234  :     {
; 235  :         ll->first_block = ll->last_block = allocate_new_datablock();

  00021	e8 00 00 00 00	 call	 _allocate_new_datablock
  00026	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00029	89 03		 mov	 DWORD PTR [ebx], eax

; 236  :         if (ll->first_block == NULL)

  0002b	85 c0		 test	 eax, eax

; 237  :             return ZIP_INTERNALERROR;

  0002d	74 e1		 je	 SHORT $LN22@add_data_i
$LN10@add_data_i:

; 238  :     }
; 239  : 
; 240  :     ldi = ll->last_block;
; 241  :     from_copy = (unsigned char*)buf;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00032	56		 push	 esi
  00033	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00036	89 45 fc	 mov	 DWORD PTR _from_copy$[ebp], eax

; 242  : 
; 243  :     while (len>0)

  00039	85 ff		 test	 edi, edi
  0003b	74 53		 je	 SHORT $LN8@add_data_i
  0003d	8d 49 00	 npad	 3
$LL9@add_data_i:

; 244  :     {
; 245  :         uInt copy_this;
; 246  :         uInt i;
; 247  :         unsigned char* to_copy;
; 248  : 
; 249  :         if (ldi->avail_in_this_block==0)

  00040	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00044	75 10		 jne	 SHORT $LN7@add_data_i

; 250  :         {
; 251  :             ldi->next_datablock = allocate_new_datablock();

  00046	e8 00 00 00 00	 call	 _allocate_new_datablock
  0004b	89 06		 mov	 DWORD PTR [esi], eax

; 252  :             if (ldi->next_datablock == NULL)

  0004d	85 c0		 test	 eax, eax
  0004f	74 48		 je	 SHORT $LN17@add_data_i

; 254  :             ldi = ldi->next_datablock ;

  00051	8b f0		 mov	 esi, eax

; 255  :             ll->last_block = ldi;

  00053	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN7@add_data_i:

; 256  :         }
; 257  : 
; 258  :         if (ldi->avail_in_this_block < len)

  00056	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00059	3b cf		 cmp	 ecx, edi

; 259  :             copy_this = (uInt)ldi->avail_in_this_block;
; 260  :         else

  0005b	72 02		 jb	 SHORT $LN4@add_data_i

; 261  :             copy_this = (uInt)len;

  0005d	8b cf		 mov	 ecx, edi
$LN4@add_data_i:

; 262  : 
; 263  :         to_copy = &(ldi->data[ldi->filled_in_this_block]);

  0005f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00062	8d 44 32 10	 lea	 eax, DWORD PTR [edx+esi+16]

; 264  : 
; 265  :         for (i=0;i<copy_this;i++)

  00066	85 c9		 test	 ecx, ecx
  00068	74 16		 je	 SHORT $LN1@add_data_i
  0006a	8b 7d fc	 mov	 edi, DWORD PTR _from_copy$[ebp]
  0006d	2b f8		 sub	 edi, eax
  0006f	8b d1		 mov	 edx, ecx
$LL3@add_data_i:

; 266  :             *(to_copy+i)=*(from_copy+i);

  00071	8a 1c 07	 mov	 bl, BYTE PTR [edi+eax]
  00074	88 18		 mov	 BYTE PTR [eax], bl
  00076	40		 inc	 eax
  00077	4a		 dec	 edx
  00078	75 f7		 jne	 SHORT $LL3@add_data_i

; 264  : 
; 265  :         for (i=0;i<copy_this;i++)

  0007a	8b 5d 08	 mov	 ebx, DWORD PTR _ll$[ebp]
  0007d	8b 7d 10	 mov	 edi, DWORD PTR _len$[ebp]
$LN1@add_data_i:

; 267  : 
; 268  :         ldi->filled_in_this_block += copy_this;

  00080	01 4e 08	 add	 DWORD PTR [esi+8], ecx

; 269  :         ldi->avail_in_this_block -= copy_this;

  00083	29 4e 04	 sub	 DWORD PTR [esi+4], ecx

; 270  :         from_copy += copy_this ;

  00086	01 4d fc	 add	 DWORD PTR _from_copy$[ebp], ecx

; 271  :         len -= copy_this;

  00089	2b f9		 sub	 edi, ecx
  0008b	89 7d 10	 mov	 DWORD PTR _len$[ebp], edi
  0008e	75 b0		 jne	 SHORT $LL9@add_data_i
$LN8@add_data_i:
  00090	5e		 pop	 esi
  00091	5f		 pop	 edi

; 272  :     }
; 273  :     return ZIP_OK;

  00092	33 c0		 xor	 eax, eax
  00094	5b		 pop	 ebx

; 274  : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN17@add_data_i:
  00099	5e		 pop	 esi
  0009a	5f		 pop	 edi

; 253  :                 return ZIP_INTERNALERROR;

  0009b	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  000a0	5b		 pop	 ebx

; 274  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_add_data_in_datablock ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _free_linkedlist
_TEXT	SEGMENT
_free_linkedlist PROC					; COMDAT
; _ll$ = esi

; 220  :     free_datablock(ll->first_block);

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	e8 00 00 00 00	 call	 _free_datablock

; 221  :     ll->first_block = ll->last_block = NULL;

  00007	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 222  : }

  00014	c3		 ret	 0
_free_linkedlist ENDP
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\crypt.h
_TEXT	ENDS
;	COMDAT _init_keys
_TEXT	SEGMENT
_init_keys PROC						; COMDAT
; _passwd$ = edx
; _pkeys$ = ecx
; _pcrc_32_tab$ = eax

; 66   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi
  00005	8b da		 mov	 ebx, edx
  00007	8b f8		 mov	 edi, eax

; 67   :     *(pkeys+0) = 305419896L;

  00009	c7 06 78 56 34
	12		 mov	 DWORD PTR [esi], 305419896 ; 12345678H

; 68   :     *(pkeys+1) = 591751049L;

  0000f	c7 46 04 89 67
	45 23		 mov	 DWORD PTR [esi+4], 591751049 ; 23456789H

; 69   :     *(pkeys+2) = 878082192L;

  00016	c7 46 08 90 78
	56 34		 mov	 DWORD PTR [esi+8], 878082192 ; 34567890H

; 70   :     while (*passwd != '\0') {

  0001d	8a 03		 mov	 al, BYTE PTR [ebx]
  0001f	84 c0		 test	 al, al
  00021	74 10		 je	 SHORT $LN1@init_keys
$LL2@init_keys:

; 71   :         update_keys(pkeys,pcrc_32_tab,(int)*passwd);

  00023	0f be c0	 movsx	 eax, al
  00026	e8 00 00 00 00	 call	 _update_keys
  0002b	8a 43 01	 mov	 al, BYTE PTR [ebx+1]

; 72   :         passwd++;

  0002e	43		 inc	 ebx
  0002f	84 c0		 test	 al, al
  00031	75 f0		 jne	 SHORT $LL2@init_keys
$LN1@init_keys:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 73   :     }
; 74   : }

  00036	c3		 ret	 0
_init_keys ENDP
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\zip.c
;	COMDAT _zip64local_SearchCentralDir64
_TEXT	SEGMENT
_relativeOffset$ = -40					; size = 8
_uSizeFile$ = -40					; size = 8
_uPosFound$ = -32					; size = 8
_uBackRead$ = -24					; size = 8
_uMaxBack$ = -16					; size = 8
_uReadSize$82994 = -8					; size = 4
_uL$ = -4						; size = 4
_buf$ = -4						; size = 4
_pzlib_filefunc_def$ = 8				; size = 4
_filestream$ = 12					; size = 4
_zip64local_SearchCentralDir64 PROC			; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 544  :   unsigned char* buf;
; 545  :   ZPOS64_T uSizeFile;
; 546  :   ZPOS64_T uBackRead;
; 547  :   ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
; 548  :   ZPOS64_T uPosFound=0;
; 549  :   uLong uL;
; 550  :   ZPOS64_T relativeOffset;
; 551  : 
; 552  :   if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _filestream$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	57		 push	 edi
  00012	57		 push	 edi
  00013	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  00016	8b f3		 mov	 esi, ebx
  00018	c7 45 f0 ff ff
	00 00		 mov	 DWORD PTR _uMaxBack$[ebp], 65535 ; 0000ffffH
  0001f	89 7d f4	 mov	 DWORD PTR _uMaxBack$[ebp+4], edi
  00022	89 7d e0	 mov	 DWORD PTR _uPosFound$[ebp], edi
  00025	89 7d e4	 mov	 DWORD PTR _uPosFound$[ebp+4], edi
  00028	e8 00 00 00 00	 call	 _call_zseek64
  0002d	83 c4 08	 add	 esp, 8
  00030	85 c0		 test	 eax, eax
  00032	74 0b		 je	 SHORT $LN25@zip64local@9
$LN50@zip64local@9:

; 553  :     return 0;

  00034	33 c0		 xor	 eax, eax
  00036	33 d2		 xor	 edx, edx

; 638  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN25@zip64local@9:

; 554  : 
; 555  :   uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00042	8b cb		 mov	 ecx, ebx
  00044	e8 00 00 00 00	 call	 _call_ztell64
  00049	8b f0		 mov	 esi, eax
  0004b	89 75 d8	 mov	 DWORD PTR _uSizeFile$[ebp], esi
  0004e	89 55 dc	 mov	 DWORD PTR _uSizeFile$[ebp+4], edx

; 556  : 
; 557  :   if (uMaxBack>uSizeFile)

  00051	85 d2		 test	 edx, edx
  00053	77 12		 ja	 SHORT $LN24@zip64local@9
  00055	72 08		 jb	 SHORT $LN38@zip64local@9
  00057	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  0005d	73 08		 jae	 SHORT $LN24@zip64local@9
$LN38@zip64local@9:

; 558  :     uMaxBack = uSizeFile;

  0005f	89 75 f0	 mov	 DWORD PTR _uMaxBack$[ebp], esi
  00062	89 55 f4	 mov	 DWORD PTR _uMaxBack$[ebp+4], edx
  00065	8b fa		 mov	 edi, edx
$LN24@zip64local@9:

; 559  : 
; 560  :   buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);

  00067	68 04 04 00 00	 push	 1028			; 00000404H
  0006c	e8 00 00 00 00	 call	 _malloc
  00071	83 c4 04	 add	 esp, 4
  00074	89 45 fc	 mov	 DWORD PTR _buf$[ebp], eax

; 561  :   if (buf==NULL)

  00077	85 c0		 test	 eax, eax

; 562  :     return 0;

  00079	74 b9		 je	 SHORT $LN50@zip64local@9

; 563  : 
; 564  :   uBackRead = 4;

  0007b	33 c9		 xor	 ecx, ecx
  0007d	ba 04 00 00 00	 mov	 edx, 4

; 565  :   while (uBackRead<uMaxBack)

  00082	3b cf		 cmp	 ecx, edi
  00084	0f 87 07 01 00
	00		 ja	 $LN42@zip64local@9
  0008a	8b 45 f0	 mov	 eax, DWORD PTR _uMaxBack$[ebp]
  0008d	72 20		 jb	 SHORT $LN22@zip64local@9
  0008f	3b d0		 cmp	 edx, eax
  00091	0f 83 fa 00 00
	00		 jae	 $LN42@zip64local@9
  00097	eb 16		 jmp	 SHORT $LN22@zip64local@9
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL45@zip64local@9:
  000a0	8b 75 d8	 mov	 esi, DWORD PTR _uSizeFile$[ebp]
  000a3	8b 7d f4	 mov	 edi, DWORD PTR _uMaxBack$[ebp+4]
  000a6	8b 55 e8	 mov	 edx, DWORD PTR _uBackRead$[ebp]
  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _uBackRead$[ebp+4]
  000ac	8b 45 f0	 mov	 eax, DWORD PTR _uMaxBack$[ebp]
$LN22@zip64local@9:

; 566  :   {
; 567  :     uLong uReadSize;
; 568  :     ZPOS64_T uReadPos;
; 569  :     int i;
; 570  :     if (uBackRead+BUFREADCOMMENT>uMaxBack)

  000af	81 c2 00 04 00
	00		 add	 edx, 1024		; 00000400H
  000b5	83 d1 00	 adc	 ecx, 0
  000b8	3b cf		 cmp	 ecx, edi
  000ba	72 0e		 jb	 SHORT $LN20@zip64local@9
  000bc	77 04		 ja	 SHORT $LN40@zip64local@9
  000be	3b d0		 cmp	 edx, eax
  000c0	76 08		 jbe	 SHORT $LN20@zip64local@9
$LN40@zip64local@9:

; 571  :       uBackRead = uMaxBack;

  000c2	89 45 e8	 mov	 DWORD PTR _uBackRead$[ebp], eax
  000c5	89 7d ec	 mov	 DWORD PTR _uBackRead$[ebp+4], edi

; 572  :     else

  000c8	eb 06		 jmp	 SHORT $LN19@zip64local@9
$LN20@zip64local@9:

; 573  :       uBackRead+=BUFREADCOMMENT;

  000ca	89 55 e8	 mov	 DWORD PTR _uBackRead$[ebp], edx
  000cd	89 4d ec	 mov	 DWORD PTR _uBackRead$[ebp+4], ecx
$LN19@zip64local@9:

; 574  :     uReadPos = uSizeFile-uBackRead ;

  000d0	8b 5d dc	 mov	 ebx, DWORD PTR _uSizeFile$[ebp+4]

; 575  : 
; 576  :     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
; 577  :       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);

  000d3	8b 45 dc	 mov	 eax, DWORD PTR _uSizeFile$[ebp+4]
  000d6	8b fe		 mov	 edi, esi
  000d8	2b 7d e8	 sub	 edi, DWORD PTR _uBackRead$[ebp]
  000db	8b ce		 mov	 ecx, esi
  000dd	1b 5d ec	 sbb	 ebx, DWORD PTR _uBackRead$[ebp+4]
  000e0	2b cf		 sub	 ecx, edi
  000e2	1b c3		 sbb	 eax, ebx
  000e4	85 c0		 test	 eax, eax
  000e6	72 13		 jb	 SHORT $LN28@zip64local@9
  000e8	77 08		 ja	 SHORT $LN41@zip64local@9
  000ea	81 f9 04 04 00
	00		 cmp	 ecx, 1028		; 00000404H
  000f0	76 09		 jbe	 SHORT $LN28@zip64local@9
$LN41@zip64local@9:
  000f2	c7 45 f8 04 04
	00 00		 mov	 DWORD PTR _uReadSize$82994[ebp], 1028 ; 00000404H
  000f9	eb 05		 jmp	 SHORT $LN29@zip64local@9
$LN28@zip64local@9:
  000fb	2b f7		 sub	 esi, edi
  000fd	89 75 f8	 mov	 DWORD PTR _uReadSize$82994[ebp], esi
$LN29@zip64local@9:

; 578  :     if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  00100	8b 75 0c	 mov	 esi, DWORD PTR _filestream$[ebp]
  00103	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00106	53		 push	 ebx
  00107	57		 push	 edi
  00108	33 d2		 xor	 edx, edx
  0010a	e8 00 00 00 00	 call	 _call_zseek64
  0010f	83 c4 08	 add	 esp, 8
  00112	85 c0		 test	 eax, eax
  00114	75 78		 jne	 SHORT $LN46@zip64local@9

; 579  :       break;
; 580  : 
; 581  :     if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)

  00116	8b 75 f8	 mov	 esi, DWORD PTR _uReadSize$82994[ebp]
  00119	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]
  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _filestream$[ebp]
  0011f	56		 push	 esi
  00120	50		 push	 eax
  00121	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00124	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00127	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012a	51		 push	 ecx
  0012b	52		 push	 edx
  0012c	ff d0		 call	 eax
  0012e	83 c4 10	 add	 esp, 16			; 00000010H
  00131	3b c6		 cmp	 eax, esi
  00133	75 59		 jne	 SHORT $LN46@zip64local@9

; 582  :       break;
; 583  : 
; 584  :     for (i=(int)uReadSize-3; (i--)>0;)

  00135	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]
  00138	85 c0		 test	 eax, eax
  0013a	7e 38		 jle	 SHORT $LN37@zip64local@9
  0013c	8d 64 24 00	 npad	 4
$LL16@zip64local@9:

; 585  :     {
; 586  :       // Signature "0x07064b50" Zip64 end of central directory locater
; 587  :       if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))

  00140	8b 4d fc	 mov	 ecx, DWORD PTR _buf$[ebp]
  00143	48		 dec	 eax
  00144	80 3c 08 50	 cmp	 BYTE PTR [eax+ecx], 80	; 00000050H
  00148	75 15		 jne	 SHORT $LN14@zip64local@9
  0014a	80 7c 08 01 4b	 cmp	 BYTE PTR [eax+ecx+1], 75 ; 0000004bH
  0014f	75 0e		 jne	 SHORT $LN14@zip64local@9
  00151	80 7c 08 02 06	 cmp	 BYTE PTR [eax+ecx+2], 6
  00156	75 07		 jne	 SHORT $LN14@zip64local@9
  00158	80 7c 08 03 07	 cmp	 BYTE PTR [eax+ecx+3], 7
  0015d	74 06		 je	 SHORT $LN32@zip64local@9
$LN14@zip64local@9:

; 582  :       break;
; 583  : 
; 584  :     for (i=(int)uReadSize-3; (i--)>0;)

  0015f	85 c0		 test	 eax, eax
  00161	7f dd		 jg	 SHORT $LL16@zip64local@9

; 590  :         break;
; 591  :       }
; 592  :     }
; 593  : 
; 594  :       if (uPosFound!=0)

  00163	eb 0f		 jmp	 SHORT $LN37@zip64local@9
$LN32@zip64local@9:

; 588  :       {
; 589  :         uPosFound = uReadPos+i;

  00165	99		 cdq
  00166	03 c7		 add	 eax, edi
  00168	13 d3		 adc	 edx, ebx
  0016a	89 45 e0	 mov	 DWORD PTR _uPosFound$[ebp], eax

; 590  :         break;
; 591  :       }
; 592  :     }
; 593  : 
; 594  :       if (uPosFound!=0)

  0016d	0b c2		 or	 eax, edx
  0016f	89 55 e4	 mov	 DWORD PTR _uPosFound$[ebp+4], edx
  00172	75 1a		 jne	 SHORT $LN46@zip64local@9
$LN37@zip64local@9:

; 565  :   while (uBackRead<uMaxBack)

  00174	8b 4d f4	 mov	 ecx, DWORD PTR _uMaxBack$[ebp+4]
  00177	39 4d ec	 cmp	 DWORD PTR _uBackRead$[ebp+4], ecx
  0017a	0f 82 20 ff ff
	ff		 jb	 $LL45@zip64local@9
  00180	77 0c		 ja	 SHORT $LN46@zip64local@9
  00182	8b 55 f0	 mov	 edx, DWORD PTR _uMaxBack$[ebp]
  00185	39 55 e8	 cmp	 DWORD PTR _uBackRead$[ebp], edx
  00188	0f 82 12 ff ff
	ff		 jb	 $LL45@zip64local@9
$LN46@zip64local@9:
  0018e	8b 5d 0c	 mov	 ebx, DWORD PTR _filestream$[ebp]
$LN42@zip64local@9:

; 595  :         break;
; 596  :   }
; 597  : 
; 598  :   TRYFREE(buf);

  00191	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _free

; 599  :   if (uPosFound == 0)

  0019a	8b 45 e0	 mov	 eax, DWORD PTR _uPosFound$[ebp]
  0019d	8b 4d e4	 mov	 ecx, DWORD PTR _uPosFound$[ebp+4]
  001a0	8b d0		 mov	 edx, eax
  001a2	83 c4 04	 add	 esp, 4
  001a5	0b d1		 or	 edx, ecx

; 600  :     return 0;

  001a7	0f 84 87 fe ff
	ff		 je	 $LN50@zip64local@9

; 601  : 
; 602  :   /* Zip64 end of central directory locator */
; 603  :   if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)

  001ad	8b 7d 08	 mov	 edi, DWORD PTR _pzlib_filefunc_def$[ebp]
  001b0	51		 push	 ecx
  001b1	50		 push	 eax
  001b2	33 d2		 xor	 edx, edx
  001b4	8b f3		 mov	 esi, ebx
  001b6	8b c7		 mov	 eax, edi
  001b8	e8 00 00 00 00	 call	 _call_zseek64
  001bd	83 c4 08	 add	 esp, 8
  001c0	85 c0		 test	 eax, eax

; 604  :     return 0;

  001c2	0f 85 6c fe ff
	ff		 jne	 $LN50@zip64local@9

; 605  : 
; 606  :   /* the signature, already checked */
; 607  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  001c8	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  001cb	50		 push	 eax
  001cc	8b c3		 mov	 eax, ebx
  001ce	8b cf		 mov	 ecx, edi
  001d0	e8 00 00 00 00	 call	 _zip64local_getLong
  001d5	83 c4 04	 add	 esp, 4
  001d8	85 c0		 test	 eax, eax

; 608  :     return 0;

  001da	0f 85 54 fe ff
	ff		 jne	 $LN50@zip64local@9

; 609  : 
; 610  :   /* number of the disk with the start of the zip64 end of  central directory */
; 611  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  001e0	8d 4d fc	 lea	 ecx, DWORD PTR _uL$[ebp]
  001e3	51		 push	 ecx
  001e4	8b c3		 mov	 eax, ebx
  001e6	8b cf		 mov	 ecx, edi
  001e8	e8 00 00 00 00	 call	 _zip64local_getLong
  001ed	83 c4 04	 add	 esp, 4
  001f0	85 c0		 test	 eax, eax

; 612  :     return 0;

  001f2	0f 85 3c fe ff
	ff		 jne	 $LN50@zip64local@9

; 613  :   if (uL != 0)

  001f8	39 45 fc	 cmp	 DWORD PTR _uL$[ebp], eax

; 614  :     return 0;

  001fb	0f 85 33 fe ff
	ff		 jne	 $LN50@zip64local@9

; 615  : 
; 616  :   /* relative offset of the zip64 end of central directory record */
; 617  :   if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)

  00201	8d 55 d8	 lea	 edx, DWORD PTR _relativeOffset$[ebp]
  00204	52		 push	 edx
  00205	8b c3		 mov	 eax, ebx
  00207	8b cf		 mov	 ecx, edi
  00209	e8 00 00 00 00	 call	 _zip64local_getLong64
  0020e	83 c4 04	 add	 esp, 4
  00211	85 c0		 test	 eax, eax

; 618  :     return 0;

  00213	0f 85 1b fe ff
	ff		 jne	 $LN50@zip64local@9

; 619  : 
; 620  :   /* total number of disks */
; 621  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  00219	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  0021c	50		 push	 eax
  0021d	8b c3		 mov	 eax, ebx
  0021f	8b cf		 mov	 ecx, edi
  00221	e8 00 00 00 00	 call	 _zip64local_getLong
  00226	83 c4 04	 add	 esp, 4
  00229	85 c0		 test	 eax, eax

; 622  :     return 0;

  0022b	0f 85 03 fe ff
	ff		 jne	 $LN50@zip64local@9

; 623  :   if (uL != 1)

  00231	83 7d fc 01	 cmp	 DWORD PTR _uL$[ebp], 1

; 624  :     return 0;

  00235	0f 85 f9 fd ff
	ff		 jne	 $LN50@zip64local@9

; 625  : 
; 626  :   /* Goto Zip64 end of central directory record */
; 627  :   if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0023b	8b 4d dc	 mov	 ecx, DWORD PTR _relativeOffset$[ebp+4]
  0023e	8b 55 d8	 mov	 edx, DWORD PTR _relativeOffset$[ebp]
  00241	51		 push	 ecx
  00242	52		 push	 edx
  00243	33 d2		 xor	 edx, edx
  00245	8b c7		 mov	 eax, edi
  00247	e8 00 00 00 00	 call	 _call_zseek64
  0024c	83 c4 08	 add	 esp, 8
  0024f	85 c0		 test	 eax, eax

; 628  :     return 0;

  00251	0f 85 dd fd ff
	ff		 jne	 $LN50@zip64local@9

; 629  : 
; 630  :   /* the signature */
; 631  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  00257	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  0025a	50		 push	 eax
  0025b	8b c3		 mov	 eax, ebx
  0025d	8b cf		 mov	 ecx, edi
  0025f	e8 00 00 00 00	 call	 _zip64local_getLong
  00264	83 c4 04	 add	 esp, 4
  00267	85 c0		 test	 eax, eax

; 632  :     return 0;

  00269	0f 85 c5 fd ff
	ff		 jne	 $LN50@zip64local@9

; 633  : 
; 634  :   if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'

  0026f	81 7d fc 50 4b
	06 06		 cmp	 DWORD PTR _uL$[ebp], 101075792 ; 06064b50H

; 635  :     return 0;

  00276	0f 85 b8 fd ff
	ff		 jne	 $LN50@zip64local@9

; 636  : 
; 637  :   return relativeOffset;

  0027c	8b 45 d8	 mov	 eax, DWORD PTR _relativeOffset$[ebp]
  0027f	8b 55 dc	 mov	 edx, DWORD PTR _relativeOffset$[ebp+4]

; 638  : }

  00282	5f		 pop	 edi
  00283	5e		 pop	 esi
  00284	5b		 pop	 ebx
  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c3		 ret	 0
_zip64local_SearchCentralDir64 ENDP
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\crypt.h
_TEXT	ENDS
;	COMDAT _crypthead
_TEXT	SEGMENT
_header$ = -24						; size = 10
tv280 = -12						; size = 4
tv243 = -12						; size = 4
_n$ = -12						; size = 4
_t$ = -8						; size = 4
tv238 = -1						; size = 1
_passwd$ = 8						; size = 4
_buf$ = 12						; size = 4
_crcForCrypting$ = 16					; size = 4
_crypthead PROC						; COMDAT
; _pkeys$ = ecx
; _pcrc_32_tab$ = eax

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax

; 97   :     int n;                       /* index in random header */
; 98   :     int t;                       /* temporary */
; 99   :     int c;                       /* random byte */
; 100  :     unsigned char header[RAND_HEAD_LEN-2]; /* random header */
; 101  :     static unsigned calls = 0;   /* ensure different random header each time */
; 102  : 
; 103  :     if (bufSize<RAND_HEAD_LEN)
; 104  :       return 0;
; 105  : 
; 106  :     /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
; 107  :      * output of rand() to get less predictability, since rand() is
; 108  :      * often poorly implemented.
; 109  :      */
; 110  :     if (++calls == 1)

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?calls@?1??crypthead@@9@9
  00010	40		 inc	 eax
  00011	8b f1		 mov	 esi, ecx
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?calls@?1??crypthead@@9@9, eax
  00018	83 f8 01	 cmp	 eax, 1
  0001b	75 15		 jne	 SHORT $LN17@crypthead

; 111  :     {
; 112  :         srand((unsigned)(time(NULL) ^ ZCR_SEED2));

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 __time64
  00024	35 4e e6 40 bb	 xor	 eax, -1153374642	; bb40e64eH
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _srand
  0002f	83 c4 08	 add	 esp, 8
$LN17@crypthead:

; 113  :     }
; 114  :     init_keys(passwd, pkeys, pcrc_32_tab);

  00032	8b 55 08	 mov	 edx, DWORD PTR _passwd$[ebp]
  00035	8b c7		 mov	 eax, edi
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 _init_keys

; 115  :     for (n = 0; n < RAND_HEAD_LEN-2; n++)

  0003e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LL6@crypthead:

; 116  :     {
; 117  :         c = (rand() >> 7) & 0xff;

  00045	e8 00 00 00 00	 call	 _rand
  0004a	8b d8		 mov	 ebx, eax
  0004c	c1 fb 07	 sar	 ebx, 7

; 118  :         header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);

  0004f	8b c6		 mov	 eax, esi
  00051	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  00057	e8 00 00 00 00	 call	 _decrypt_byte
  0005c	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  0005f	8b c3		 mov	 eax, ebx
  00061	e8 00 00 00 00	 call	 _update_keys
  00066	32 5d f8	 xor	 bl, BYTE PTR _t$[ebp]
  00069	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0006c	88 5c 05 e8	 mov	 BYTE PTR _header$[ebp+eax], bl
  00070	40		 inc	 eax
  00071	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00074	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00077	7c cc		 jl	 SHORT $LL6@crypthead

; 119  :     }
; 120  :     /* Encrypt random header (last two bytes is high word of crc) */
; 121  :     init_keys(passwd, pkeys, pcrc_32_tab);

  00079	8b 55 08	 mov	 edx, DWORD PTR _passwd$[ebp]
  0007c	8b c7		 mov	 eax, edi
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 _init_keys

; 122  :     for (n = 0; n < RAND_HEAD_LEN-2; n++)

  00085	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00088	8d 4d e8	 lea	 ecx, DWORD PTR _header$[ebp]
  0008b	33 db		 xor	 ebx, ebx
  0008d	2b c1		 sub	 eax, ecx
  0008f	89 45 f4	 mov	 DWORD PTR tv280[ebp], eax
$LL3@crypthead:

; 123  :     {
; 124  :         buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);

  00092	8b c6		 mov	 eax, esi
  00094	e8 00 00 00 00	 call	 _decrypt_byte
  00099	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  0009c	0f b6 44 1d e8	 movzx	 eax, BYTE PTR _header$[ebp+ebx]
  000a1	e8 00 00 00 00	 call	 _update_keys
  000a6	8a 44 1d e8	 mov	 al, BYTE PTR _header$[ebp+ebx]
  000aa	8b 55 f4	 mov	 edx, DWORD PTR tv280[ebp]
  000ad	32 45 f8	 xor	 al, BYTE PTR _t$[ebp]
  000b0	03 d3		 add	 edx, ebx
  000b2	43		 inc	 ebx
  000b3	88 44 15 e8	 mov	 BYTE PTR _header$[ebp+edx], al
  000b7	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  000ba	7c d6		 jl	 SHORT $LL3@crypthead

; 125  :     }
; 126  :     buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);

  000bc	8b c6		 mov	 eax, esi
  000be	e8 00 00 00 00	 call	 _decrypt_byte
  000c3	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  000c6	8b 45 10	 mov	 eax, DWORD PTR _crcForCrypting$[ebp]
  000c9	c1 e8 10	 shr	 eax, 16			; 00000010H
  000cc	89 45 f4	 mov	 DWORD PTR tv243[ebp], eax
  000cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d4	e8 00 00 00 00	 call	 _update_keys
  000d9	8a 45 f4	 mov	 al, BYTE PTR tv243[ebp]
  000dc	32 45 f8	 xor	 al, BYTE PTR _t$[ebp]
  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000e2	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 127  :     buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);

  000e5	8b c6		 mov	 eax, esi
  000e7	e8 00 00 00 00	 call	 _decrypt_byte
  000ec	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax
  000ef	8b 45 10	 mov	 eax, DWORD PTR _crcForCrypting$[ebp]
  000f2	c1 e8 18	 shr	 eax, 24			; 00000018H
  000f5	e8 00 00 00 00	 call	 _update_keys
  000fa	32 45 f8	 xor	 al, BYTE PTR _t$[ebp]
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00100	5f		 pop	 edi
  00101	88 44 13 01	 mov	 BYTE PTR [ebx+edx+1], al
  00105	5e		 pop	 esi
  00106	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00109	5b		 pop	 ebx

; 128  :     return n;
; 129  : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_crypthead ENDP
PUBLIC	_LoadCentralDirectoryRecord
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\contrib\minizip\zip.c
;	COMDAT _LoadCentralDirectoryRecord
_TEXT	SEGMENT
tv439 = -56						; size = 8
_offset_central_dir$ = -56				; size = 8
_number_entry$ = -56					; size = 8
_sizeEndOfCentralDirectory$83042 = -56			; size = 8
_number_entry_CD$ = -48					; size = 8
_size_central_dir_to_read$83077 = -40			; size = 8
_central_pos$ = -40					; size = 8
_buf_read$83079 = -28					; size = 4
_size_comment$ = -28					; size = 4
_number_disk$ = -28					; size = 4
_VersionNeeded$ = -28					; size = 4
_VersionMadeBy$ = -28					; size = 4
_read_this$83085 = -24					; size = 8
_size_central_dir$ = -24				; size = 8
_number_disk_with_CD$ = -20				; size = 4
_byte_before_the_zipfile$ = -16				; size = 8
_uL$ = -12						; size = 4
_err$ = -4						; size = 4
_LoadCentralDirectoryRecord PROC			; COMDAT
; _pziinit$ = edi

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 642  :   int err=ZIP_OK;
; 643  :   ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
; 644  : 
; 645  :   ZPOS64_T size_central_dir;     /* size of the central directory  */
; 646  :   ZPOS64_T offset_central_dir;   /* offset of start of central directory */
; 647  :   ZPOS64_T central_pos;
; 648  :   uLong uL;
; 649  : 
; 650  :   uLong number_disk;          /* number of the current dist, used for
; 651  :                               spaning ZIP, unsupported, always 0*/
; 652  :   uLong number_disk_with_CD;  /* number the the disk with central dir, used
; 653  :                               for spaning ZIP, unsupported, always 0*/
; 654  :   ZPOS64_T number_entry;
; 655  :   ZPOS64_T number_entry_CD;      /* total number of entries in
; 656  :                                 the central dir
; 657  :                                 (same than number_entry on nospan) */
; 658  :   uLong VersionMadeBy;
; 659  :   uLong VersionNeeded;
; 660  :   uLong size_comment;
; 661  : 
; 662  :   int hasZIP64Record = 0;
; 663  : 
; 664  :   // check first if we find a ZIP64 record
; 665  :   central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);

  00006	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	50		 push	 eax
  0000c	33 db		 xor	 ebx, ebx
  0000e	57		 push	 edi
  0000f	89 5d fc	 mov	 DWORD PTR _err$[ebp], ebx
  00012	e8 00 00 00 00	 call	 _zip64local_SearchCentralDir64
  00017	83 c4 08	 add	 esp, 8
  0001a	89 45 d8	 mov	 DWORD PTR _central_pos$[ebp], eax
  0001d	89 55 dc	 mov	 DWORD PTR _central_pos$[ebp+4], edx

; 666  :   if(central_pos > 0)

  00020	3b d3		 cmp	 edx, ebx
  00022	0f 87 ad 00 00
	00		 ja	 $LN51@LoadCentra
  00028	72 08		 jb	 SHORT $LN53@LoadCentra
  0002a	3b c3		 cmp	 eax, ebx

; 667  :   {
; 668  :     hasZIP64Record = 1;

  0002c	0f 87 a3 00 00
	00		 ja	 $LN51@LoadCentra
$LN53@LoadCentra:

; 669  :   }
; 670  :   else if(central_pos == 0)

  00032	8b c8		 mov	 ecx, eax
  00034	0b ca		 or	 ecx, edx
  00036	75 13		 jne	 SHORT $LN42@LoadCentra

; 671  :   {
; 672  :     central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);

  00038	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0003b	52		 push	 edx
  0003c	57		 push	 edi
  0003d	e8 00 00 00 00	 call	 _zip64local_SearchCentralDir
  00042	83 c4 08	 add	 esp, 8
  00045	89 45 d8	 mov	 DWORD PTR _central_pos$[ebp], eax
  00048	89 55 dc	 mov	 DWORD PTR _central_pos$[ebp+4], edx
$LN42@LoadCentra:

; 735  :   {
; 736  :     // Read End of central Directory info
; 737  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0004b	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0004e	52		 push	 edx
  0004f	50		 push	 eax
  00050	33 d2		 xor	 edx, edx
  00052	8b c7		 mov	 eax, edi
  00054	e8 00 00 00 00	 call	 _call_zseek64
  00059	83 c4 08	 add	 esp, 8

; 738  :       err=ZIP_ERRNO;

  0005c	83 ce ff	 or	 esi, -1
  0005f	85 c0		 test	 eax, eax
  00061	74 03		 je	 SHORT $LN27@LoadCentra
  00063	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN27@LoadCentra:

; 739  : 
; 740  :     /* the signature, already checked */
; 741  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)

  00066	8d 45 f4	 lea	 eax, DWORD PTR _uL$[ebp]
  00069	50		 push	 eax
  0006a	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0006d	8b cf		 mov	 ecx, edi
  0006f	e8 00 00 00 00	 call	 _zip64local_getLong
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	74 03		 je	 SHORT $LN26@LoadCentra

; 742  :       err=ZIP_ERRNO;

  0007b	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN26@LoadCentra:

; 743  : 
; 744  :     /* number of this disk */
; 745  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)

  0007e	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00081	8d 4d e4	 lea	 ecx, DWORD PTR _number_disk$[ebp]
  00084	51		 push	 ecx
  00085	8b cf		 mov	 ecx, edi
  00087	e8 00 00 00 00	 call	 _zip64local_getShort
  0008c	83 c4 04	 add	 esp, 4
  0008f	85 c0		 test	 eax, eax
  00091	74 03		 je	 SHORT $LN25@LoadCentra

; 746  :       err=ZIP_ERRNO;

  00093	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN25@LoadCentra:

; 747  : 
; 748  :     /* number of the disk with the start of the central directory */
; 749  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)

  00096	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00099	8d 55 ec	 lea	 edx, DWORD PTR _number_disk_with_CD$[ebp]
  0009c	52		 push	 edx
  0009d	8b cf		 mov	 ecx, edi
  0009f	e8 00 00 00 00	 call	 _zip64local_getShort
  000a4	83 c4 04	 add	 esp, 4
  000a7	85 c0		 test	 eax, eax
  000a9	74 03		 je	 SHORT $LN24@LoadCentra

; 750  :       err=ZIP_ERRNO;

  000ab	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN24@LoadCentra:

; 751  : 
; 752  :     /* total number of entries in the central dir on this disk */
; 753  :     number_entry = 0;
; 754  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  000ae	8d 45 f4	 lea	 eax, DWORD PTR _uL$[ebp]
  000b1	50		 push	 eax
  000b2	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000b5	8b cf		 mov	 ecx, edi
  000b7	33 f6		 xor	 esi, esi
  000b9	e8 00 00 00 00	 call	 _zip64local_getShort
  000be	83 c4 04	 add	 esp, 4
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 46 01 00
	00		 je	 $LN23@LoadCentra

; 755  :       err=ZIP_ERRNO;

  000c9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 756  :     else

  000d0	e9 3f 01 00 00	 jmp	 $LN22@LoadCentra
$LN51@LoadCentra:

; 673  :   }
; 674  : 
; 675  : /* disable to allow appending to empty ZIP archive
; 676  :         if (central_pos==0)
; 677  :             err=ZIP_ERRNO;
; 678  : */
; 679  : 
; 680  :   if(hasZIP64Record)
; 681  :   {
; 682  :     ZPOS64_T sizeEndOfCentralDirectory;
; 683  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)

  000d5	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  000d8	52		 push	 edx
  000d9	50		 push	 eax
  000da	33 d2		 xor	 edx, edx
  000dc	8b c7		 mov	 eax, edi
  000de	e8 00 00 00 00	 call	 _call_zseek64
  000e3	83 c4 08	 add	 esp, 8

; 684  :       err=ZIP_ERRNO;

  000e6	83 ce ff	 or	 esi, -1
  000e9	85 c0		 test	 eax, eax
  000eb	74 03		 je	 SHORT $LN41@LoadCentra
  000ed	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN41@LoadCentra:

; 685  : 
; 686  :     /* the signature, already checked */
; 687  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)

  000f0	8d 45 f4	 lea	 eax, DWORD PTR _uL$[ebp]
  000f3	50		 push	 eax
  000f4	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000f7	8b cf		 mov	 ecx, edi
  000f9	e8 00 00 00 00	 call	 _zip64local_getLong
  000fe	83 c4 04	 add	 esp, 4
  00101	85 c0		 test	 eax, eax
  00103	74 03		 je	 SHORT $LN40@LoadCentra

; 688  :       err=ZIP_ERRNO;

  00105	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN40@LoadCentra:

; 689  : 
; 690  :     /* size of zip64 end of central directory record */
; 691  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)

  00108	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0010b	8d 4d c8	 lea	 ecx, DWORD PTR _sizeEndOfCentralDirectory$83042[ebp]
  0010e	51		 push	 ecx
  0010f	8b cf		 mov	 ecx, edi
  00111	e8 00 00 00 00	 call	 _zip64local_getLong64
  00116	83 c4 04	 add	 esp, 4
  00119	85 c0		 test	 eax, eax
  0011b	74 03		 je	 SHORT $LN39@LoadCentra

; 692  :       err=ZIP_ERRNO;

  0011d	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN39@LoadCentra:

; 693  : 
; 694  :     /* version made by */
; 695  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)

  00120	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00123	8d 55 e4	 lea	 edx, DWORD PTR _VersionMadeBy$[ebp]
  00126	52		 push	 edx
  00127	8b cf		 mov	 ecx, edi
  00129	e8 00 00 00 00	 call	 _zip64local_getShort
  0012e	83 c4 04	 add	 esp, 4
  00131	85 c0		 test	 eax, eax
  00133	74 03		 je	 SHORT $LN38@LoadCentra

; 696  :       err=ZIP_ERRNO;

  00135	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN38@LoadCentra:

; 697  : 
; 698  :     /* version needed to extract */
; 699  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)

  00138	8d 45 e4	 lea	 eax, DWORD PTR _VersionNeeded$[ebp]
  0013b	50		 push	 eax
  0013c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0013f	8b cf		 mov	 ecx, edi
  00141	e8 00 00 00 00	 call	 _zip64local_getShort
  00146	83 c4 04	 add	 esp, 4
  00149	85 c0		 test	 eax, eax
  0014b	74 03		 je	 SHORT $LN37@LoadCentra

; 700  :       err=ZIP_ERRNO;

  0014d	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN37@LoadCentra:

; 701  : 
; 702  :     /* number of this disk */
; 703  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)

  00150	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00153	8d 4d e4	 lea	 ecx, DWORD PTR _number_disk$[ebp]
  00156	51		 push	 ecx
  00157	8b cf		 mov	 ecx, edi
  00159	e8 00 00 00 00	 call	 _zip64local_getLong
  0015e	83 c4 04	 add	 esp, 4
  00161	85 c0		 test	 eax, eax
  00163	74 03		 je	 SHORT $LN36@LoadCentra

; 704  :       err=ZIP_ERRNO;

  00165	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN36@LoadCentra:

; 705  : 
; 706  :     /* number of the disk with the start of the central directory */
; 707  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)

  00168	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0016b	8d 55 ec	 lea	 edx, DWORD PTR _number_disk_with_CD$[ebp]
  0016e	52		 push	 edx
  0016f	8b cf		 mov	 ecx, edi
  00171	e8 00 00 00 00	 call	 _zip64local_getLong
  00176	83 c4 04	 add	 esp, 4
  00179	85 c0		 test	 eax, eax
  0017b	74 03		 je	 SHORT $LN35@LoadCentra

; 708  :       err=ZIP_ERRNO;

  0017d	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN35@LoadCentra:

; 709  : 
; 710  :     /* total number of entries in the central directory on this disk */
; 711  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)

  00180	8d 45 c8	 lea	 eax, DWORD PTR _number_entry$[ebp]
  00183	50		 push	 eax
  00184	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00187	8b cf		 mov	 ecx, edi
  00189	e8 00 00 00 00	 call	 _zip64local_getLong64
  0018e	83 c4 04	 add	 esp, 4
  00191	85 c0		 test	 eax, eax
  00193	74 03		 je	 SHORT $LN34@LoadCentra

; 712  :       err=ZIP_ERRNO;

  00195	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN34@LoadCentra:

; 713  : 
; 714  :     /* total number of entries in the central directory */
; 715  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)

  00198	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0019b	8d 4d d0	 lea	 ecx, DWORD PTR _number_entry_CD$[ebp]
  0019e	51		 push	 ecx
  0019f	8b cf		 mov	 ecx, edi
  001a1	e8 00 00 00 00	 call	 _zip64local_getLong64
  001a6	83 c4 04	 add	 esp, 4
  001a9	85 c0		 test	 eax, eax
  001ab	74 03		 je	 SHORT $LN33@LoadCentra

; 716  :       err=ZIP_ERRNO;

  001ad	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN33@LoadCentra:

; 717  : 
; 718  :     if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))

  001b0	8b 55 d0	 mov	 edx, DWORD PTR _number_entry_CD$[ebp]
  001b3	3b 55 c8	 cmp	 edx, DWORD PTR _number_entry$[ebp]
  001b6	75 12		 jne	 SHORT $LN31@LoadCentra
  001b8	8b 45 d4	 mov	 eax, DWORD PTR _number_entry_CD$[ebp+4]
  001bb	3b 45 cc	 cmp	 eax, DWORD PTR _number_entry$[ebp+4]
  001be	75 0a		 jne	 SHORT $LN31@LoadCentra
  001c0	39 5d ec	 cmp	 DWORD PTR _number_disk_with_CD$[ebp], ebx
  001c3	75 05		 jne	 SHORT $LN31@LoadCentra
  001c5	39 5d e4	 cmp	 DWORD PTR _number_disk$[ebp], ebx
  001c8	74 07		 je	 SHORT $LN32@LoadCentra
$LN31@LoadCentra:

; 719  :       err=ZIP_BADZIPFILE;

  001ca	c7 45 fc 99 ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -103 ; ffffff99H
$LN32@LoadCentra:

; 720  : 
; 721  :     /* size of the central directory */
; 722  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)

  001d1	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001d4	8d 4d e8	 lea	 ecx, DWORD PTR _size_central_dir$[ebp]
  001d7	51		 push	 ecx
  001d8	8b cf		 mov	 ecx, edi
  001da	e8 00 00 00 00	 call	 _zip64local_getLong64
  001df	83 c4 04	 add	 esp, 4
  001e2	85 c0		 test	 eax, eax
  001e4	74 03		 je	 SHORT $LN30@LoadCentra

; 723  :       err=ZIP_ERRNO;

  001e6	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN30@LoadCentra:

; 724  : 
; 725  :     /* offset of start of central directory with respect to the
; 726  :     starting disk number */
; 727  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)

  001e9	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001ec	8d 55 c8	 lea	 edx, DWORD PTR _offset_central_dir$[ebp]
  001ef	52		 push	 edx
  001f0	8b cf		 mov	 ecx, edi
  001f2	e8 00 00 00 00	 call	 _zip64local_getLong64
  001f7	83 c4 04	 add	 esp, 4
  001fa	85 c0		 test	 eax, eax
  001fc	74 03		 je	 SHORT $LN29@LoadCentra

; 728  :       err=ZIP_ERRNO;

  001fe	89 75 fc	 mov	 DWORD PTR _err$[ebp], esi
$LN29@LoadCentra:

; 729  : 
; 730  :     // TODO..
; 731  :     // read the comment from the standard central header.
; 732  :     size_comment = 0;
; 733  :   }
; 734  :   else

  00201	8b 75 c8	 mov	 esi, DWORD PTR _offset_central_dir$[ebp]
  00204	89 5d e4	 mov	 DWORD PTR _size_comment$[ebp], ebx
  00207	8b 5d cc	 mov	 ebx, DWORD PTR _offset_central_dir$[ebp+4]
  0020a	e9 c7 00 00 00	 jmp	 $LN13@LoadCentra
$LN23@LoadCentra:

; 757  :       number_entry = uL;

  0020f	8b 75 f4	 mov	 esi, DWORD PTR _uL$[ebp]
  00212	33 db		 xor	 ebx, ebx
$LN22@LoadCentra:

; 758  : 
; 759  :     /* total number of entries in the central dir */
; 760  :     number_entry_CD = 0;

  00214	33 c0		 xor	 eax, eax

; 761  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00216	8d 4d f4	 lea	 ecx, DWORD PTR _uL$[ebp]
  00219	89 45 d0	 mov	 DWORD PTR _number_entry_CD$[ebp], eax
  0021c	89 45 d4	 mov	 DWORD PTR _number_entry_CD$[ebp+4], eax
  0021f	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00222	51		 push	 ecx
  00223	8b cf		 mov	 ecx, edi
  00225	e8 00 00 00 00	 call	 _zip64local_getShort
  0022a	83 c4 04	 add	 esp, 4
  0022d	85 c0		 test	 eax, eax
  0022f	74 0b		 je	 SHORT $LN21@LoadCentra

; 762  :       err=ZIP_ERRNO;

  00231	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 763  :     else

  00238	33 c0		 xor	 eax, eax
  0023a	eb 0b		 jmp	 SHORT $LN20@LoadCentra
$LN21@LoadCentra:

; 764  :       number_entry_CD = uL;

  0023c	8b 55 f4	 mov	 edx, DWORD PTR _uL$[ebp]
  0023f	33 c0		 xor	 eax, eax
  00241	89 55 d0	 mov	 DWORD PTR _number_entry_CD$[ebp], edx
  00244	89 45 d4	 mov	 DWORD PTR _number_entry_CD$[ebp+4], eax
$LN20@LoadCentra:

; 765  : 
; 766  :     if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))

  00247	39 75 d0	 cmp	 DWORD PTR _number_entry_CD$[ebp], esi
  0024a	75 0f		 jne	 SHORT $LN18@LoadCentra
  0024c	39 5d d4	 cmp	 DWORD PTR _number_entry_CD$[ebp+4], ebx
  0024f	75 0a		 jne	 SHORT $LN18@LoadCentra
  00251	39 45 ec	 cmp	 DWORD PTR _number_disk_with_CD$[ebp], eax
  00254	75 05		 jne	 SHORT $LN18@LoadCentra
  00256	39 45 e4	 cmp	 DWORD PTR _number_disk$[ebp], eax
  00259	74 07		 je	 SHORT $LN19@LoadCentra
$LN18@LoadCentra:

; 767  :       err=ZIP_BADZIPFILE;

  0025b	c7 45 fc 99 ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -103 ; ffffff99H
$LN19@LoadCentra:

; 768  : 
; 769  :     /* size of the central directory */
; 770  :     size_central_dir = 0;

  00262	89 45 e8	 mov	 DWORD PTR _size_central_dir$[ebp], eax
  00265	89 45 ec	 mov	 DWORD PTR _size_central_dir$[ebp+4], eax

; 771  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00268	8d 45 f4	 lea	 eax, DWORD PTR _uL$[ebp]
  0026b	50		 push	 eax
  0026c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0026f	8b cf		 mov	 ecx, edi
  00271	e8 00 00 00 00	 call	 _zip64local_getLong
  00276	83 c4 04	 add	 esp, 4
  00279	85 c0		 test	 eax, eax
  0027b	74 09		 je	 SHORT $LN17@LoadCentra

; 772  :       err=ZIP_ERRNO;

  0027d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 773  :     else

  00284	eb 0d		 jmp	 SHORT $LN16@LoadCentra
$LN17@LoadCentra:

; 774  :       size_central_dir = uL;

  00286	8b 4d f4	 mov	 ecx, DWORD PTR _uL$[ebp]
  00289	89 4d e8	 mov	 DWORD PTR _size_central_dir$[ebp], ecx
  0028c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _size_central_dir$[ebp+4], 0
$LN16@LoadCentra:

; 775  : 
; 776  :     /* offset of start of central directory with respect to the starting disk number */
; 777  :     offset_central_dir = 0;
; 778  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00293	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00296	8d 55 f4	 lea	 edx, DWORD PTR _uL$[ebp]
  00299	52		 push	 edx
  0029a	8b cf		 mov	 ecx, edi
  0029c	33 f6		 xor	 esi, esi
  0029e	33 db		 xor	 ebx, ebx
  002a0	e8 00 00 00 00	 call	 _zip64local_getLong
  002a5	83 c4 04	 add	 esp, 4
  002a8	85 c0		 test	 eax, eax
  002aa	74 09		 je	 SHORT $LN15@LoadCentra

; 779  :       err=ZIP_ERRNO;

  002ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 780  :     else

  002b3	eb 05		 jmp	 SHORT $LN14@LoadCentra
$LN15@LoadCentra:

; 781  :       offset_central_dir = uL;

  002b5	8b 75 f4	 mov	 esi, DWORD PTR _uL$[ebp]
  002b8	33 db		 xor	 ebx, ebx
$LN14@LoadCentra:

; 782  : 
; 783  : 
; 784  :     /* zipfile global comment length */
; 785  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)

  002ba	8d 45 e4	 lea	 eax, DWORD PTR _size_comment$[ebp]
  002bd	50		 push	 eax
  002be	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  002c1	8b cf		 mov	 ecx, edi
  002c3	e8 00 00 00 00	 call	 _zip64local_getShort
  002c8	83 c4 04	 add	 esp, 4
  002cb	85 c0		 test	 eax, eax
  002cd	74 07		 je	 SHORT $LN13@LoadCentra

; 786  :       err=ZIP_ERRNO;

  002cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1
$LN13@LoadCentra:

; 787  :   }
; 788  : 
; 789  :   if ((central_pos<offset_central_dir+size_central_dir) &&
; 790  :     (err==ZIP_OK))

  002d6	8b 45 dc	 mov	 eax, DWORD PTR _central_pos$[ebp+4]
  002d9	8b d6		 mov	 edx, esi
  002db	03 55 e8	 add	 edx, DWORD PTR _size_central_dir$[ebp]
  002de	8b cb		 mov	 ecx, ebx
  002e0	13 4d ec	 adc	 ecx, DWORD PTR _size_central_dir$[ebp+4]
  002e3	3b c1		 cmp	 eax, ecx
  002e5	72 0f		 jb	 SHORT $LN50@LoadCentra
  002e7	8b 4d d8	 mov	 ecx, DWORD PTR _central_pos$[ebp]
  002ea	77 04		 ja	 SHORT $LN54@LoadCentra
  002ec	3b ca		 cmp	 ecx, edx

; 791  :     err=ZIP_BADZIPFILE;
; 792  : 
; 793  :   if (err!=ZIP_OK)

  002ee	72 06		 jb	 SHORT $LN50@LoadCentra
$LN54@LoadCentra:
  002f0	83 7d fc 00	 cmp	 DWORD PTR _err$[ebp], 0
  002f4	74 19		 je	 SHORT $LN11@LoadCentra
$LN50@LoadCentra:

; 794  :   {
; 795  :     ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);

  002f6	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  002f9	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  002fc	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  002ff	51		 push	 ecx
  00300	52		 push	 edx
  00301	ff d0		 call	 eax
  00303	83 c4 08	 add	 esp, 8

; 796  :     return ZIP_ERRNO;

  00306	83 c8 ff	 or	 eax, -1

; 842  : }

  00309	5e		 pop	 esi
  0030a	5b		 pop	 ebx
  0030b	8b e5		 mov	 esp, ebp
  0030d	5d		 pop	 ebp
  0030e	c3		 ret	 0
$LN11@LoadCentra:

; 797  :   }
; 798  : 
; 799  :   if (size_comment>0)

  0030f	8b 55 e4	 mov	 edx, DWORD PTR _size_comment$[ebp]
  00312	85 d2		 test	 edx, edx
  00314	74 39		 je	 SHORT $LN9@LoadCentra

; 800  :   {
; 801  :     pziinit->globalcomment = (char*)ALLOC(size_comment+1);

  00316	42		 inc	 edx
  00317	52		 push	 edx
  00318	e8 00 00 00 00	 call	 _malloc
  0031d	83 c4 04	 add	 esp, 4
  00320	89 87 00 01 01
	00		 mov	 DWORD PTR [edi+65792], eax

; 802  :     if (pziinit->globalcomment)

  00326	85 c0		 test	 eax, eax
  00328	74 1f		 je	 SHORT $LN64@LoadCentra

; 803  :     {
; 804  :       size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);

  0032a	8b 4d e4	 mov	 ecx, DWORD PTR _size_comment$[ebp]
  0032d	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00330	51		 push	 ecx
  00331	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00334	50		 push	 eax
  00335	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00338	52		 push	 edx
  00339	50		 push	 eax
  0033a	ff d1		 call	 ecx

; 805  :       pziinit->globalcomment[size_comment]=0;

  0033c	8b 97 00 01 01
	00		 mov	 edx, DWORD PTR [edi+65792]
  00342	83 c4 10	 add	 esp, 16			; 00000010H
  00345	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
$LN64@LoadCentra:
  00349	8b 45 dc	 mov	 eax, DWORD PTR _central_pos$[ebp+4]
  0034c	8b 4d d8	 mov	 ecx, DWORD PTR _central_pos$[ebp]
$LN9@LoadCentra:

; 806  :     }
; 807  :   }
; 808  : 
; 809  :   byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);

  0034f	8b 55 ec	 mov	 edx, DWORD PTR _size_central_dir$[ebp+4]
  00352	2b ce		 sub	 ecx, esi
  00354	1b c3		 sbb	 eax, ebx
  00356	2b 4d e8	 sub	 ecx, DWORD PTR _size_central_dir$[ebp]

; 810  :   pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
; 811  : 
; 812  :   {
; 813  :     ZPOS64_T size_central_dir_to_read = size_central_dir;
; 814  :     size_t buf_size = SIZEDATA_INDATABLOCK;
; 815  :     void* buf_read = (void*)ALLOC(buf_size);

  00359	68 f0 0f 00 00	 push	 4080			; 00000ff0H
  0035e	1b c2		 sbb	 eax, edx
  00360	89 45 f4	 mov	 DWORD PTR _byte_before_the_zipfile$[ebp+4], eax
  00363	89 87 f4 00 01
	00		 mov	 DWORD PTR [edi+65780], eax
  00369	8b 45 e8	 mov	 eax, DWORD PTR _size_central_dir$[ebp]
  0036c	89 4d f0	 mov	 DWORD PTR _byte_before_the_zipfile$[ebp], ecx
  0036f	89 8f f0 00 01
	00		 mov	 DWORD PTR [edi+65776], ecx
  00375	89 45 d8	 mov	 DWORD PTR _size_central_dir_to_read$83077[ebp], eax
  00378	89 55 dc	 mov	 DWORD PTR _size_central_dir_to_read$83077[ebp+4], edx
  0037b	e8 00 00 00 00	 call	 _malloc

; 816  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)

  00380	8b 4d f4	 mov	 ecx, DWORD PTR _byte_before_the_zipfile$[ebp+4]
  00383	89 45 e4	 mov	 DWORD PTR _buf_read$83079[ebp], eax
  00386	8b 45 f0	 mov	 eax, DWORD PTR _byte_before_the_zipfile$[ebp]
  00389	83 c4 04	 add	 esp, 4
  0038c	03 c6		 add	 eax, esi
  0038e	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  00391	13 cb		 adc	 ecx, ebx
  00393	51		 push	 ecx
  00394	89 45 c8	 mov	 DWORD PTR tv439[ebp], eax
  00397	50		 push	 eax
  00398	33 d2		 xor	 edx, edx
  0039a	8b c7		 mov	 eax, edi
  0039c	89 4d cc	 mov	 DWORD PTR tv439[ebp+4], ecx
  0039f	e8 00 00 00 00	 call	 _call_zseek64
  003a4	83 c4 08	 add	 esp, 8
  003a7	85 c0		 test	 eax, eax
  003a9	74 07		 je	 SHORT $LN48@LoadCentra

; 817  :       err=ZIP_ERRNO;

  003ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1
$LN48@LoadCentra:

; 818  : 
; 819  :     while ((size_central_dir_to_read>0) && (err==ZIP_OK))

  003b2	83 7d ec 00	 cmp	 DWORD PTR _size_central_dir$[ebp+4], 0
  003b6	77 06		 ja	 SHORT $LN7@LoadCentra
  003b8	83 7d e8 00	 cmp	 DWORD PTR _size_central_dir$[ebp], 0
  003bc	76 78		 jbe	 SHORT $LN58@LoadCentra
$LN7@LoadCentra:
  003be	83 7d fc 00	 cmp	 DWORD PTR _err$[ebp], 0
  003c2	75 72		 jne	 SHORT $LN58@LoadCentra

; 820  :     {
; 821  :       ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
; 822  :       if (read_this > size_central_dir_to_read)

  003c4	8b 5d dc	 mov	 ebx, DWORD PTR _size_central_dir_to_read$83077[ebp+4]
  003c7	be f0 0f 00 00	 mov	 esi, 4080		; 00000ff0H
  003cc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _read_this$83085[ebp+4], 0
  003d3	85 db		 test	 ebx, ebx
  003d5	77 0d		 ja	 SHORT $LN5@LoadCentra
  003d7	72 05		 jb	 SHORT $LN56@LoadCentra
  003d9	39 75 d8	 cmp	 DWORD PTR _size_central_dir_to_read$83077[ebp], esi
  003dc	73 06		 jae	 SHORT $LN5@LoadCentra
$LN56@LoadCentra:

; 823  :         read_this = size_central_dir_to_read;

  003de	8b 75 d8	 mov	 esi, DWORD PTR _size_central_dir_to_read$83077[ebp]
  003e1	89 5d ec	 mov	 DWORD PTR _read_this$83085[ebp+4], ebx
$LN5@LoadCentra:

; 824  : 
; 825  :       if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)

  003e4	8b 4d e4	 mov	 ecx, DWORD PTR _buf_read$83079[ebp]
  003e7	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  003ea	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  003ed	56		 push	 esi
  003ee	51		 push	 ecx
  003ef	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  003f2	52		 push	 edx
  003f3	50		 push	 eax
  003f4	ff d1		 call	 ecx
  003f6	83 c4 10	 add	 esp, 16			; 00000010H
  003f9	33 c9		 xor	 ecx, ecx
  003fb	3b c6		 cmp	 eax, esi
  003fd	75 05		 jne	 SHORT $LN57@LoadCentra
  003ff	3b 4d ec	 cmp	 ecx, DWORD PTR _read_this$83085[ebp+4]
  00402	74 09		 je	 SHORT $LN52@LoadCentra
$LN57@LoadCentra:

; 826  :         err=ZIP_ERRNO;

  00404	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 827  : 
; 828  :       if (err==ZIP_OK)

  0040b	eb 14		 jmp	 SHORT $LN3@LoadCentra
$LN52@LoadCentra:

; 829  :         err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);

  0040d	8b 55 e4	 mov	 edx, DWORD PTR _buf_read$83079[ebp]
  00410	56		 push	 esi
  00411	52		 push	 edx
  00412	8d 47 30	 lea	 eax, DWORD PTR [edi+48]
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 _add_data_in_datablock
  0041b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0041e	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
$LN3@LoadCentra:

; 830  : 
; 831  :       size_central_dir_to_read-=read_this;

  00421	29 75 d8	 sub	 DWORD PTR _size_central_dir_to_read$83077[ebp], esi
  00424	1b 5d ec	 sbb	 ebx, DWORD PTR _read_this$83085[ebp+4]
  00427	89 5d dc	 mov	 DWORD PTR _size_central_dir_to_read$83077[ebp+4], ebx
  0042a	85 db		 test	 ebx, ebx
  0042c	77 90		 ja	 SHORT $LN7@LoadCentra

; 818  : 
; 819  :     while ((size_central_dir_to_read>0) && (err==ZIP_OK))

  0042e	72 06		 jb	 SHORT $LN58@LoadCentra
  00430	83 7d d8 00	 cmp	 DWORD PTR _size_central_dir_to_read$83077[ebp], 0
  00434	77 88		 ja	 SHORT $LN7@LoadCentra
$LN58@LoadCentra:

; 832  :     }
; 833  :     TRYFREE(buf_read);

  00436	8b 45 e4	 mov	 eax, DWORD PTR _buf_read$83079[ebp]
  00439	85 c0		 test	 eax, eax
  0043b	74 09		 je	 SHORT $LN2@LoadCentra
  0043d	50		 push	 eax
  0043e	e8 00 00 00 00	 call	 _free
  00443	83 c4 04	 add	 esp, 4
$LN2@LoadCentra:

; 834  :   }
; 835  :   pziinit->begin_pos = byte_before_the_zipfile;

  00446	8b 55 f4	 mov	 edx, DWORD PTR _byte_before_the_zipfile$[ebp+4]

; 836  :   pziinit->number_entry = number_entry_CD;

  00449	8b 45 d0	 mov	 eax, DWORD PTR _number_entry_CD$[ebp]
  0044c	8b 4d f0	 mov	 ecx, DWORD PTR _byte_before_the_zipfile$[ebp]

; 837  : 
; 838  :   if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)

  0044f	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  00452	89 97 ec 00 01
	00		 mov	 DWORD PTR [edi+65772], edx
  00458	8b 55 cc	 mov	 edx, DWORD PTR tv439[ebp+4]
  0045b	89 87 f8 00 01
	00		 mov	 DWORD PTR [edi+65784], eax
  00461	8b 45 c8	 mov	 eax, DWORD PTR tv439[ebp]
  00464	52		 push	 edx
  00465	89 8f e8 00 01
	00		 mov	 DWORD PTR [edi+65768], ecx
  0046b	8b 4d d4	 mov	 ecx, DWORD PTR _number_entry_CD$[ebp+4]
  0046e	50		 push	 eax
  0046f	33 d2		 xor	 edx, edx
  00471	8b c7		 mov	 eax, edi
  00473	89 8f fc 00 01
	00		 mov	 DWORD PTR [edi+65788], ecx
  00479	e8 00 00 00 00	 call	 _call_zseek64
  0047e	83 c4 08	 add	 esp, 8
  00481	85 c0		 test	 eax, eax
  00483	74 07		 je	 SHORT $LN1@LoadCentra

; 839  :     err=ZIP_ERRNO;

  00485	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1
$LN1@LoadCentra:

; 840  : 
; 841  :   return err;

  0048c	8b 45 fc	 mov	 eax, DWORD PTR _err$[ebp]

; 842  : }

  0048f	5e		 pop	 esi
  00490	5b		 pop	 ebx
  00491	8b e5		 mov	 esp, ebp
  00493	5d		 pop	 ebp
  00494	c3		 ret	 0
_LoadCentralDirectoryRecord ENDP
PUBLIC	_zipCloseFileInZipRaw64@16
; Function compile flags: /Ogtp
;	COMDAT _zipCloseFileInZipRaw64@16
_TEXT	SEGMENT
_err$ = -28						; size = 4
tv525 = -24						; size = 4
_datasize$ = -24					; size = 2
_cur_pos_inzip$83677 = -24				; size = 8
_compressed_size$ = -16					; size = 8
tv511 = -8						; size = 8
_file$ = 8						; size = 4
_uncompressed_size$ = 12				; size = 8
_crc32$ = 20						; size = 4
_zipCloseFileInZipRaw64@16 PROC				; COMDAT

; 1515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx

; 1516 :     zip64_internal* zi;
; 1517 :     ZPOS64_T compressed_size;
; 1518 :     uLong invalidValue = 0xffffffff;
; 1519 :     short datasize = 0;
; 1520 :     int err=ZIP_OK;
; 1521 : 
; 1522 :     if (file == NULL)

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  0000d	33 c0		 xor	 eax, eax
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	89 44 24 10	 mov	 DWORD PTR _datasize$[esp+40], eax
  00015	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax
  00019	3b d8		 cmp	 ebx, eax
  0001b	75 0e		 jne	 SHORT $LN45@zipCloseFi
$LN89@zipCloseFi:

; 1523 :         return ZIP_PARAMERROR;

  0001d	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1745 :     zi->in_opened_file_inzip = 0;
; 1746 : 
; 1747 :     return err;
; 1748 : }

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 10 00	 ret	 16			; 00000010H
$LN45@zipCloseFi:

; 1524 :     zi = (zip64_internal*)file;
; 1525 : 
; 1526 :     if (zi->in_opened_file_inzip == 0)

  0002b	39 43 38	 cmp	 DWORD PTR [ebx+56], eax

; 1527 :         return ZIP_PARAMERROR;

  0002e	74 ed		 je	 SHORT $LN89@zipCloseFi

; 1528 :     zi->ci.stream.avail_in = 0;
; 1529 : 
; 1530 :     if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  00030	83 bb 9c 00 00
	00 08		 cmp	 DWORD PTR [ebx+156], 8
  00037	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  0003a	75 4e		 jne	 SHORT $LN36@zipCloseFi
  0003c	39 83 a0 00 00
	00		 cmp	 DWORD PTR [ebx+160], eax
  00042	75 46		 jne	 SHORT $LN36@zipCloseFi
  00044	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
$LN42@zipCloseFi:

; 1531 :                 {
; 1532 :                         while (err==ZIP_OK)
; 1533 :                         {
; 1534 :                                 uLong uTotalOutBefore;
; 1535 :                                 if (zi->ci.stream.avail_out == 0)

  00047	83 7b 50 00	 cmp	 DWORD PTR [ebx+80], 0
  0004b	75 15		 jne	 SHORT $LN40@zipCloseFi

; 1536 :                                 {
; 1537 :                                         if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)

  0004d	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer

; 1538 :                                                 err = ZIP_ERRNO;
; 1539 :                                         zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
; 1540 :                                         zi->ci.stream.next_out = zi->ci.buffered_data;

  00052	8d 83 a4 00 00
	00		 lea	 eax, DWORD PTR [ebx+164]
  00058	c7 43 50 00 00
	01 00		 mov	 DWORD PTR [ebx+80], 65536 ; 00010000H
  0005f	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
$LN40@zipCloseFi:

; 1541 :                                 }
; 1542 :                                 uTotalOutBefore = zi->ci.stream.total_out;

  00062	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]

; 1543 :                                 err=deflate(&zi->ci.stream,  Z_FINISH);

  00065	6a 04		 push	 4
  00067	57		 push	 edi
  00068	e8 00 00 00 00	 call	 _deflate@8

; 1544 :                                 zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;

  0006d	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  00070	2b ce		 sub	 ecx, esi
  00072	01 4b 7c	 add	 DWORD PTR [ebx+124], ecx
  00075	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax
  00079	85 c0		 test	 eax, eax
  0007b	74 ca		 je	 SHORT $LN42@zipCloseFi

; 1545 :                         }
; 1546 :                 }
; 1547 :     else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1548 :     {
; 1549 : #ifdef HAVE_BZIP2
; 1550 :       err = BZ_FINISH_OK;
; 1551 :       while (err==BZ_FINISH_OK)
; 1552 :       {
; 1553 :         uLong uTotalOutBefore;
; 1554 :         if (zi->ci.bstream.avail_out == 0)
; 1555 :         {
; 1556 :           if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
; 1557 :             err = ZIP_ERRNO;
; 1558 :           zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1559 :           zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1560 :         }
; 1561 :         uTotalOutBefore = zi->ci.bstream.total_out_lo32;
; 1562 :         err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);
; 1563 :         if(err == BZ_STREAM_END)
; 1564 :           err = Z_STREAM_END;
; 1565 : 
; 1566 :         zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
; 1567 :       }
; 1568 : 
; 1569 :       if(err == BZ_FINISH_OK)
; 1570 :         err = ZIP_OK;
; 1571 : #endif
; 1572 :     }
; 1573 : 
; 1574 :     if (err==Z_STREAM_END)

  0007d	83 f8 01	 cmp	 eax, 1
  00080	75 08		 jne	 SHORT $LN36@zipCloseFi

; 1575 :         err=ZIP_OK; /* this is normal */

  00082	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _err$[esp+40], 0
$LN36@zipCloseFi:

; 1576 : 
; 1577 :     if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))

  0008a	83 7b 7c 00	 cmp	 DWORD PTR [ebx+124], 0
  0008e	76 19		 jbe	 SHORT $LN69@zipCloseFi
  00090	83 7c 24 0c 00	 cmp	 DWORD PTR _err$[esp+40], 0
  00095	75 12		 jne	 SHORT $LN69@zipCloseFi

; 1578 :                 {
; 1579 :         if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)

  00097	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer
  0009c	83 ce ff	 or	 esi, -1
  0009f	3b c6		 cmp	 eax, esi
  000a1	75 09		 jne	 SHORT $LN34@zipCloseFi

; 1580 :             err = ZIP_ERRNO;

  000a3	89 74 24 0c	 mov	 DWORD PTR _err$[esp+40], esi
  000a7	eb 03		 jmp	 SHORT $LN34@zipCloseFi
$LN69@zipCloseFi:
  000a9	83 ce ff	 or	 esi, -1
$LN34@zipCloseFi:

; 1581 :                 }
; 1582 : 
; 1583 :     if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  000ac	83 bb 9c 00 00
	00 08		 cmp	 DWORD PTR [ebx+156], 8
  000b3	75 24		 jne	 SHORT $LN33@zipCloseFi
  000b5	83 bb a0 00 00
	00 00		 cmp	 DWORD PTR [ebx+160], 0
  000bc	75 3f		 jne	 SHORT $LN31@zipCloseFi

; 1584 :     {
; 1585 :         int tmp_err = deflateEnd(&zi->ci.stream);

  000be	8d 53 40	 lea	 edx, DWORD PTR [ebx+64]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 _deflateEnd@4

; 1586 :         if (err == ZIP_OK)

  000c7	83 7c 24 0c 00	 cmp	 DWORD PTR _err$[esp+40], 0
  000cc	75 04		 jne	 SHORT $LN32@zipCloseFi

; 1587 :             err = tmp_err;

  000ce	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax
$LN32@zipCloseFi:

; 1588 :         zi->ci.stream_initialised = 0;

  000d2	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [ebx+120], 0
$LN33@zipCloseFi:

; 1589 :     }
; 1590 : #ifdef HAVE_BZIP2
; 1591 :     else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1592 :     {
; 1593 :       int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
; 1594 :                         if (err==ZIP_OK)
; 1595 :                                 err = tmperr;
; 1596 :                         zi->ci.stream_initialised = 0;
; 1597 :     }
; 1598 : #endif
; 1599 : 
; 1600 :     if (!zi->ci.raw)

  000d9	83 bb a0 00 00
	00 00		 cmp	 DWORD PTR [ebx+160], 0
  000e0	75 1b		 jne	 SHORT $LN31@zipCloseFi

; 1601 :     {
; 1602 :         crc32 = (uLong)zi->ci.crc32;

  000e2	8b 83 a8 00 01
	00		 mov	 eax, DWORD PTR [ebx+65704]

; 1603 :         uncompressed_size = zi->ci.totalUncompressedData;

  000e8	8b 8b c8 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65736]
  000ee	8b 93 cc 00 01
	00		 mov	 edx, DWORD PTR [ebx+65740]
  000f4	89 45 14	 mov	 DWORD PTR _crc32$[ebp], eax
  000f7	89 4d 0c	 mov	 DWORD PTR _uncompressed_size$[ebp], ecx
  000fa	89 55 10	 mov	 DWORD PTR _uncompressed_size$[ebp+4], edx
$LN31@zipCloseFi:

; 1604 :     }
; 1605 :     compressed_size = zi->ci.totalCompressedData;
; 1606 : 
; 1607 : #    ifndef NOCRYPT
; 1608 :     compressed_size += zi->ci.crypt_header_size;

  000fd	8b 83 e0 00 01
	00		 mov	 eax, DWORD PTR [ebx+65760]
  00103	99		 cdq
  00104	03 83 c0 00 01
	00		 add	 eax, DWORD PTR [ebx+65728]
  0010a	13 93 c4 00 01
	00		 adc	 edx, DWORD PTR [ebx+65732]
  00110	89 44 24 18	 mov	 DWORD PTR _compressed_size$[esp+40], eax
  00114	89 54 24 1c	 mov	 DWORD PTR _compressed_size$[esp+44], edx

; 1609 : #    endif
; 1610 : 
; 1611 :     // update Current Item crc and sizes,
; 1612 :     if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)

  00118	85 d2		 test	 edx, edx
  0011a	77 24		 ja	 SHORT $LN55@zipCloseFi
  0011c	72 04		 jb	 SHORT $LN53@zipCloseFi
  0011e	3b c6		 cmp	 eax, esi
  00120	73 1e		 jae	 SHORT $LN55@zipCloseFi
$LN53@zipCloseFi:
  00122	83 7d 10 00	 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 0
  00126	77 18		 ja	 SHORT $LN55@zipCloseFi
  00128	72 05		 jb	 SHORT $LN54@zipCloseFi
  0012a	39 75 0c	 cmp	 DWORD PTR _uncompressed_size$[ebp], esi
  0012d	73 11		 jae	 SHORT $LN55@zipCloseFi
$LN54@zipCloseFi:
  0012f	83 bb 84 00 00
	00 00		 cmp	 DWORD PTR [ebx+132], 0
  00136	77 08		 ja	 SHORT $LN55@zipCloseFi
  00138	39 b3 80 00 00
	00		 cmp	 DWORD PTR [ebx+128], esi
  0013e	72 2c		 jb	 SHORT $LN30@zipCloseFi
$LN55@zipCloseFi:

; 1613 :     {
; 1614 :       /*version Made by*/
; 1615 :       zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);

  00140	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00146	6a 00		 push	 0
  00148	6a 2d		 push	 45			; 0000002dH
  0014a	83 c7 04	 add	 edi, 4
  0014d	be 02 00 00 00	 mov	 esi, 2
  00152	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1616 :       /*version needed*/
; 1617 :       zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);

  00157	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  0015d	6a 00		 push	 0
  0015f	6a 2d		 push	 45			; 0000002dH
  00161	83 c7 06	 add	 edi, 6
  00164	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  00169	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@zipCloseFi:

; 1618 : 
; 1619 :     }
; 1620 : 
; 1621 :     zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/

  0016c	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00172	33 c0		 xor	 eax, eax
  00174	50		 push	 eax
  00175	89 44 24 28	 mov	 DWORD PTR tv511[esp+48], eax
  00179	8b 45 14	 mov	 eax, DWORD PTR _crc32$[ebp]
  0017c	50		 push	 eax
  0017d	83 c7 10	 add	 edi, 16			; 00000010H
  00180	be 04 00 00 00	 mov	 esi, 4
  00185	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1622 : 
; 1623 : 
; 1624 :     if(compressed_size >= 0xffffffff)

  0018a	8b 44 24 24	 mov	 eax, DWORD PTR _compressed_size$[esp+52]
  0018e	83 c4 08	 add	 esp, 8
  00191	85 c0		 test	 eax, eax
  00193	75 09		 jne	 SHORT $LN56@zipCloseFi
  00195	8b 4c 24 18	 mov	 ecx, DWORD PTR _compressed_size$[esp+40]
  00199	83 f9 ff	 cmp	 ecx, -1
  0019c	72 06		 jb	 SHORT $LN28@zipCloseFi
$LN56@zipCloseFi:

; 1625 :       zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/

  0019e	6a 00		 push	 0
  001a0	6a ff		 push	 -1

; 1626 :     else

  001a2	eb 02		 jmp	 SHORT $LN86@zipCloseFi
$LN28@zipCloseFi:

; 1627 :       zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/

  001a4	50		 push	 eax
  001a5	51		 push	 ecx
$LN86@zipCloseFi:
  001a6	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001ac	83 c7 14	 add	 edi, 20			; 00000014H
  001af	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  001b4	83 c4 08	 add	 esp, 8

; 1628 : 
; 1629 :     /// set internal file attributes field
; 1630 :     if (zi->ci.stream.data_type == Z_ASCII)

  001b7	83 7b 6c 01	 cmp	 DWORD PTR [ebx+108], 1
  001bb	75 1a		 jne	 SHORT $LN26@zipCloseFi

; 1631 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);

  001bd	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001c3	6a 00		 push	 0
  001c5	6a 01		 push	 1
  001c7	83 c7 24	 add	 edi, 36			; 00000024H
  001ca	be 02 00 00 00	 mov	 esi, 2
  001cf	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  001d4	83 c4 08	 add	 esp, 8
$LN26@zipCloseFi:

; 1632 : 
; 1633 :     if(uncompressed_size >= 0xffffffff)

  001d7	8b 4d 10	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp+4]
  001da	85 c9		 test	 ecx, ecx
  001dc	75 08		 jne	 SHORT $LN57@zipCloseFi
  001de	8b 45 0c	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  001e1	83 f8 ff	 cmp	 eax, -1
  001e4	72 06		 jb	 SHORT $LN25@zipCloseFi
$LN57@zipCloseFi:

; 1634 :       zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/

  001e6	6a 00		 push	 0
  001e8	6a ff		 push	 -1

; 1635 :     else

  001ea	eb 02		 jmp	 SHORT $LN87@zipCloseFi
$LN25@zipCloseFi:

; 1636 :       zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/

  001ec	51		 push	 ecx
  001ed	50		 push	 eax
$LN87@zipCloseFi:
  001ee	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001f4	be 04 00 00 00	 mov	 esi, 4
  001f9	83 c7 18	 add	 edi, 24			; 00000018H
  001fc	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  00201	83 c4 08	 add	 esp, 8

; 1637 : 
; 1638 :     // Add ZIP64 extra info field for uncompressed size
; 1639 :     if(uncompressed_size >= 0xffffffff)

  00204	83 7d 10 00	 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 0
  00208	77 08		 ja	 SHORT $LN58@zipCloseFi
  0020a	83 c9 ff	 or	 ecx, -1
  0020d	39 4d 0c	 cmp	 DWORD PTR _uncompressed_size$[ebp], ecx
  00210	72 0a		 jb	 SHORT $LN71@zipCloseFi
$LN58@zipCloseFi:

; 1640 :       datasize += 8;

  00212	b8 08 00 00 00	 mov	 eax, 8
  00217	83 c9 ff	 or	 ecx, -1
  0021a	eb 04		 jmp	 SHORT $LN23@zipCloseFi
$LN71@zipCloseFi:
  0021c	8b 44 24 10	 mov	 eax, DWORD PTR _datasize$[esp+40]
$LN23@zipCloseFi:

; 1641 : 
; 1642 :     // Add ZIP64 extra info field for compressed size
; 1643 :     if(compressed_size >= 0xffffffff)

  00220	83 7c 24 1c 00	 cmp	 DWORD PTR _compressed_size$[esp+44], 0
  00225	77 06		 ja	 SHORT $LN59@zipCloseFi
  00227	39 4c 24 18	 cmp	 DWORD PTR _compressed_size$[esp+40], ecx
  0022b	72 03		 jb	 SHORT $LN22@zipCloseFi
$LN59@zipCloseFi:

; 1644 :       datasize += 8;

  0022d	83 c0 08	 add	 eax, 8
$LN22@zipCloseFi:

; 1645 : 
; 1646 :     // Add ZIP64 extra info field for relative offset to local file header of current file
; 1647 :     if(zi->ci.pos_local_header >= 0xffffffff)

  00230	83 bb 84 00 00
	00 00		 cmp	 DWORD PTR [ebx+132], 0
  00237	77 08		 ja	 SHORT $LN60@zipCloseFi
  00239	39 8b 80 00 00
	00		 cmp	 DWORD PTR [ebx+128], ecx
  0023f	72 03		 jb	 SHORT $LN21@zipCloseFi
$LN60@zipCloseFi:

; 1648 :       datasize += 8;

  00241	83 c0 08	 add	 eax, 8
$LN21@zipCloseFi:

; 1649 : 
; 1650 :     if(datasize > 0)

  00244	66 85 c0	 test	 ax, ax
  00247	0f 8e f6 00 00
	00		 jle	 $LN20@zipCloseFi

; 1651 :     {
; 1652 :       char* p = NULL;
; 1653 : 
; 1654 :       if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)

  0024d	98		 cwde
  0024e	89 44 24 10	 mov	 DWORD PTR tv525[esp+40], eax
  00252	83 c0 04	 add	 eax, 4
  00255	3b 83 94 00 00
	00		 cmp	 eax, DWORD PTR [ebx+148]
  0025b	76 0e		 jbe	 SHORT $LN19@zipCloseFi

; 1655 :       {
; 1656 :         // we can not write more data to the buffer that we have room for.
; 1657 :         return ZIP_BADZIPFILE;

  0025d	b8 99 ff ff ff	 mov	 eax, -103		; ffffff99H

; 1745 :     zi->in_opened_file_inzip = 0;
; 1746 : 
; 1747 :     return err;
; 1748 : }

  00262	5f		 pop	 edi
  00263	5e		 pop	 esi
  00264	5b		 pop	 ebx
  00265	8b e5		 mov	 esp, ebp
  00267	5d		 pop	 ebp
  00268	c2 10 00	 ret	 16			; 00000010H
$LN19@zipCloseFi:

; 1658 :       }
; 1659 : 
; 1660 :       p = zi->ci.central_header + zi->ci.size_centralheader;

  0026b	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00271	03 bb 90 00 00
	00		 add	 edi, DWORD PTR [ebx+144]

; 1661 : 
; 1662 :       // Add Extra Information Header for 'ZIP64 information'
; 1663 :       zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID

  00277	6a 00		 push	 0
  00279	6a 01		 push	 1
  0027b	be 02 00 00 00	 mov	 esi, 2
  00280	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1664 :       p += 2;
; 1665 :       zip64local_putValue_inmemory(p, datasize, 2); // DataSize

  00285	8b 44 24 18	 mov	 eax, DWORD PTR tv525[esp+48]
  00289	99		 cdq
  0028a	52		 push	 edx
  0028b	03 fe		 add	 edi, esi
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1666 :       p += 2;
; 1667 : 
; 1668 :       if(uncompressed_size >= 0xffffffff)

  00293	8b 45 10	 mov	 eax, DWORD PTR _uncompressed_size$[ebp+4]
  00296	83 c4 10	 add	 esp, 16			; 00000010H
  00299	03 fe		 add	 edi, esi
  0029b	85 c0		 test	 eax, eax
  0029d	75 06		 jne	 SHORT $LN61@zipCloseFi
  0029f	83 7d 0c ff	 cmp	 DWORD PTR _uncompressed_size$[ebp], -1
  002a3	72 14		 jb	 SHORT $LN18@zipCloseFi
$LN61@zipCloseFi:

; 1669 :       {
; 1670 :         zip64local_putValue_inmemory(p, uncompressed_size, 8);

  002a5	8b 4d 0c	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp]
  002a8	50		 push	 eax
  002a9	51		 push	 ecx
  002aa	be 08 00 00 00	 mov	 esi, 8
  002af	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002b4	83 c4 08	 add	 esp, 8

; 1671 :         p += 8;

  002b7	03 fe		 add	 edi, esi
$LN18@zipCloseFi:

; 1672 :       }
; 1673 : 
; 1674 :       if(compressed_size >= 0xffffffff)

  002b9	8b 44 24 1c	 mov	 eax, DWORD PTR _compressed_size$[esp+44]
  002bd	85 c0		 test	 eax, eax
  002bf	75 07		 jne	 SHORT $LN62@zipCloseFi
  002c1	83 7c 24 18 ff	 cmp	 DWORD PTR _compressed_size$[esp+40], -1
  002c6	72 15		 jb	 SHORT $LN17@zipCloseFi
$LN62@zipCloseFi:

; 1675 :       {
; 1676 :         zip64local_putValue_inmemory(p, compressed_size, 8);

  002c8	8b 54 24 18	 mov	 edx, DWORD PTR _compressed_size$[esp+40]
  002cc	50		 push	 eax
  002cd	52		 push	 edx
  002ce	be 08 00 00 00	 mov	 esi, 8
  002d3	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002d8	83 c4 08	 add	 esp, 8

; 1677 :         p += 8;

  002db	03 fe		 add	 edi, esi
$LN17@zipCloseFi:

; 1678 :       }
; 1679 : 
; 1680 :       if(zi->ci.pos_local_header >= 0xffffffff)

  002dd	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [ebx+132]
  002e3	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [ebx+128]
  002e9	85 c0		 test	 eax, eax
  002eb	75 05		 jne	 SHORT $LN63@zipCloseFi
  002ed	83 f9 ff	 cmp	 ecx, -1
  002f0	72 0f		 jb	 SHORT $LN16@zipCloseFi
$LN63@zipCloseFi:

; 1681 :       {
; 1682 :         zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);

  002f2	50		 push	 eax
  002f3	51		 push	 ecx
  002f4	be 08 00 00 00	 mov	 esi, 8
  002f9	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002fe	83 c4 08	 add	 esp, 8
$LN16@zipCloseFi:

; 1683 :         p += 8;
; 1684 :       }
; 1685 : 
; 1686 :       // Update how much extra free space we got in the memory buffer
; 1687 :       // and increase the centralheader size so the new ZIP64 fields are included
; 1688 :       // ( 4 below is the size of HeaderID and DataSize field )
; 1689 :       zi->ci.size_centralExtraFree -= datasize + 4;

  00301	8b 44 24 10	 mov	 eax, DWORD PTR tv525[esp+40]

; 1690 :       zi->ci.size_centralheader += datasize + 4;
; 1691 : 
; 1692 :       // Update the extra info size field
; 1693 :       zi->ci.size_centralExtra += datasize + 4;
; 1694 :       zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);

  00305	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  0030b	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0030e	01 93 90 00 00
	00		 add	 DWORD PTR [ebx+144], edx
  00314	b9 fc ff ff ff	 mov	 ecx, -4			; fffffffcH
  00319	2b c8		 sub	 ecx, eax
  0031b	01 8b 94 00 00
	00		 add	 DWORD PTR [ebx+148], ecx
  00321	83 c0 04	 add	 eax, 4
  00324	01 83 8c 00 00
	00		 add	 DWORD PTR [ebx+140], eax
  0032a	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  00330	6a 00		 push	 0
  00332	50		 push	 eax
  00333	83 c7 1e	 add	 edi, 30			; 0000001eH
  00336	be 02 00 00 00	 mov	 esi, 2
  0033b	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  00340	83 c4 08	 add	 esp, 8
$LN20@zipCloseFi:

; 1695 :     }
; 1696 : 
; 1697 :     if (err==ZIP_OK)

  00343	83 7c 24 0c 00	 cmp	 DWORD PTR _err$[esp+40], 0
  00348	75 1e		 jne	 SHORT $LN15@zipCloseFi

; 1698 :         err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);

  0034a	8b 83 90 00 00
	00		 mov	 eax, DWORD PTR [ebx+144]
  00350	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  00356	50		 push	 eax
  00357	51		 push	 ecx
  00358	8d 53 30	 lea	 edx, DWORD PTR [ebx+48]
  0035b	52		 push	 edx
  0035c	e8 00 00 00 00	 call	 _add_data_in_datablock
  00361	83 c4 0c	 add	 esp, 12			; 0000000cH
  00364	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax
$LN15@zipCloseFi:

; 1699 : 
; 1700 :     free(zi->ci.central_header);

  00368	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 _free
  00374	83 c4 04	 add	 esp, 4

; 1701 : 
; 1702 :     if (err==ZIP_OK)

  00377	83 7c 24 0c 00	 cmp	 DWORD PTR _err$[esp+40], 0
  0037c	0f 85 5d 01 00
	00		 jne	 $LN1@zipCloseFi

; 1703 :     {
; 1704 :         // Update the LocalFileHeader with the new values.
; 1705 : 
; 1706 :         ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);

  00382	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  00385	8b c3		 mov	 eax, ebx
  00387	e8 00 00 00 00	 call	 _call_ztell64

; 1707 : 
; 1708 :         if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0038c	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [ebx+128]
  00392	8b 73 2c	 mov	 esi, DWORD PTR [ebx+44]
  00395	89 54 24 14	 mov	 DWORD PTR _cur_pos_inzip$83677[esp+44], edx
  00399	8b 93 84 00 00
	00		 mov	 edx, DWORD PTR [ebx+132]
  0039f	83 c1 0e	 add	 ecx, 14			; 0000000eH
  003a2	83 d2 00	 adc	 edx, 0
  003a5	52		 push	 edx
  003a6	89 44 24 14	 mov	 DWORD PTR _cur_pos_inzip$83677[esp+44], eax
  003aa	51		 push	 ecx
  003ab	33 d2		 xor	 edx, edx
  003ad	8b c3		 mov	 eax, ebx
  003af	e8 00 00 00 00	 call	 _call_zseek64
  003b4	83 c4 08	 add	 esp, 8
  003b7	85 c0		 test	 eax, eax
  003b9	74 09		 je	 SHORT $LN51@zipCloseFi

; 1709 :             err = ZIP_ERRNO;

  003bb	83 cf ff	 or	 edi, -1
  003be	89 7c 24 0c	 mov	 DWORD PTR _err$[esp+40], edi

; 1710 : 
; 1711 :         if (err==ZIP_OK)

  003c2	eb 22		 jmp	 SHORT $LN12@zipCloseFi
$LN51@zipCloseFi:

; 1712 :             err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */

  003c4	8b 44 24 24	 mov	 eax, DWORD PTR tv511[esp+44]
  003c8	8b 4d 14	 mov	 ecx, DWORD PTR _crc32$[ebp]
  003cb	8b 53 2c	 mov	 edx, DWORD PTR [ebx+44]
  003ce	50		 push	 eax
  003cf	51		 push	 ecx
  003d0	52		 push	 edx
  003d1	be 04 00 00 00	 mov	 esi, 4
  003d6	8b fb		 mov	 edi, ebx
  003d8	e8 00 00 00 00	 call	 _zip64local_putValue
  003dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e0	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax
  003e4	8b f8		 mov	 edi, eax
$LN12@zipCloseFi:

; 1713 : 
; 1714 :         if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )

  003e6	83 7d 10 00	 cmp	 DWORD PTR _uncompressed_size$[ebp+4], 0
  003ea	77 4c		 ja	 SHORT $LN10@zipCloseFi
  003ec	72 06		 jb	 SHORT $LN64@zipCloseFi
  003ee	83 7d 0c ff	 cmp	 DWORD PTR _uncompressed_size$[ebp], -1
  003f2	73 44		 jae	 SHORT $LN10@zipCloseFi
$LN64@zipCloseFi:
  003f4	8b 44 24 1c	 mov	 eax, DWORD PTR _compressed_size$[esp+44]
  003f8	85 c0		 test	 eax, eax
  003fa	77 3c		 ja	 SHORT $LN10@zipCloseFi
  003fc	72 07		 jb	 SHORT $LN65@zipCloseFi
  003fe	83 7c 24 18 ff	 cmp	 DWORD PTR _compressed_size$[esp+40], -1
  00403	73 33		 jae	 SHORT $LN10@zipCloseFi
$LN65@zipCloseFi:

; 1730 :         }
; 1731 :         else
; 1732 :         {
; 1733 :           if (err==ZIP_OK) /* compressed size, unknown */

  00405	85 ff		 test	 edi, edi
  00407	0f 85 ad 00 00
	00		 jne	 $LN5@zipCloseFi

; 1734 :               err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);

  0040d	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  00410	50		 push	 eax
  00411	8b 44 24 1c	 mov	 eax, DWORD PTR _compressed_size$[esp+44]
  00415	50		 push	 eax
  00416	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00419	51		 push	 ecx
  0041a	8b fb		 mov	 edi, ebx
  0041c	e8 00 00 00 00	 call	 _zip64local_putValue
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH
  00424	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax

; 1735 : 
; 1736 :           if (err==ZIP_OK) /* uncompressed size, unknown */

  00428	85 c0		 test	 eax, eax
  0042a	0f 85 8a 00 00
	00		 jne	 $LN5@zipCloseFi

; 1737 :               err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);

  00430	8b 55 10	 mov	 edx, DWORD PTR _uncompressed_size$[ebp+4]
  00433	8b 45 0c	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  00436	eb 66		 jmp	 SHORT $LN90@zipCloseFi
$LN10@zipCloseFi:

; 1715 :         {
; 1716 :           if(zi->ci.pos_zip64extrainfo > 0)

  00438	8b 83 bc 00 01
	00		 mov	 eax, DWORD PTR [ebx+65724]
  0043e	8b 8b b8 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65720]
  00444	85 c0		 test	 eax, eax
  00446	75 04		 jne	 SHORT $LN66@zipCloseFi
  00448	85 c9		 test	 ecx, ecx
  0044a	74 66		 je	 SHORT $LN9@zipCloseFi
$LN66@zipCloseFi:

; 1717 :           {
; 1718 :             // Update the size in the ZIP64 extended field.
; 1719 :             if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0044c	8b 73 2c	 mov	 esi, DWORD PTR [ebx+44]
  0044f	83 c1 04	 add	 ecx, 4
  00452	83 d0 00	 adc	 eax, 0
  00455	50		 push	 eax
  00456	51		 push	 ecx
  00457	33 d2		 xor	 edx, edx
  00459	8b c3		 mov	 eax, ebx
  0045b	e8 00 00 00 00	 call	 _call_zseek64
  00460	83 c4 08	 add	 esp, 8
  00463	85 c0		 test	 eax, eax
  00465	74 0a		 je	 SHORT $LN8@zipCloseFi

; 1720 :               err = ZIP_ERRNO;

  00467	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _err$[esp+40], -1

; 1721 : 
; 1722 :             if (err==ZIP_OK) /* compressed size, unknown */

  0046f	eb 49		 jmp	 SHORT $LN5@zipCloseFi
$LN8@zipCloseFi:
  00471	85 ff		 test	 edi, edi
  00473	75 45		 jne	 SHORT $LN5@zipCloseFi

; 1723 :               err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);

  00475	8b 55 10	 mov	 edx, DWORD PTR _uncompressed_size$[ebp+4]
  00478	8b 45 0c	 mov	 eax, DWORD PTR _uncompressed_size$[ebp]
  0047b	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  0047e	52		 push	 edx
  0047f	50		 push	 eax
  00480	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00483	51		 push	 ecx
  00484	8b fb		 mov	 edi, ebx
  00486	e8 00 00 00 00	 call	 _zip64local_putValue
  0048b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0048e	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax

; 1724 : 
; 1725 :             if (err==ZIP_OK) /* uncompressed size, unknown */

  00492	85 c0		 test	 eax, eax
  00494	75 24		 jne	 SHORT $LN5@zipCloseFi

; 1726 :               err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);

  00496	8b 54 24 1c	 mov	 edx, DWORD PTR _compressed_size$[esp+44]
  0049a	8b 44 24 18	 mov	 eax, DWORD PTR _compressed_size$[esp+40]
$LN90@zipCloseFi:
  0049e	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  004a1	52		 push	 edx
  004a2	50		 push	 eax
  004a3	51		 push	 ecx
  004a4	e8 00 00 00 00	 call	 _zip64local_putValue
  004a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ac	89 44 24 0c	 mov	 DWORD PTR _err$[esp+40], eax

; 1727 :           }
; 1728 :           else

  004b0	eb 08		 jmp	 SHORT $LN5@zipCloseFi
$LN9@zipCloseFi:

; 1729 :               err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal

  004b2	c7 44 24 0c 99
	ff ff ff	 mov	 DWORD PTR _err$[esp+40], -103 ; ffffff99H
$LN5@zipCloseFi:

; 1738 :         }
; 1739 : 
; 1740 :         if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)

  004ba	8b 54 24 14	 mov	 edx, DWORD PTR _cur_pos_inzip$83677[esp+44]
  004be	8b 44 24 10	 mov	 eax, DWORD PTR _cur_pos_inzip$83677[esp+40]
  004c2	8b 73 2c	 mov	 esi, DWORD PTR [ebx+44]
  004c5	52		 push	 edx
  004c6	50		 push	 eax
  004c7	33 d2		 xor	 edx, edx
  004c9	8b c3		 mov	 eax, ebx
  004cb	e8 00 00 00 00	 call	 _call_zseek64
  004d0	83 c4 08	 add	 esp, 8
  004d3	85 c0		 test	 eax, eax
  004d5	74 08		 je	 SHORT $LN1@zipCloseFi

; 1741 :             err = ZIP_ERRNO;

  004d7	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _err$[esp+40], -1
$LN1@zipCloseFi:

; 1742 :     }
; 1743 : 
; 1744 :     zi->number_entry ++;

  004df	83 83 f8 00 01
	00 01		 add	 DWORD PTR [ebx+65784], 1
  004e6	b8 00 00 00 00	 mov	 eax, 0

; 1745 :     zi->in_opened_file_inzip = 0;
; 1746 : 
; 1747 :     return err;
; 1748 : }

  004eb	5f		 pop	 edi
  004ec	11 83 fc 00 01
	00		 adc	 DWORD PTR [ebx+65788], eax
  004f2	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  004f5	8b 44 24 08	 mov	 eax, DWORD PTR _err$[esp+36]
  004f9	5e		 pop	 esi
  004fa	5b		 pop	 ebx
  004fb	8b e5		 mov	 esp, ebp
  004fd	5d		 pop	 ebp
  004fe	c2 10 00	 ret	 16			; 00000010H
_zipCloseFileInZipRaw64@16 ENDP
_TEXT	ENDS
PUBLIC	_zipCloseFileInZipRaw@12
; Function compile flags: /Ogtp
;	COMDAT _zipCloseFileInZipRaw@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_uncompressed_size$ = 12				; size = 4
_crc32$ = 16						; size = 4
_zipCloseFileInZipRaw@12 PROC				; COMDAT

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 1511 :     return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);

  00006	8b 45 10	 mov	 eax, DWORD PTR _crc32$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _zipCloseFileInZipRaw64@16

; 1512 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
_zipCloseFileInZipRaw@12 ENDP
_TEXT	ENDS
PUBLIC	_zipWriteInFileInZip@12
; Function compile flags: /Ogtp
;	COMDAT _zipWriteInFileInZip@12
_TEXT	SEGMENT
_err$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_zipWriteInFileInZip@12 PROC				; COMDAT

; 1403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1404 :     zip64_internal* zi;
; 1405 :     int err=ZIP_OK;
; 1406 : 
; 1407 :     if (file == NULL)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _err$[ebp], 0
  0000f	85 db		 test	 ebx, ebx
  00011	75 0c		 jne	 SHORT $LN15@zipWriteIn
$LN24@zipWriteIn:

; 1408 :         return ZIP_PARAMERROR;

  00013	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00018	5b		 pop	 ebx

; 1507 : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
$LN15@zipWriteIn:

; 1409 :     zi = (zip64_internal*)file;
; 1410 : 
; 1411 :     if (zi->in_opened_file_inzip == 0)

  0001f	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0

; 1412 :         return ZIP_PARAMERROR;

  00023	74 ee		 je	 SHORT $LN24@zipWriteIn

; 1413 : 
; 1414 :     zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00028	8b 8b a8 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65704]
  0002e	56		 push	 esi
  0002f	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  00032	57		 push	 edi
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _crc32@12

; 1415 : 
; 1416 : #ifdef HAVE_BZIP2
; 1417 :     if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
; 1418 :     {
; 1419 :       zi->ci.bstream.next_in = (void*)buf;
; 1420 :       zi->ci.bstream.avail_in = len;
; 1421 :       err = BZ_RUN_OK;
; 1422 : 
; 1423 :       while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))
; 1424 :       {
; 1425 :         if (zi->ci.bstream.avail_out == 0)
; 1426 :         {
; 1427 :           if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
; 1428 :             err = ZIP_ERRNO;
; 1429 :           zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1430 :           zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1431 :         }
; 1432 : 
; 1433 : 
; 1434 :         if(err != BZ_RUN_OK)
; 1435 :           break;
; 1436 : 
; 1437 :         if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1438 :         {
; 1439 :           uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
; 1440 : //          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
; 1441 :           err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);
; 1442 : 
; 1443 :           zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
; 1444 :         }
; 1445 :       }
; 1446 : 
; 1447 :       if(err == BZ_RUN_OK)
; 1448 :         err = ZIP_OK;
; 1449 :     }
; 1450 :     else
; 1451 : #endif
; 1452 :     {
; 1453 :       zi->ci.stream.next_in = (Bytef*)buf;

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0003e	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
  00041	89 83 a8 00 01
	00		 mov	 DWORD PTR [ebx+65704], eax
  00047	89 17		 mov	 DWORD PTR [edi], edx

; 1454 :       zi->ci.stream.avail_in = len;

  00049	89 73 44	 mov	 DWORD PTR [ebx+68], esi
  0004c	8d 64 24 00	 npad	 4
$LL13@zipWriteIn:

; 1455 : 
; 1456 :       while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))

  00050	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0
  00054	76 55		 jbe	 SHORT $LN23@zipWriteIn

; 1457 :       {
; 1458 :           if (zi->ci.stream.avail_out == 0)

  00056	83 7b 50 00	 cmp	 DWORD PTR [ebx+80], 0
  0005a	75 1d		 jne	 SHORT $LN11@zipWriteIn

; 1459 :           {
; 1460 :               if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)

  0005c	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer
  00061	83 f8 ff	 cmp	 eax, -1
  00064	75 03		 jne	 SHORT $LN10@zipWriteIn

; 1461 :                   err = ZIP_ERRNO;

  00066	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
$LN10@zipWriteIn:

; 1462 :               zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
; 1463 :               zi->ci.stream.next_out = zi->ci.buffered_data;

  00069	8d 83 a4 00 00
	00		 lea	 eax, DWORD PTR [ebx+164]
  0006f	c7 43 50 00 00
	01 00		 mov	 DWORD PTR [ebx+80], 65536 ; 00010000H
  00076	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
$LN11@zipWriteIn:

; 1464 :           }
; 1465 : 
; 1466 : 
; 1467 :           if(err != ZIP_OK)

  00079	83 7d fc 00	 cmp	 DWORD PTR _err$[ebp], 0
  0007d	75 2c		 jne	 SHORT $LN23@zipWriteIn

; 1468 :               break;
; 1469 : 
; 1470 :           if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  0007f	83 bb 9c 00 00
	00 08		 cmp	 DWORD PTR [ebx+156], 8
  00086	75 2f		 jne	 SHORT $LN8@zipWriteIn
  00088	83 bb a0 00 00
	00 00		 cmp	 DWORD PTR [ebx+160], 0
  0008f	75 26		 jne	 SHORT $LN8@zipWriteIn

; 1471 :           {
; 1472 :               uLong uTotalOutBefore = zi->ci.stream.total_out;

  00091	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]

; 1473 :               err=deflate(&zi->ci.stream,  Z_NO_FLUSH);

  00094	6a 00		 push	 0
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 _deflate@8

; 1474 :               if(uTotalOutBefore > zi->ci.stream.total_out)
; 1475 :               {
; 1476 :                 int bBreak = 0;
; 1477 :                 bBreak++;
; 1478 :               }
; 1479 : 
; 1480 :               zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;

  0009c	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  0009f	2b ce		 sub	 ecx, esi
  000a1	01 4b 7c	 add	 DWORD PTR [ebx+124], ecx
  000a4	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
  000a7	85 c0		 test	 eax, eax
  000a9	74 a5		 je	 SHORT $LL13@zipWriteIn
$LN23@zipWriteIn:

; 1501 :               }
; 1502 :           }
; 1503 :       }// while(...)
; 1504 :     }
; 1505 : 
; 1506 :     return err;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _err$[ebp]
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 1507 : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN8@zipWriteIn:

; 1481 :           }
; 1482 :           else
; 1483 :           {
; 1484 :               uInt copy_this,i;
; 1485 :               if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)

  000b7	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  000ba	8b 73 44	 mov	 esi, DWORD PTR [ebx+68]
  000bd	3b f0		 cmp	 esi, eax

; 1486 :                   copy_this = zi->ci.stream.avail_in;
; 1487 :               else

  000bf	72 02		 jb	 SHORT $LN4@zipWriteIn

; 1488 :                   copy_this = zi->ci.stream.avail_out;

  000c1	8b f0		 mov	 esi, eax
$LN4@zipWriteIn:

; 1489 : 
; 1490 :               for (i = 0; i < copy_this; i++)

  000c3	33 c0		 xor	 eax, eax
  000c5	85 f6		 test	 esi, esi
  000c7	74 17		 je	 SHORT $LN1@zipWriteIn
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$LL3@zipWriteIn:

; 1491 :                   *(((char*)zi->ci.stream.next_out)+i) =
; 1492 :                       *(((const char*)zi->ci.stream.next_in)+i);

  000d0	8b 17		 mov	 edx, DWORD PTR [edi]
  000d2	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  000d5	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000d8	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  000db	40		 inc	 eax
  000dc	3b c6		 cmp	 eax, esi
  000de	72 f0		 jb	 SHORT $LL3@zipWriteIn
$LN1@zipWriteIn:

; 1493 :               {
; 1494 :                   zi->ci.stream.avail_in -= copy_this;

  000e0	29 73 44	 sub	 DWORD PTR [ebx+68], esi

; 1495 :                   zi->ci.stream.avail_out-= copy_this;

  000e3	29 73 50	 sub	 DWORD PTR [ebx+80], esi

; 1496 :                   zi->ci.stream.next_in+= copy_this;

  000e6	01 37		 add	 DWORD PTR [edi], esi

; 1497 :                   zi->ci.stream.next_out+= copy_this;

  000e8	01 73 4c	 add	 DWORD PTR [ebx+76], esi

; 1498 :                   zi->ci.stream.total_in+= copy_this;

  000eb	01 73 48	 add	 DWORD PTR [ebx+72], esi

; 1499 :                   zi->ci.stream.total_out+= copy_this;

  000ee	01 73 54	 add	 DWORD PTR [ebx+84], esi

; 1500 :                   zi->ci.pos_in_buffered_data += copy_this;

  000f1	01 73 7c	 add	 DWORD PTR [ebx+124], esi
  000f4	e9 57 ff ff ff	 jmp	 $LL13@zipWriteIn
_zipWriteInFileInZip@12 ENDP
_TEXT	ENDS
PUBLIC	_zipOpen3@16
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT _zipOpen3@16
_TEXT	SEGMENT
_ziinit$ = -65800					; size = 65800
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_globalcomment$ = 16					; size = 4
_zipOpen3@16 PROC					; COMDAT
; _pzlib_filefunc64_32_def$ = ecx

; 850  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 0c 01 01 00	 mov	 eax, 65804		; 0001010cH
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 851  :     zip64_internal ziinit;
; 852  :     zip64_internal* zi;
; 853  :     int err=ZIP_OK;

  00012	33 db		 xor	 ebx, ebx
  00014	8b f1		 mov	 esi, ecx
  00016	57		 push	 edi

; 854  : 
; 855  :     ziinit.z_filefunc.zseek32_file = NULL;

  00017	89 5c 24 38	 mov	 DWORD PTR _ziinit$[esp+65856], ebx

; 856  :     ziinit.z_filefunc.ztell32_file = NULL;

  0001b	89 5c 24 34	 mov	 DWORD PTR _ziinit$[esp+65852], ebx

; 857  :     if (pzlib_filefunc64_32_def==NULL)

  0001f	3b f3		 cmp	 esi, ebx
  00021	75 0b		 jne	 SHORT $LN11@zipOpen3

; 858  :         fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);

  00023	8d 44 24 10	 lea	 eax, DWORD PTR _ziinit$[esp+65816]
  00027	e8 00 00 00 00	 call	 _fill_fopen64_filefunc

; 859  :     else

  0002c	eb 0b		 jmp	 SHORT $LN10@zipOpen3
$LN11@zipOpen3:

; 860  :         ziinit.z_filefunc = *pzlib_filefunc64_32_def;

  0002e	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00033	8d 7c 24 10	 lea	 edi, DWORD PTR _ziinit$[esp+65816]
  00037	f3 a5		 rep movsd
$LN10@zipOpen3:

; 861  : 
; 862  :     ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
; 863  :                   pathname,
; 864  :                   (append == APPEND_STATUS_CREATE) ?
; 865  :                   (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
; 866  :                     (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));

  00039	8b 7d 0c	 mov	 edi, DWORD PTR _append$[ebp]
  0003c	8b 75 08	 mov	 esi, DWORD PTR _pathname$[ebp]
  0003f	33 d2		 xor	 edx, edx
  00041	3b fb		 cmp	 edi, ebx
  00043	0f 94 c2	 sete	 dl
  00046	8d 44 24 10	 lea	 eax, DWORD PTR _ziinit$[esp+65816]
  0004a	8d 14 95 07 00
	00 00		 lea	 edx, DWORD PTR [edx*4+7]
  00051	e8 00 00 00 00	 call	 _call_zopen64
  00056	8b f0		 mov	 esi, eax
  00058	89 74 24 3c	 mov	 DWORD PTR _ziinit$[esp+65860], esi

; 867  : 
; 868  :     if (ziinit.filestream == NULL)

  0005c	3b f3		 cmp	 esi, ebx

; 869  :         return NULL;

  0005e	0f 84 83 00 00
	00		 je	 $LN15@zipOpen3

; 870  : 
; 871  :     if (append == APPEND_STATUS_CREATEAFTER)

  00064	83 ff 01	 cmp	 edi, 1
  00067	75 11		 jne	 SHORT $LN8@zipOpen3

; 872  :         ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);

  00069	53		 push	 ebx
  0006a	53		 push	 ebx
  0006b	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0006e	8d 44 24 18	 lea	 eax, DWORD PTR _ziinit$[esp+65824]
  00072	e8 00 00 00 00	 call	 _call_zseek64
  00077	83 c4 08	 add	 esp, 8
$LN8@zipOpen3:

; 873  : 
; 874  :     ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);

  0007a	8b ce		 mov	 ecx, esi
  0007c	8d 44 24 10	 lea	 eax, DWORD PTR _ziinit$[esp+65816]
  00080	e8 00 00 00 00	 call	 _call_ztell64
  00085	89 84 24 f8 00
	01 00		 mov	 DWORD PTR _ziinit$[esp+131584], eax

; 875  :     ziinit.in_opened_file_inzip = 0;
; 876  :     ziinit.ci.stream_initialised = 0;
; 877  :     ziinit.number_entry = 0;
; 878  :     ziinit.add_position_when_writting_offset = 0;
; 879  :     init_linkedlist(&(ziinit.central_dir));

  0008c	8d 44 24 40	 lea	 eax, DWORD PTR _ziinit$[esp+65864]
  00090	89 94 24 fc 00
	01 00		 mov	 DWORD PTR _ziinit$[esp+131588], edx
  00097	89 5c 24 48	 mov	 DWORD PTR _ziinit$[esp+65872], ebx
  0009b	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _ziinit$[esp+65936], ebx
  000a2	89 9c 24 08 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131600], ebx
  000a9	89 9c 24 0c 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131604], ebx
  000b0	89 9c 24 00 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131592], ebx
  000b7	89 9c 24 04 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131596], ebx
  000be	e8 00 00 00 00	 call	 _init_linkedlist

; 880  : 
; 881  : 
; 882  : 
; 883  :     zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));

  000c3	68 08 01 01 00	 push	 65800			; 00010108H
  000c8	e8 00 00 00 00	 call	 _malloc
  000cd	8b f0		 mov	 esi, eax
  000cf	83 c4 04	 add	 esp, 4

; 884  :     if (zi==NULL)

  000d2	3b f3		 cmp	 esi, ebx
  000d4	75 1c		 jne	 SHORT $LN7@zipOpen3

; 885  :     {
; 886  :         ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);

  000d6	8b 44 24 3c	 mov	 eax, DWORD PTR _ziinit$[esp+65860]
  000da	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ziinit$[esp+65844]
  000de	50		 push	 eax
  000df	51		 push	 ecx
  000e0	ff 54 24 2c	 call	 DWORD PTR _ziinit$[esp+65844]
  000e4	83 c4 08	 add	 esp, 8
$LN15@zipOpen3:

; 887  :         return NULL;

  000e7	33 c0		 xor	 eax, eax

; 916  :         return (zipFile)zi;
; 917  :     }
; 918  : }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 0c 00	 ret	 12			; 0000000cH
$LN7@zipOpen3:

; 888  :     }
; 889  : 
; 890  :     /* now we add file in a zipfile */
; 891  : #    ifndef NO_ADDFILEINEXISTINGZIP
; 892  :     ziinit.globalcomment = NULL;

  000f2	33 c9		 xor	 ecx, ecx
  000f4	89 8c 24 10 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131608], ecx

; 893  :     if (append == APPEND_STATUS_ADDINZIP)

  000fb	83 ff 02	 cmp	 edi, 2
  000fe	75 12		 jne	 SHORT $LN14@zipOpen3

; 894  :     {
; 895  :       // Read and Cache Central Directory Records
; 896  :       err = LoadCentralDirectoryRecord(&ziinit);

  00100	8d 7c 24 10	 lea	 edi, DWORD PTR _ziinit$[esp+65816]
  00104	e8 00 00 00 00	 call	 _LoadCentralDirectoryRecord
  00109	8b 8c 24 10 01
	01 00		 mov	 ecx, DWORD PTR _ziinit$[esp+131608]
  00110	eb 02		 jmp	 SHORT $LN6@zipOpen3
$LN14@zipOpen3:
  00112	8b c1		 mov	 eax, ecx
$LN6@zipOpen3:

; 897  :     }
; 898  : 
; 899  :     if (globalcomment)

  00114	8b 55 10	 mov	 edx, DWORD PTR _globalcomment$[ebp]
  00117	3b d3		 cmp	 edx, ebx
  00119	74 02		 je	 SHORT $LN5@zipOpen3

; 900  :     {
; 901  :       *globalcomment = ziinit.globalcomment;

  0011b	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@zipOpen3:

; 902  :     }
; 903  : #    endif /* !NO_ADDFILEINEXISTINGZIP*/
; 904  : 
; 905  :     if (err != ZIP_OK)

  0011d	3b c3		 cmp	 eax, ebx
  0011f	74 21		 je	 SHORT $LN4@zipOpen3

; 906  :     {
; 907  : #    ifndef NO_ADDFILEINEXISTINGZIP
; 908  :         TRYFREE(ziinit.globalcomment);

  00121	3b cb		 cmp	 ecx, ebx
  00123	74 09		 je	 SHORT $LN3@zipOpen3
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 _free
  0012b	83 c4 04	 add	 esp, 4
$LN3@zipOpen3:

; 909  : #    endif /* !NO_ADDFILEINEXISTINGZIP*/
; 910  :         TRYFREE(zi);

  0012e	56		 push	 esi
  0012f	e8 00 00 00 00	 call	 _free
  00134	83 c4 04	 add	 esp, 4

; 911  :         return NULL;

  00137	33 c0		 xor	 eax, eax

; 916  :         return (zipFile)zi;
; 917  :     }
; 918  : }

  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 0c 00	 ret	 12			; 0000000cH
$LN4@zipOpen3:

; 912  :     }
; 913  :     else
; 914  :     {
; 915  :         *zi = ziinit;

  00142	68 08 01 01 00	 push	 65800			; 00010108H
  00147	8d 54 24 14	 lea	 edx, DWORD PTR _ziinit$[esp+65820]
  0014b	52		 push	 edx
  0014c	56		 push	 esi
  0014d	e8 00 00 00 00	 call	 _memcpy
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH

; 916  :         return (zipFile)zi;
; 917  :     }
; 918  : }

  00155	5f		 pop	 edi
  00156	8b c6		 mov	 eax, esi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH
_zipOpen3@16 ENDP
PUBLIC	_zipCloseFileInZip@4
; Function compile flags: /Ogtp
;	COMDAT _zipCloseFileInZip@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_zipCloseFileInZip@4 PROC				; COMDAT

; 1751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1752 :     return zipCloseFileInZipRaw (file,0,0);

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _zipCloseFileInZipRaw@12

; 1753 : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_zipCloseFileInZip@4 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip4_64@76
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip4_64@76
_TEXT	SEGMENT
_size_comment$ = -20					; size = 4
tv878 = -16						; size = 4
_size_filename$ = -16					; size = 4
_bufHead$83356 = -12					; size = 12
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_versionMadeBy$ = 72					; size = 4
_flagBase$ = 76						; size = 4
_zip64$ = 80						; size = 4
_zipOpenNewFileInZip4_64@76 PROC			; COMDAT

; 1062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx

; 1063 :     zip64_internal* zi;
; 1064 :     uInt size_filename;
; 1065 :     uInt size_comment;
; 1066 :     uInt i;
; 1067 :     int err = ZIP_OK;
; 1068 : 
; 1069 : #    ifdef NOCRYPT
; 1070 :     (crcForCrypting);
; 1071 :     if (password != NULL)
; 1072 :         return ZIP_PARAMERROR;
; 1073 : #    endif
; 1074 : 
; 1075 :     if (file == NULL)

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _file$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 ff		 xor	 edi, edi
  00011	3b df		 cmp	 ebx, edi
  00013	75 0e		 jne	 SHORT $LN41@zipOpenNew
$LN64@zipOpenNew:

; 1076 :         return ZIP_PARAMERROR;

  00015	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1263 : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 4c 00	 ret	 76			; 0000004cH
$LN41@zipOpenNew:

; 1077 : 
; 1078 : #ifdef HAVE_BZIP2
; 1079 :     if ((method!=0) && (method!=Z_DEFLATED) && (method!=Z_BZIP2ED))
; 1080 :       return ZIP_PARAMERROR;
; 1081 : #else
; 1082 :     if ((method!=0) && (method!=Z_DEFLATED))

  00023	8b 45 28	 mov	 eax, DWORD PTR _method$[ebp]
  00026	3b c7		 cmp	 eax, edi
  00028	74 05		 je	 SHORT $LN40@zipOpenNew
  0002a	83 f8 08	 cmp	 eax, 8

; 1083 :       return ZIP_PARAMERROR;

  0002d	75 e6		 jne	 SHORT $LN64@zipOpenNew
$LN40@zipOpenNew:

; 1084 : #endif
; 1085 : 
; 1086 :     zi = (zip64_internal*)file;
; 1087 : 
; 1088 :     if (zi->in_opened_file_inzip == 1)

  0002f	83 7b 38 01	 cmp	 DWORD PTR [ebx+56], 1
  00033	75 0e		 jne	 SHORT $LN38@zipOpenNew

; 1089 :     {
; 1090 :         err = zipCloseFileInZip (file);

  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 _zipCloseFileInZip@4

; 1091 :         if (err != ZIP_OK)

  0003b	3b c7		 cmp	 eax, edi

; 1092 :             return err;

  0003d	0f 85 7d 04 00
	00		 jne	 $LN42@zipOpenNew
$LN38@zipOpenNew:

; 1093 :     }
; 1094 : 
; 1095 :     if (filename==NULL)

  00043	39 7d 0c	 cmp	 DWORD PTR _filename$[ebp], edi
  00046	75 07		 jne	 SHORT $LN37@zipOpenNew

; 1096 :         filename="-";

  00048	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _filename$[ebp], OFFSET ??_C@_01JOAMLHOP@?9?$AA@
$LN37@zipOpenNew:

; 1097 : 
; 1098 :     if (comment==NULL)

  0004f	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  00052	3b c7		 cmp	 eax, edi
  00054	75 06		 jne	 SHORT $LN36@zipOpenNew

; 1099 :         size_comment = 0;

  00056	89 7c 24 0c	 mov	 DWORD PTR _size_comment$[esp+32], edi

; 1100 :     else

  0005a	eb 11		 jmp	 SHORT $LN35@zipOpenNew
$LN36@zipOpenNew:

; 1101 :         size_comment = (uInt)strlen(comment);

  0005c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0005f	90		 npad	 1
$LL52@zipOpenNew:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL52@zipOpenNew
  00067	2b c2		 sub	 eax, edx
  00069	89 44 24 0c	 mov	 DWORD PTR _size_comment$[esp+32], eax
$LN35@zipOpenNew:

; 1102 : 
; 1103 :     size_filename = (uInt)strlen(filename);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00070	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL53@zipOpenNew:
  00073	8a 08		 mov	 cl, BYTE PTR [eax]
  00075	40		 inc	 eax
  00076	84 c9		 test	 cl, cl
  00078	75 f9		 jne	 SHORT $LL53@zipOpenNew
  0007a	2b c2		 sub	 eax, edx

; 1104 : 
; 1105 :     if (zipfi == NULL)

  0007c	8b 55 10	 mov	 edx, DWORD PTR _zipfi$[ebp]
  0007f	8b f0		 mov	 esi, eax
  00081	89 74 24 10	 mov	 DWORD PTR _size_filename$[esp+32], esi
  00085	3b d7		 cmp	 edx, edi
  00087	75 08		 jne	 SHORT $LN34@zipOpenNew

; 1106 :         zi->ci.dosDate = 0;

  00089	89 bb a4 00 01
	00		 mov	 DWORD PTR [ebx+65700], edi

; 1107 :     else

  0008f	eb 12		 jmp	 SHORT $LN31@zipOpenNew
$LN34@zipOpenNew:

; 1108 :     {
; 1109 :         if (zipfi->dosDate != 0)

  00091	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00094	3b c7		 cmp	 eax, edi

; 1110 :             zi->ci.dosDate = zipfi->dosDate;
; 1111 :         else

  00096	75 05		 jne	 SHORT $LN61@zipOpenNew

; 1112 :           zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);

  00098	e8 00 00 00 00	 call	 _zip64local_TmzDateToDosDate
$LN61@zipOpenNew:
  0009d	89 83 a4 00 01
	00		 mov	 DWORD PTR [ebx+65700], eax
$LN31@zipOpenNew:

; 1113 :     }
; 1114 : 
; 1115 :     zi->ci.flag = flagBase;
; 1116 :     if ((level==8) || (level==9))

  000a3	8b 4d 2c	 mov	 ecx, DWORD PTR _level$[ebp]
  000a6	8b 45 4c	 mov	 eax, DWORD PTR _flagBase$[ebp]
  000a9	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
  000af	83 f9 08	 cmp	 ecx, 8
  000b2	74 05		 je	 SHORT $LN29@zipOpenNew
  000b4	83 f9 09	 cmp	 ecx, 9
  000b7	75 09		 jne	 SHORT $LN30@zipOpenNew
$LN29@zipOpenNew:

; 1117 :       zi->ci.flag |= 2;

  000b9	83 c8 02	 or	 eax, 2
  000bc	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
$LN30@zipOpenNew:

; 1118 :     if (level==2)

  000c2	83 f9 02	 cmp	 ecx, 2
  000c5	75 09		 jne	 SHORT $LN28@zipOpenNew

; 1119 :       zi->ci.flag |= 4;

  000c7	83 8b 98 00 00
	00 04		 or	 DWORD PTR [ebx+152], 4

; 1120 :     if (level==1)

  000ce	eb 0c		 jmp	 SHORT $LN27@zipOpenNew
$LN28@zipOpenNew:
  000d0	83 f9 01	 cmp	 ecx, 1
  000d3	75 07		 jne	 SHORT $LN27@zipOpenNew

; 1121 :       zi->ci.flag |= 6;

  000d5	83 8b 98 00 00
	00 06		 or	 DWORD PTR [ebx+152], 6
$LN27@zipOpenNew:

; 1122 :     if (password != NULL)

  000dc	39 7d 40	 cmp	 DWORD PTR _password$[ebp], edi
  000df	74 07		 je	 SHORT $LN26@zipOpenNew

; 1123 :       zi->ci.flag |= 1;

  000e1	83 8b 98 00 00
	00 01		 or	 DWORD PTR [ebx+152], 1
$LN26@zipOpenNew:

; 1124 : 
; 1125 :     zi->ci.crc32 = 0;
; 1126 :     zi->ci.method = method;

  000e8	8b 45 28	 mov	 eax, DWORD PTR _method$[ebp]

; 1127 :     zi->ci.encrypt = 0;
; 1128 :     zi->ci.stream_initialised = 0;
; 1129 :     zi->ci.pos_in_buffered_data = 0;
; 1130 :     zi->ci.raw = raw;

  000eb	8b 4d 30	 mov	 ecx, DWORD PTR _raw$[ebp]
  000ee	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax
  000f4	89 8b a0 00 00
	00		 mov	 DWORD PTR [ebx+160], ecx

; 1131 :     zi->ci.pos_local_header = ZTELL64(zi->z_filefunc,zi->filestream);

  000fa	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  000fd	8b c3		 mov	 eax, ebx
  000ff	89 bb a8 00 01
	00		 mov	 DWORD PTR [ebx+65704], edi
  00105	89 bb ac 00 01
	00		 mov	 DWORD PTR [ebx+65708], edi
  0010b	89 7b 78	 mov	 DWORD PTR [ebx+120], edi
  0010e	89 7b 7c	 mov	 DWORD PTR [ebx+124], edi
  00111	e8 00 00 00 00	 call	 _call_ztell64
  00116	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  0011c	89 93 84 00 00
	00		 mov	 DWORD PTR [ebx+132], edx

; 1132 : 
; 1133 :     zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;

  00122	8b 54 24 0c	 mov	 edx, DWORD PTR _size_comment$[esp+32]
  00126	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00129	8b 75 20	 mov	 esi, DWORD PTR _size_extrafield_global$[ebp]
  0012c	8d 44 30 2e	 lea	 eax, DWORD PTR [eax+esi+46]
  00130	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax

; 1134 :     zi->ci.size_centralExtraFree = 32; // Extra space we have reserved in case we need to add ZIP64 extra info data
; 1135 : 
; 1136 :     zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);

  00136	83 c0 20	 add	 eax, 32			; 00000020H
  00139	50		 push	 eax
  0013a	c7 83 94 00 00
	00 20 00 00 00	 mov	 DWORD PTR [ebx+148], 32	; 00000020H
  00144	e8 00 00 00 00	 call	 _malloc
  00149	83 c4 04	 add	 esp, 4

; 1137 : 
; 1138 :     zi->ci.size_centralExtra = size_extrafield_global;
; 1139 :     zip64local_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);

  0014c	57		 push	 edi
  0014d	89 b3 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], esi
  00153	68 50 4b 01 02	 push	 33639248		; 02014b50H
  00158	be 04 00 00 00	 mov	 esi, 4
  0015d	8b f8		 mov	 edi, eax
  0015f	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00165	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1140 :     /* version info */
; 1141 :     zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)versionMadeBy,2);

  0016a	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00170	8b 4d 48	 mov	 ecx, DWORD PTR _versionMadeBy$[ebp]
  00173	6a 00		 push	 0
  00175	03 fe		 add	 edi, esi
  00177	51		 push	 ecx
  00178	be 02 00 00 00	 mov	 esi, 2
  0017d	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1142 :     zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);

  00182	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00188	6a 00		 push	 0
  0018a	6a 14		 push	 20			; 00000014H
  0018c	83 c7 06	 add	 edi, 6
  0018f	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1143 :     zip64local_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);

  00194	8b 93 98 00 00
	00		 mov	 edx, DWORD PTR [ebx+152]
  0019a	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001a0	6a 00		 push	 0
  001a2	52		 push	 edx
  001a3	83 c7 08	 add	 edi, 8
  001a6	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1144 :     zip64local_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);

  001ab	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  001b1	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001b7	6a 00		 push	 0
  001b9	50		 push	 eax
  001ba	83 c7 0a	 add	 edi, 10			; 0000000aH
  001bd	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1145 :     zip64local_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);

  001c2	8b 8b a4 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65700]
  001c8	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001ce	6a 00		 push	 0
  001d0	51		 push	 ecx
  001d1	83 c7 0c	 add	 edi, 12			; 0000000cH
  001d4	be 04 00 00 00	 mov	 esi, 4
  001d9	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1146 :     zip64local_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/

  001de	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001e4	6a 00		 push	 0
  001e6	6a 00		 push	 0
  001e8	83 c7 10	 add	 edi, 16			; 00000010H
  001eb	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1147 :     zip64local_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/

  001f0	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  001f6	6a 00		 push	 0
  001f8	6a 00		 push	 0
  001fa	83 c7 14	 add	 edi, 20			; 00000014H
  001fd	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1148 :     zip64local_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/

  00202	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00208	83 c4 40	 add	 esp, 64			; 00000040H
  0020b	6a 00		 push	 0
  0020d	6a 00		 push	 0
  0020f	83 c7 18	 add	 edi, 24			; 00000018H
  00212	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1149 :     zip64local_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);

  00217	8b 54 24 18	 mov	 edx, DWORD PTR _size_filename$[esp+40]
  0021b	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00221	6a 00		 push	 0
  00223	52		 push	 edx
  00224	83 c7 1c	 add	 edi, 28			; 0000001cH
  00227	be 02 00 00 00	 mov	 esi, 2
  0022c	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1150 :     zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);

  00231	8b 45 20	 mov	 eax, DWORD PTR _size_extrafield_global$[ebp]
  00234	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  0023a	6a 00		 push	 0
  0023c	50		 push	 eax
  0023d	83 c7 1e	 add	 edi, 30			; 0000001eH
  00240	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1151 :     zip64local_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);

  00245	8b 4c 24 24	 mov	 ecx, DWORD PTR _size_comment$[esp+56]
  00249	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  0024f	6a 00		 push	 0
  00251	51		 push	 ecx
  00252	83 c7 20	 add	 edi, 32			; 00000020H
  00255	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1152 :     zip64local_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/

  0025a	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00260	6a 00		 push	 0
  00262	6a 00		 push	 0
  00264	83 c7 22	 add	 edi, 34			; 00000022H
  00267	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1153 : 
; 1154 :     if (zipfi==NULL)
; 1155 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);

  0026c	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  00272	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  00275	83 c4 28	 add	 esp, 40			; 00000028H
  00278	83 c7 24	 add	 edi, 36			; 00000024H
  0027b	6a 00		 push	 0
  0027d	85 c0		 test	 eax, eax
  0027f	75 0f		 jne	 SHORT $LN25@zipOpenNew
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  00287	83 c4 08	 add	 esp, 8

; 1158 : 
; 1159 :     if (zipfi==NULL)
; 1160 :         zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);

  0028a	6a 00		 push	 0
  0028c	6a 00		 push	 0

; 1161 :     else

  0028e	eb 15		 jmp	 SHORT $LN62@zipOpenNew
$LN25@zipOpenNew:

; 1156 :     else
; 1157 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);

  00290	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00293	52		 push	 edx
  00294	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1162 :         zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);

  00299	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  0029c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0029f	83 c4 08	 add	 esp, 8
  002a2	6a 00		 push	 0
  002a4	51		 push	 ecx
$LN62@zipOpenNew:
  002a5	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  002ab	be 04 00 00 00	 mov	 esi, 4
  002b0	83 c7 26	 add	 edi, 38			; 00000026H
  002b3	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002b8	83 c4 08	 add	 esp, 8

; 1163 : 
; 1164 :     if(zi->ci.pos_local_header >= 0xffffffff)

  002bb	83 bb 84 00 00
	00 00		 cmp	 DWORD PTR [ebx+132], 0
  002c2	77 09		 ja	 SHORT $LN54@zipOpenNew
  002c4	83 bb 80 00 00
	00 ff		 cmp	 DWORD PTR [ebx+128], -1
  002cb	72 06		 jb	 SHORT $LN21@zipOpenNew
$LN54@zipOpenNew:

; 1165 :       zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);

  002cd	6a 00		 push	 0
  002cf	6a ff		 push	 -1

; 1166 :     else

  002d1	eb 16		 jmp	 SHORT $LN63@zipOpenNew
$LN21@zipOpenNew:

; 1167 :       zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset,4);

  002d3	8b 93 80 00 00
	00		 mov	 edx, DWORD PTR [ebx+128]
  002d9	33 c0		 xor	 eax, eax
  002db	2b 93 f0 00 01
	00		 sub	 edx, DWORD PTR [ebx+65776]
  002e1	1b 83 f4 00 01
	00		 sbb	 eax, DWORD PTR [ebx+65780]
  002e7	50		 push	 eax
  002e8	52		 push	 edx
$LN63@zipOpenNew:
  002e9	8b bb 88 00 00
	00		 mov	 edi, DWORD PTR [ebx+136]
  002ef	be 04 00 00 00	 mov	 esi, 4
  002f4	83 c7 2a	 add	 edi, 42			; 0000002aH
  002f7	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1168 : 
; 1169 :     for (i=0;i<size_filename;i++)

  002fc	8b 74 24 18	 mov	 esi, DWORD PTR _size_filename$[esp+40]
  00300	33 c9		 xor	 ecx, ecx
  00302	83 c4 08	 add	 esp, 8
  00305	33 c0		 xor	 eax, eax
  00307	3b f1		 cmp	 esi, ecx
  00309	76 22		 jbe	 SHORT $LN17@zipOpenNew
  0030b	eb 03 8d 49 00	 npad	 5
$LL19@zipOpenNew:

; 1170 :         *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);

  00310	8b 7d 0c	 mov	 edi, DWORD PTR _filename$[ebp]
  00313	8b 93 88 00 00
	00		 mov	 edx, DWORD PTR [ebx+136]
  00319	89 4c 24 10	 mov	 DWORD PTR tv878[esp+32], ecx
  0031d	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00320	88 4c 02 2e	 mov	 BYTE PTR [edx+eax+46], cl
  00324	8b 4c 24 10	 mov	 ecx, DWORD PTR tv878[esp+32]
  00328	40		 inc	 eax
  00329	3b c6		 cmp	 eax, esi
  0032b	72 e3		 jb	 SHORT $LL19@zipOpenNew
$LN17@zipOpenNew:

; 1171 : 
; 1172 :     for (i=0;i<size_extrafield_global;i++)

  0032d	8b 7d 20	 mov	 edi, DWORD PTR _size_extrafield_global$[ebp]
  00330	33 c0		 xor	 eax, eax
  00332	3b f9		 cmp	 edi, ecx
  00334	76 19		 jbe	 SHORT $LN14@zipOpenNew
$LN16@zipOpenNew:

; 1173 :         *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
; 1174 :               *(((const char*)extrafield_global)+i);

  00336	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  0033c	8b 55 1c	 mov	 edx, DWORD PTR _extrafield_global$[ebp]
  0033f	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  00342	03 c8		 add	 ecx, eax
  00344	40		 inc	 eax
  00345	88 54 31 2e	 mov	 BYTE PTR [ecx+esi+46], dl
  00349	3b c7		 cmp	 eax, edi
  0034b	72 e9		 jb	 SHORT $LN16@zipOpenNew

; 1171 : 
; 1172 :     for (i=0;i<size_extrafield_global;i++)

  0034d	33 c9		 xor	 ecx, ecx
$LN14@zipOpenNew:

; 1175 : 
; 1176 :     for (i=0;i<size_comment;i++)

  0034f	33 c0		 xor	 eax, eax
  00351	39 4c 24 0c	 cmp	 DWORD PTR _size_comment$[esp+32], ecx
  00355	76 26		 jbe	 SHORT $LN11@zipOpenNew
  00357	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL13@zipOpenNew:

; 1177 :         *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
; 1178 :               size_extrafield_global+i) = *(comment+i);

  00360	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  00366	8b 55 24	 mov	 edx, DWORD PTR _comment$[ebp]
  00369	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  0036c	03 c8		 add	 ecx, eax
  0036e	03 ce		 add	 ecx, esi
  00370	40		 inc	 eax
  00371	88 54 39 2e	 mov	 BYTE PTR [ecx+edi+46], dl
  00375	3b 44 24 0c	 cmp	 eax, DWORD PTR _size_comment$[esp+32]
  00379	72 e5		 jb	 SHORT $LL13@zipOpenNew

; 1175 : 
; 1176 :     for (i=0;i<size_comment;i++)

  0037b	33 c9		 xor	 ecx, ecx
$LN11@zipOpenNew:

; 1179 :     if (zi->ci.central_header == NULL)

  0037d	39 8b 88 00 00
	00		 cmp	 DWORD PTR [ebx+136], ecx
  00383	75 0e		 jne	 SHORT $LN10@zipOpenNew

; 1180 :         return ZIP_INTERNALERROR;

  00385	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H

; 1263 : }

  0038a	5f		 pop	 edi
  0038b	5e		 pop	 esi
  0038c	5b		 pop	 ebx
  0038d	8b e5		 mov	 esp, ebp
  0038f	5d		 pop	 ebp
  00390	c2 4c 00	 ret	 76			; 0000004cH
$LN10@zipOpenNew:

; 1181 : 
; 1182 :     zi->ci.zip64 = zip64;

  00393	8b 45 50	 mov	 eax, DWORD PTR _zip64$[ebp]

; 1183 :     zi->ci.totalCompressedData = 0;
; 1184 :     zi->ci.totalUncompressedData = 0;
; 1185 :     zi->ci.pos_zip64extrainfo = 0;
; 1186 : 
; 1187 :     err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);

  00396	8b 55 18	 mov	 edx, DWORD PTR _size_extrafield_local$[ebp]
  00399	89 8b c0 00 01
	00		 mov	 DWORD PTR [ebx+65728], ecx
  0039f	89 8b c4 00 01
	00		 mov	 DWORD PTR [ebx+65732], ecx
  003a5	89 8b c8 00 01
	00		 mov	 DWORD PTR [ebx+65736], ecx
  003ab	89 8b cc 00 01
	00		 mov	 DWORD PTR [ebx+65740], ecx
  003b1	89 8b b8 00 01
	00		 mov	 DWORD PTR [ebx+65720], ecx
  003b7	89 8b bc 00 01
	00		 mov	 DWORD PTR [ebx+65724], ecx
  003bd	8b 4d 14	 mov	 ecx, DWORD PTR _extrafield_local$[ebp]
  003c0	51		 push	 ecx
  003c1	89 83 b0 00 01
	00		 mov	 DWORD PTR [ebx+65712], eax
  003c7	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  003ca	52		 push	 edx
  003cb	50		 push	 eax
  003cc	8b c3		 mov	 eax, ebx
  003ce	e8 00 00 00 00	 call	 _Write_LocalFileHeader

; 1188 : 
; 1189 : #ifdef HAVE_BZIP2
; 1190 :     zi->ci.bstream.avail_in = (uInt)0;
; 1191 :     zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1192 :     zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1193 :     zi->ci.bstream.total_in_hi32 = 0;
; 1194 :     zi->ci.bstream.total_in_lo32 = 0;
; 1195 :     zi->ci.bstream.total_out_hi32 = 0;
; 1196 :     zi->ci.bstream.total_out_lo32 = 0;
; 1197 : #endif
; 1198 : 
; 1199 :     zi->ci.stream.avail_in = (uInt)0;

  003d3	33 f6		 xor	 esi, esi
  003d5	8b f8		 mov	 edi, eax
  003d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1200 :     zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
; 1201 :     zi->ci.stream.next_out = zi->ci.buffered_data;

  003da	8d 8b a4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+164]
  003e0	89 73 44	 mov	 DWORD PTR [ebx+68], esi
  003e3	c7 43 50 00 00
	01 00		 mov	 DWORD PTR [ebx+80], 65536 ; 00010000H
  003ea	89 4b 4c	 mov	 DWORD PTR [ebx+76], ecx

; 1202 :     zi->ci.stream.total_in = 0;

  003ed	89 73 48	 mov	 DWORD PTR [ebx+72], esi

; 1203 :     zi->ci.stream.total_out = 0;

  003f0	89 73 54	 mov	 DWORD PTR [ebx+84], esi

; 1204 :     zi->ci.stream.data_type = Z_BINARY;

  003f3	89 73 6c	 mov	 DWORD PTR [ebx+108], esi

; 1205 : 
; 1206 : #ifdef HAVE_BZIP2
; 1207 :     if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1208 : #else
; 1209 :     if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  003f6	3b fe		 cmp	 edi, esi
  003f8	75 4f		 jne	 SHORT $LN6@zipOpenNew
  003fa	83 bb 9c 00 00
	00 08		 cmp	 DWORD PTR [ebx+156], 8
  00401	75 46		 jne	 SHORT $LN6@zipOpenNew
  00403	39 b3 a0 00 00
	00		 cmp	 DWORD PTR [ebx+160], esi
  00409	75 3e		 jne	 SHORT $LN6@zipOpenNew

; 1210 : #endif
; 1211 :     {
; 1212 :         if(zi->ci.method == Z_DEFLATED)
; 1213 :         {
; 1214 :           zi->ci.stream.zalloc = (alloc_func)0;
; 1215 :           zi->ci.stream.zfree = (free_func)0;
; 1216 :           zi->ci.stream.opaque = (voidpf)0;
; 1217 : 
; 1218 :           if (windowBits>0)

  0040b	8b 45 34	 mov	 eax, DWORD PTR _windowBits$[ebp]
  0040e	89 73 60	 mov	 DWORD PTR [ebx+96], esi
  00411	89 73 64	 mov	 DWORD PTR [ebx+100], esi
  00414	89 73 68	 mov	 DWORD PTR [ebx+104], esi
  00417	3b c6		 cmp	 eax, esi
  00419	7e 02		 jle	 SHORT $LN7@zipOpenNew

; 1219 :               windowBits = -windowBits;

  0041b	f7 d8		 neg	 eax
$LN7@zipOpenNew:

; 1220 : 
; 1221 :           err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);

  0041d	8b 55 3c	 mov	 edx, DWORD PTR _strategy$[ebp]
  00420	8b 4d 38	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  00423	6a 38		 push	 56			; 00000038H
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  0042a	52		 push	 edx
  0042b	8b 55 2c	 mov	 edx, DWORD PTR _level$[ebp]
  0042e	51		 push	 ecx
  0042f	50		 push	 eax
  00430	6a 08		 push	 8
  00432	52		 push	 edx
  00433	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 _deflateInit2_@32
  0043c	8b f8		 mov	 edi, eax

; 1222 : 
; 1223 :           if (err==Z_OK)

  0043e	3b fe		 cmp	 edi, esi
  00440	75 07		 jne	 SHORT $LN6@zipOpenNew

; 1224 :               zi->ci.stream_initialised = Z_DEFLATED;

  00442	c7 43 78 08 00
	00 00		 mov	 DWORD PTR [ebx+120], 8
$LN6@zipOpenNew:

; 1225 :         }
; 1226 :         else if(zi->ci.method == Z_BZIP2ED)
; 1227 :         {
; 1228 : #ifdef HAVE_BZIP2
; 1229 :             // Init BZip stuff here
; 1230 :           zi->ci.bstream.bzalloc = 0;
; 1231 :           zi->ci.bstream.bzfree = 0;
; 1232 :           zi->ci.bstream.opaque = (voidpf)0;
; 1233 : 
; 1234 :           err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0,35);
; 1235 :           if(err == BZ_OK)
; 1236 :             zi->ci.stream_initialised = Z_BZIP2ED;
; 1237 : #endif
; 1238 :         }
; 1239 : 
; 1240 :     }
; 1241 : 
; 1242 : #    ifndef NOCRYPT
; 1243 :     zi->ci.crypt_header_size = 0;

  00449	89 b3 e0 00 01
	00		 mov	 DWORD PTR [ebx+65760], esi

; 1244 :     if ((err==Z_OK) && (password != NULL))

  0044f	3b fe		 cmp	 edi, esi
  00451	75 6b		 jne	 SHORT $LN1@zipOpenNew
  00453	8b 55 40	 mov	 edx, DWORD PTR _password$[ebp]
  00456	3b d6		 cmp	 edx, esi
  00458	74 5d		 je	 SHORT $LN51@zipOpenNew

; 1245 :     {
; 1246 :         unsigned char bufHead[RAND_HEAD_LEN];
; 1247 :         unsigned int sizeHead;
; 1248 :         zi->ci.encrypt = 1;

  0045a	c7 83 ac 00 01
	00 01 00 00 00	 mov	 DWORD PTR [ebx+65708], 1

; 1249 :         zi->ci.pcrc_32_tab = get_crc_table();

  00464	e8 00 00 00 00	 call	 _get_crc_table@0

; 1250 :         /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
; 1251 : 
; 1252 :         sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);

  00469	8b 4d 44	 mov	 ecx, DWORD PTR _crcForCrypting$[ebp]
  0046c	51		 push	 ecx
  0046d	8d 74 24 18	 lea	 esi, DWORD PTR _bufHead$83356[esp+36]
  00471	56		 push	 esi
  00472	8d 8b d0 00 01
	00		 lea	 ecx, DWORD PTR [ebx+65744]
  00478	52		 push	 edx
  00479	89 83 dc 00 01
	00		 mov	 DWORD PTR [ebx+65756], eax
  0047f	e8 00 00 00 00	 call	 _crypthead

; 1253 :         zi->ci.crypt_header_size = sizeHead;
; 1254 : 
; 1255 :         if (ZWRITE64(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)

  00484	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00487	83 c4 0c	 add	 esp, 12			; 0000000cH
  0048a	8b f0		 mov	 esi, eax
  0048c	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0048f	56		 push	 esi
  00490	8d 54 24 18	 lea	 edx, DWORD PTR _bufHead$83356[esp+36]
  00494	52		 push	 edx
  00495	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00498	50		 push	 eax
  00499	51		 push	 ecx
  0049a	89 b3 e0 00 01
	00		 mov	 DWORD PTR [ebx+65760], esi
  004a0	ff d2		 call	 edx
  004a2	83 c4 10	 add	 esp, 16			; 00000010H
  004a5	3b c6		 cmp	 eax, esi
  004a7	74 0e		 je	 SHORT $LN51@zipOpenNew

; 1256 :                 err = ZIP_ERRNO;

  004a9	83 cf ff	 or	 edi, -1

; 1262 :     return err;

  004ac	8b c7		 mov	 eax, edi

; 1263 : }

  004ae	5f		 pop	 edi
  004af	5e		 pop	 esi
  004b0	5b		 pop	 ebx
  004b1	8b e5		 mov	 esp, ebp
  004b3	5d		 pop	 ebp
  004b4	c2 4c 00	 ret	 76			; 0000004cH
$LN51@zipOpenNew:

; 1257 :     }
; 1258 : #    endif
; 1259 : 
; 1260 :     if (err==Z_OK)
; 1261 :         zi->in_opened_file_inzip = 1;

  004b7	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [ebx+56], 1
$LN1@zipOpenNew:

; 1262 :     return err;

  004be	8b c7		 mov	 eax, edi
$LN42@zipOpenNew:

; 1263 : }

  004c0	5f		 pop	 edi
  004c1	5e		 pop	 esi
  004c2	5b		 pop	 ebx
  004c3	8b e5		 mov	 esp, ebp
  004c5	5d		 pop	 ebp
  004c6	c2 4c 00	 ret	 76			; 0000004cH
_zipOpenNewFileInZip4_64@76 ENDP
_TEXT	ENDS
PUBLIC	_zipOpen64@8
; Function compile flags: /Ogtp
;	COMDAT _zipOpen64@8
_TEXT	SEGMENT
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_zipOpen64@8 PROC					; COMDAT

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 955  :     return zipOpen3(pathname,append,NULL,NULL);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _append$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00009	6a 00		 push	 0
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 _zipOpen3@16

; 956  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_zipOpen64@8 ENDP
_TEXT	ENDS
PUBLIC	_zipOpen@8
; Function compile flags: /Ogtp
;	COMDAT _zipOpen@8
_TEXT	SEGMENT
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_zipOpen@8 PROC						; COMDAT

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 950  :     return zipOpen3((const void*)pathname,append,NULL,NULL);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _append$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00009	6a 00		 push	 0
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 _zipOpen3@16

; 951  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_zipOpen@8 ENDP
_TEXT	ENDS
PUBLIC	_zipOpen2_64@16
; Function compile flags: /Ogtp
;	COMDAT _zipOpen2_64@16
_TEXT	SEGMENT
_zlib_filefunc64_32_def_fill$83154 = -44		; size = 44
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_globalcomment$ = 16					; size = 4
_pzlib_filefunc_def$ = 20				; size = 4
_zipOpen2_64@16 PROC					; COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 938  :         zlib_filefunc64_32_def_fill.ztell32_file = NULL;
; 939  :         zlib_filefunc64_32_def_fill.zseek32_file = NULL;
; 940  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);

  00006	8b 55 08	 mov	 edx, DWORD PTR _pathname$[ebp]
  00009	83 ec 30	 sub	 esp, 48			; 00000030H
  0000c	56		 push	 esi
  0000d	8b 75 14	 mov	 esi, DWORD PTR _pzlib_filefunc_def$[ebp]
  00010	33 c0		 xor	 eax, eax
  00012	57		 push	 edi
  00013	3b f0		 cmp	 esi, eax
  00015	74 2d		 je	 SHORT $LN2@zipOpen2_6

; 934  :     if (pzlib_filefunc_def != NULL)
; 935  :     {
; 936  :         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
; 937  :         zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;

  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	8d 7c 24 0c	 lea	 edi, DWORD PTR _zlib_filefunc64_32_def_fill$83154[esp+56]
  00020	f3 a5		 rep movsd

; 938  :         zlib_filefunc64_32_def_fill.ztell32_file = NULL;
; 939  :         zlib_filefunc64_32_def_fill.zseek32_file = NULL;
; 940  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _append$[ebp]
  00025	89 44 24 30	 mov	 DWORD PTR _zlib_filefunc64_32_def_fill$83154[esp+92], eax
  00029	89 44 24 34	 mov	 DWORD PTR _zlib_filefunc64_32_def_fill$83154[esp+96], eax
  0002d	8b 45 10	 mov	 eax, DWORD PTR _globalcomment$[ebp]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 4c 24 14	 lea	 ecx, DWORD PTR _zlib_filefunc64_32_def_fill$83154[esp+64]

; 941  :     }
; 942  :     else
; 943  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _zipOpen3@16

; 944  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 10 00	 ret	 16			; 00000010H
$LN2@zipOpen2_6:

; 941  :     }
; 942  :     else
; 943  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00044	8b 45 10	 mov	 eax, DWORD PTR _globalcomment$[ebp]
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _append$[ebp]
  0004a	50		 push	 eax
  0004b	51		 push	 ecx
  0004c	33 c9		 xor	 ecx, ecx
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _zipOpen3@16

; 944  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 10 00	 ret	 16			; 00000010H
_zipOpen2_64@16 ENDP
_TEXT	ENDS
PUBLIC	_zipOpen2@16
; Function compile flags: /Ogtp
;	COMDAT _zipOpen2@16
_TEXT	SEGMENT
_zlib_filefunc64_32_def_fill$83140 = -44		; size = 44
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_globalcomment$ = 16					; size = 4
_pzlib_filefunc32_def$ = 20				; size = 4
_zipOpen2@16 PROC					; COMDAT

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 922  :     if (pzlib_filefunc32_def != NULL)

  00006	8b 4d 14	 mov	 ecx, DWORD PTR _pzlib_filefunc32_def$[ebp]
  00009	83 ec 30	 sub	 esp, 48			; 00000030H
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 24		 je	 SHORT $LN2@zipOpen2

; 923  :     {
; 924  :         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
; 925  :         fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);

  00010	8d 44 24 04	 lea	 eax, DWORD PTR _zlib_filefunc64_32_def_fill$83140[esp+48]
  00014	e8 00 00 00 00	 call	 _fill_zlib_filefunc64_32_def_from_filefunc32

; 926  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);

  00019	8b 45 10	 mov	 eax, DWORD PTR _globalcomment$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _append$[ebp]

; 927  :     }
; 928  :     else
; 929  :         return zipOpen3(pathname, append, globalcomment, NULL);

  0001f	8b 55 08	 mov	 edx, DWORD PTR _pathname$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	8d 4c 24 0c	 lea	 ecx, DWORD PTR _zlib_filefunc64_32_def_fill$83140[esp+56]
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 _zipOpen3@16

; 930  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 10 00	 ret	 16			; 00000010H
$LN2@zipOpen2:

; 927  :     }
; 928  :     else
; 929  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00034	8b 45 10	 mov	 eax, DWORD PTR _globalcomment$[ebp]
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _append$[ebp]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _pathname$[ebp]
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	33 c9		 xor	 ecx, ecx
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _zipOpen3@16

; 930  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 10 00	 ret	 16			; 00000010H
_zipOpen2@16 ENDP
PUBLIC	_zipClose@8
; Function compile flags: /Ogtp
;	COMDAT _zipClose@8
_TEXT	SEGMENT
_size_centraldir$ = -20					; size = 4
_centraldir_pos_inzip$ = -16				; size = 8
_Zip64EOCDpos$83808 = -8				; size = 8
_file$ = 8						; size = 4
_global_comment$ = 12					; size = 4
_zipClose@8 PROC					; COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1884 :     zip64_internal* zi;
; 1885 :     int err = 0;
; 1886 :     uLong size_centraldir = 0;
; 1887 :     ZPOS64_T centraldir_pos_inzip;
; 1888 :     ZPOS64_T pos;
; 1889 : 
; 1890 :     if (file == NULL)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  0000f	33 db		 xor	 ebx, ebx
  00011	89 5c 24 0c	 mov	 DWORD PTR _size_centraldir$[esp+32], ebx
  00015	85 ff		 test	 edi, edi
  00017	75 0c		 jne	 SHORT $LN16@zipClose

; 1891 :         return ZIP_PARAMERROR;

  00019	8d 43 9a	 lea	 eax, DWORD PTR [ebx-102]

; 1947 : 
; 1948 :     return err;
; 1949 : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN16@zipClose:

; 1892 : 
; 1893 :     zi = (zip64_internal*)file;
; 1894 : 
; 1895 :     if (zi->in_opened_file_inzip == 1)

  00025	83 7f 38 01	 cmp	 DWORD PTR [edi+56], 1
  00029	75 08		 jne	 SHORT $LN15@zipClose

; 1896 :     {
; 1897 :         err = zipCloseFileInZip (file);

  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 _zipCloseFileInZip@4
  00031	8b d8		 mov	 ebx, eax
$LN15@zipClose:

; 1898 :     }
; 1899 : 
; 1900 : #ifndef NO_ADDFILEINEXISTINGZIP
; 1901 :     if (global_comment==NULL)

  00033	83 7d 0c 00	 cmp	 DWORD PTR _global_comment$[ebp], 0
  00037	75 09		 jne	 SHORT $LN14@zipClose

; 1902 :         global_comment = zi->globalcomment;

  00039	8b 87 00 01 01
	00		 mov	 eax, DWORD PTR [edi+65792]
  0003f	89 45 0c	 mov	 DWORD PTR _global_comment$[ebp], eax
$LN14@zipClose:

; 1903 : #endif
; 1904 : 
; 1905 :     centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);

  00042	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00045	8b c7		 mov	 eax, edi
  00047	e8 00 00 00 00	 call	 _call_ztell64
  0004c	89 44 24 10	 mov	 DWORD PTR _centraldir_pos_inzip$[esp+32], eax
  00050	89 54 24 14	 mov	 DWORD PTR _centraldir_pos_inzip$[esp+36], edx

; 1906 : 
; 1907 :     if (err==ZIP_OK)

  00054	85 db		 test	 ebx, ebx
  00056	75 3d		 jne	 SHORT $LN11@zipClose

; 1908 :     {
; 1909 :         linkedlist_datablock_internal* ldi = zi->central_dir.first_block;

  00058	8b 77 30	 mov	 esi, DWORD PTR [edi+48]

; 1910 :         while (ldi!=NULL)

  0005b	85 f6		 test	 esi, esi
  0005d	74 36		 je	 SHORT $LN11@zipClose
  0005f	90		 npad	 1
$LL12@zipClose:

; 1911 :         {
; 1912 :             if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))

  00060	85 db		 test	 ebx, ebx
  00062	75 24		 jne	 SHORT $LN9@zipClose
  00064	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00067	85 c0		 test	 eax, eax
  00069	74 1d		 je	 SHORT $LN9@zipClose

; 1913 :             {
; 1914 :                 if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)

  0006b	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0006e	50		 push	 eax
  0006f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00072	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00075	51		 push	 ecx
  00076	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	ff d1		 call	 ecx
  0007d	83 c4 10	 add	 esp, 16			; 00000010H
  00080	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00083	74 03		 je	 SHORT $LN9@zipClose

; 1915 :                     err = ZIP_ERRNO;

  00085	83 cb ff	 or	 ebx, -1
$LN9@zipClose:

; 1916 :             }
; 1917 : 
; 1918 :             size_centraldir += ldi->filled_in_this_block;

  00088	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1919 :             ldi = ldi->next_datablock;

  0008b	8b 36		 mov	 esi, DWORD PTR [esi]
  0008d	01 54 24 0c	 add	 DWORD PTR _size_centraldir$[esp+32], edx
  00091	85 f6		 test	 esi, esi
  00093	75 cb		 jne	 SHORT $LL12@zipClose
$LN11@zipClose:

; 1920 :         }
; 1921 :     }
; 1922 :     free_linkedlist(&(zi->central_dir));

  00095	8d 77 30	 lea	 esi, DWORD PTR [edi+48]
  00098	e8 00 00 00 00	 call	 _free_linkedlist

; 1923 : 
; 1924 :     pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  0009d	8b 74 24 10	 mov	 esi, DWORD PTR _centraldir_pos_inzip$[esp+32]
  000a1	8b 44 24 14	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[esp+36]
  000a5	8b ce		 mov	 ecx, esi
  000a7	2b 8f f0 00 01
	00		 sub	 ecx, DWORD PTR [edi+65776]
  000ad	1b 87 f4 00 01
	00		 sbb	 eax, DWORD PTR [edi+65780]

; 1925 :     if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)

  000b3	85 c0		 test	 eax, eax
  000b5	77 1c		 ja	 SHORT $LN22@zipClose
  000b7	72 05		 jb	 SHORT $LN21@zipClose
  000b9	83 f9 ff	 cmp	 ecx, -1
  000bc	73 15		 jae	 SHORT $LN22@zipClose
$LN21@zipClose:
  000be	83 bf fc 00 01
	00 00		 cmp	 DWORD PTR [edi+65788], 0
  000c5	77 0c		 ja	 SHORT $LN22@zipClose
  000c7	81 bf f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [edi+65784], 65535 ; 0000ffffH
  000d1	76 3b		 jbe	 SHORT $LN8@zipClose
$LN22@zipClose:

; 1926 :     {
; 1927 :       ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);

  000d3	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000d6	8b c7		 mov	 eax, edi
  000d8	e8 00 00 00 00	 call	 _call_ztell64

; 1928 :       Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

  000dd	8b 4c 24 0c	 mov	 ecx, DWORD PTR _size_centraldir$[esp+32]
  000e1	89 44 24 18	 mov	 DWORD PTR _Zip64EOCDpos$83808[esp+32], eax
  000e5	8b 44 24 14	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[esp+36]
  000e9	50		 push	 eax
  000ea	56		 push	 esi
  000eb	51		 push	 ecx
  000ec	8b c7		 mov	 eax, edi
  000ee	89 54 24 28	 mov	 DWORD PTR _Zip64EOCDpos$83808[esp+48], edx
  000f2	e8 00 00 00 00	 call	 _Write_Zip64EndOfCentralDirectoryRecord

; 1929 : 
; 1930 :       Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);

  000f7	8b 54 24 28	 mov	 edx, DWORD PTR _Zip64EOCDpos$83808[esp+48]
  000fb	8b 44 24 24	 mov	 eax, DWORD PTR _Zip64EOCDpos$83808[esp+44]
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	8b c7		 mov	 eax, edi
  00106	e8 00 00 00 00	 call	 _Write_Zip64EndOfCentralDirectoryLocator
  0010b	83 c4 08	 add	 esp, 8
$LN8@zipClose:

; 1931 :     }
; 1932 : 
; 1933 :     if (err==ZIP_OK)

  0010e	85 db		 test	 ebx, ebx
  00110	75 2b		 jne	 SHORT $LN5@zipClose

; 1934 :       err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

  00112	8b 4c 24 14	 mov	 ecx, DWORD PTR _centraldir_pos_inzip$[esp+36]
  00116	8b 54 24 0c	 mov	 edx, DWORD PTR _size_centraldir$[esp+32]
  0011a	51		 push	 ecx
  0011b	56		 push	 esi
  0011c	52		 push	 edx
  0011d	8b c7		 mov	 eax, edi
  0011f	e8 00 00 00 00	 call	 _Write_EndOfCentralDirectoryRecord
  00124	8b d8		 mov	 ebx, eax
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1935 : 
; 1936 :     if(err == ZIP_OK)

  00129	85 db		 test	 ebx, ebx
  0012b	75 10		 jne	 SHORT $LN5@zipClose

; 1937 :       err = Write_GlobalComment(zi, global_comment);

  0012d	8b 45 0c	 mov	 eax, DWORD PTR _global_comment$[ebp]
  00130	50		 push	 eax
  00131	8b c7		 mov	 eax, edi
  00133	e8 00 00 00 00	 call	 _Write_GlobalComment
  00138	83 c4 04	 add	 esp, 4
  0013b	8b d8		 mov	 ebx, eax
$LN5@zipClose:

; 1938 : 
; 1939 :     if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)

  0013d	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00140	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  00143	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00146	51		 push	 ecx
  00147	52		 push	 edx
  00148	ff d0		 call	 eax
  0014a	83 c4 08	 add	 esp, 8
  0014d	85 c0		 test	 eax, eax
  0014f	74 07		 je	 SHORT $LN3@zipClose

; 1940 :         if (err == ZIP_OK)

  00151	85 db		 test	 ebx, ebx
  00153	75 03		 jne	 SHORT $LN3@zipClose

; 1941 :             err = ZIP_ERRNO;

  00155	83 cb ff	 or	 ebx, -1
$LN3@zipClose:

; 1942 : 
; 1943 : #ifndef NO_ADDFILEINEXISTINGZIP
; 1944 :     TRYFREE(zi->globalcomment);

  00158	8b 87 00 01 01
	00		 mov	 eax, DWORD PTR [edi+65792]
  0015e	85 c0		 test	 eax, eax
  00160	74 09		 je	 SHORT $LN2@zipClose
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _free
  00168	83 c4 04	 add	 esp, 4
$LN2@zipClose:

; 1945 : #endif
; 1946 :     TRYFREE(zi);

  0016b	57		 push	 edi
  0016c	e8 00 00 00 00	 call	 _free
  00171	83 c4 04	 add	 esp, 4

; 1947 : 
; 1948 :     return err;
; 1949 : }

  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	8b c3		 mov	 eax, ebx
  00178	5b		 pop	 ebx
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 08 00	 ret	 8
_zipClose@8 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip@40
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip@40
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_zipOpenNewFileInZip@40 PROC				; COMDAT

; 1354 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1355 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1356 :                                  extrafield_local, size_extrafield_local,
; 1357 :                                  extrafield_global, size_extrafield_global,
; 1358 :                                  comment, method, level, 0,
; 1359 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1360 :                                  NULL, 0, VERSIONMADEBY, 0, 0);

  00003	6a 00		 push	 0
  00005	8b 45 2c	 mov	 eax, DWORD PTR _level$[ebp]
  00008	6a 00		 push	 0
  0000a	8b 4d 28	 mov	 ecx, DWORD PTR _method$[ebp]
  0000d	8b 55 24	 mov	 edx, DWORD PTR _comment$[ebp]
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 08		 push	 8
  0001a	6a f1		 push	 -15			; fffffff1H
  0001c	6a 00		 push	 0
  0001e	50		 push	 eax
  0001f	8b 45 20	 mov	 eax, DWORD PTR _size_extrafield_global$[ebp]
  00022	51		 push	 ecx
  00023	8b 4d 1c	 mov	 ecx, DWORD PTR _extrafield_global$[ebp]
  00026	52		 push	 edx
  00027	8b 55 18	 mov	 edx, DWORD PTR _size_extrafield_local$[ebp]
  0002a	50		 push	 eax
  0002b	8b 45 14	 mov	 eax, DWORD PTR _extrafield_local$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _zipfi$[ebp]
  00032	52		 push	 edx
  00033	8b 55 0c	 mov	 edx, DWORD PTR _filename$[ebp]
  00036	50		 push	 eax
  00037	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0003a	51		 push	 ecx
  0003b	52		 push	 edx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1361 : }

  00042	5d		 pop	 ebp
  00043	c2 28 00	 ret	 40			; 00000028H
_zipOpenNewFileInZip@40 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip64@44
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip64@44
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_zip64$ = 48						; size = 4
_zipOpenNewFileInZip64@44 PROC				; COMDAT

; 1341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1342 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1343 :                                  extrafield_local, size_extrafield_local,
; 1344 :                                  extrafield_global, size_extrafield_global,
; 1345 :                                  comment, method, level, 0,
; 1346 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1347 :                                  NULL, 0, VERSIONMADEBY, 0, zip64);

  00003	8b 45 30	 mov	 eax, DWORD PTR _zip64$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 2c	 mov	 ecx, DWORD PTR _level$[ebp]
  0000a	6a 00		 push	 0
  0000c	8b 55 28	 mov	 edx, DWORD PTR _method$[ebp]
  0000f	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 08		 push	 8
  0001c	6a f1		 push	 -15			; fffffff1H
  0001e	6a 00		 push	 0
  00020	51		 push	 ecx
  00021	8b 4d 20	 mov	 ecx, DWORD PTR _size_extrafield_global$[ebp]
  00024	52		 push	 edx
  00025	8b 55 1c	 mov	 edx, DWORD PTR _extrafield_global$[ebp]
  00028	50		 push	 eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _size_extrafield_local$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d 14	 mov	 ecx, DWORD PTR _extrafield_local$[ebp]
  00030	52		 push	 edx
  00031	8b 55 10	 mov	 edx, DWORD PTR _zipfi$[ebp]
  00034	50		 push	 eax
  00035	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1348 : }

  00044	5d		 pop	 ebp
  00045	c2 2c 00	 ret	 44			; 0000002cH
_zipOpenNewFileInZip64@44 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip2_64@48
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip2_64@48
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_zip64$ = 52						; size = 4
_zipOpenNewFileInZip2_64@48 PROC			; COMDAT

; 1328 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1329 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1330 :                                  extrafield_local, size_extrafield_local,
; 1331 :                                  extrafield_global, size_extrafield_global,
; 1332 :                                  comment, method, level, raw,
; 1333 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1334 :                                  NULL, 0, VERSIONMADEBY, 0, zip64);

  00003	8b 45 34	 mov	 eax, DWORD PTR _zip64$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 30	 mov	 ecx, DWORD PTR _raw$[ebp]
  0000a	8b 55 2c	 mov	 edx, DWORD PTR _level$[ebp]
  0000d	6a 00		 push	 0
  0000f	8b 45 28	 mov	 eax, DWORD PTR _method$[ebp]
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 08		 push	 8
  0001c	6a f1		 push	 -15			; fffffff1H
  0001e	51		 push	 ecx
  0001f	8b 4d 24	 mov	 ecx, DWORD PTR _comment$[ebp]
  00022	52		 push	 edx
  00023	8b 55 20	 mov	 edx, DWORD PTR _size_extrafield_global$[ebp]
  00026	50		 push	 eax
  00027	8b 45 1c	 mov	 eax, DWORD PTR _extrafield_global$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d 18	 mov	 ecx, DWORD PTR _size_extrafield_local$[ebp]
  0002e	52		 push	 edx
  0002f	8b 55 14	 mov	 edx, DWORD PTR _extrafield_local$[ebp]
  00032	50		 push	 eax
  00033	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  0003a	52		 push	 edx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  0003e	50		 push	 eax
  0003f	51		 push	 ecx
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1335 : }

  00046	5d		 pop	 ebp
  00047	c2 30 00	 ret	 48			; 00000030H
_zipOpenNewFileInZip2_64@48 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip2@44
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip2@44
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_zipOpenNewFileInZip2@44 PROC				; COMDAT

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1316 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1317 :                                  extrafield_local, size_extrafield_local,
; 1318 :                                  extrafield_global, size_extrafield_global,
; 1319 :                                  comment, method, level, raw,
; 1320 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1321 :                                  NULL, 0, VERSIONMADEBY, 0, 0);

  00003	8b 45 30	 mov	 eax, DWORD PTR _raw$[ebp]
  00006	6a 00		 push	 0
  00008	8b 4d 2c	 mov	 ecx, DWORD PTR _level$[ebp]
  0000b	6a 00		 push	 0
  0000d	8b 55 28	 mov	 edx, DWORD PTR _method$[ebp]
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 08		 push	 8
  0001a	6a f1		 push	 -15			; fffffff1H
  0001c	50		 push	 eax
  0001d	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d 20	 mov	 ecx, DWORD PTR _size_extrafield_global$[ebp]
  00024	52		 push	 edx
  00025	8b 55 1c	 mov	 edx, DWORD PTR _extrafield_global$[ebp]
  00028	50		 push	 eax
  00029	8b 45 18	 mov	 eax, DWORD PTR _size_extrafield_local$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d 14	 mov	 ecx, DWORD PTR _extrafield_local$[ebp]
  00030	52		 push	 edx
  00031	8b 55 10	 mov	 edx, DWORD PTR _zipfi$[ebp]
  00034	50		 push	 eax
  00035	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1322 : }

  00044	5d		 pop	 ebp
  00045	c2 2c 00	 ret	 44			; 0000002cH
_zipOpenNewFileInZip2@44 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip3_64@68
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip3_64@68
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_zip64$ = 72						; size = 4
_zipOpenNewFileInZip3_64@68 PROC			; COMDAT

; 1302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1303 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1304 :                                  extrafield_local, size_extrafield_local,
; 1305 :                                  extrafield_global, size_extrafield_global,
; 1306 :                                  comment, method, level, raw,
; 1307 :                                  windowBits, memLevel, strategy,
; 1308 :                                  password, crcForCrypting, VERSIONMADEBY, 0, zip64);

  00003	8b 45 48	 mov	 eax, DWORD PTR _zip64$[ebp]
  00006	8b 4d 44	 mov	 ecx, DWORD PTR _crcForCrypting$[ebp]
  00009	8b 55 40	 mov	 edx, DWORD PTR _password$[ebp]
  0000c	50		 push	 eax
  0000d	8b 45 3c	 mov	 eax, DWORD PTR _strategy$[ebp]
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	51		 push	 ecx
  00015	8b 4d 38	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  00018	52		 push	 edx
  00019	8b 55 34	 mov	 edx, DWORD PTR _windowBits$[ebp]
  0001c	50		 push	 eax
  0001d	8b 45 30	 mov	 eax, DWORD PTR _raw$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d 2c	 mov	 ecx, DWORD PTR _level$[ebp]
  00024	52		 push	 edx
  00025	8b 55 28	 mov	 edx, DWORD PTR _method$[ebp]
  00028	50		 push	 eax
  00029	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d 20	 mov	 ecx, DWORD PTR _size_extrafield_global$[ebp]
  00030	52		 push	 edx
  00031	8b 55 1c	 mov	 edx, DWORD PTR _extrafield_global$[ebp]
  00034	50		 push	 eax
  00035	8b 45 18	 mov	 eax, DWORD PTR _size_extrafield_local$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d 14	 mov	 ecx, DWORD PTR _extrafield_local$[ebp]
  0003c	52		 push	 edx
  0003d	8b 55 10	 mov	 edx, DWORD PTR _zipfi$[ebp]
  00040	50		 push	 eax
  00041	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00044	51		 push	 ecx
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1309 : }

  00050	5d		 pop	 ebp
  00051	c2 44 00	 ret	 68			; 00000044H
_zipOpenNewFileInZip3_64@68 ENDP
_TEXT	ENDS
PUBLIC	_zipOpenNewFileInZip3@64
; Function compile flags: /Ogtp
;	COMDAT _zipOpenNewFileInZip3@64
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_zipOpenNewFileInZip3@64 PROC				; COMDAT

; 1287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1288 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,
; 1289 :                                  extrafield_local, size_extrafield_local,
; 1290 :                                  extrafield_global, size_extrafield_global,
; 1291 :                                  comment, method, level, raw,
; 1292 :                                  windowBits, memLevel, strategy,
; 1293 :                                  password, crcForCrypting, VERSIONMADEBY, 0, 0);

  00003	8b 45 44	 mov	 eax, DWORD PTR _crcForCrypting$[ebp]
  00006	8b 4d 40	 mov	 ecx, DWORD PTR _password$[ebp]
  00009	8b 55 3c	 mov	 edx, DWORD PTR _strategy$[ebp]
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	8b 45 38	 mov	 eax, DWORD PTR _memLevel$[ebp]
  00016	51		 push	 ecx
  00017	8b 4d 34	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  0001a	52		 push	 edx
  0001b	8b 55 30	 mov	 edx, DWORD PTR _raw$[ebp]
  0001e	50		 push	 eax
  0001f	8b 45 2c	 mov	 eax, DWORD PTR _level$[ebp]
  00022	51		 push	 ecx
  00023	8b 4d 28	 mov	 ecx, DWORD PTR _method$[ebp]
  00026	52		 push	 edx
  00027	8b 55 24	 mov	 edx, DWORD PTR _comment$[ebp]
  0002a	50		 push	 eax
  0002b	8b 45 20	 mov	 eax, DWORD PTR _size_extrafield_global$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 4d 1c	 mov	 ecx, DWORD PTR _extrafield_global$[ebp]
  00032	52		 push	 edx
  00033	8b 55 18	 mov	 edx, DWORD PTR _size_extrafield_local$[ebp]
  00036	50		 push	 eax
  00037	8b 45 14	 mov	 eax, DWORD PTR _extrafield_local$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _zipfi$[ebp]
  0003e	52		 push	 edx
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _filename$[ebp]
  00042	50		 push	 eax
  00043	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00046	51		 push	 ecx
  00047	52		 push	 edx
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1294 : }

  0004e	5d		 pop	 ebp
  0004f	c2 40 00	 ret	 64			; 00000040H
_zipOpenNewFileInZip3@64 ENDP
END
