; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\adler32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__alldiv:PROC
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\adler32.c
;	COMDAT _adler32_combine_
_TEXT	SEGMENT
_len2$ = 8						; size = 8
_sum1$ = 12						; size = 4
_adler32_combine_ PROC					; COMDAT
; _adler1$ = ecx
; _adler2$ = eax

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b d8		 mov	 ebx, eax

; 141  :     unsigned long sum1;
; 142  :     unsigned long sum2;
; 143  :     unsigned rem;
; 144  : 
; 145  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 146  :     if (len2 < 0)

  00007	8b 45 0c	 mov	 eax, DWORD PTR _len2$[ebp+4]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _len2$[ebp]
  0000e	8b f1		 mov	 esi, ecx
  00010	85 c0		 test	 eax, eax
  00012	7f 0e		 jg	 SHORT $LN5@adler32_co
  00014	7c 04		 jl	 SHORT $LN8@adler32_co
  00016	85 ff		 test	 edi, edi
  00018	73 08		 jae	 SHORT $LN5@adler32_co
$LN8@adler32_co:
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 147  :         return 0xffffffffUL;

  0001c	83 c8 ff	 or	 eax, -1
  0001f	5b		 pop	 ebx

; 162  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$LN5@adler32_co:

; 148  : 
; 149  :     /* the derivation of this formula is left as an exercise for the reader */
; 150  :     MOD63(len2);                /* assumes len2 >= 0 */

  00022	6a 00		 push	 0
  00024	68 f1 ff 00 00	 push	 65521			; 0000fff1H
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 __alldiv
  00030	69 c0 f1 ff 00
	00		 imul	 eax, 65521		; 0000fff1H
  00036	2b f8		 sub	 edi, eax

; 151  :     rem = (unsigned)len2;
; 152  :     sum1 = adler1 & 0xffff;

  00038	0f b7 c6	 movzx	 eax, si

; 153  :     sum2 = rem * sum1;

  0003b	8b c8		 mov	 ecx, eax
  0003d	0f af cf	 imul	 ecx, edi

; 154  :     MOD(sum2);
; 155  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  00040	0f b7 d3	 movzx	 edx, bx
  00043	8d 84 10 f0 ff
	00 00		 lea	 eax, DWORD PTR [eax+edx+65520]
  0004a	89 45 0c	 mov	 DWORD PTR _sum1$[ebp], eax
  0004d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00052	f7 e1		 mul	 ecx
  00054	c1 ea 0f	 shr	 edx, 15			; 0000000fH

; 156  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00057	69 d2 f1 ff 00
	00		 imul	 edx, 65521		; 0000fff1H
  0005d	c1 ee 10	 shr	 esi, 16			; 00000010H
  00060	2b f2		 sub	 esi, edx

; 157  :     if (sum1 >= BASE) sum1 -= BASE;

  00062	8b 55 0c	 mov	 edx, DWORD PTR _sum1$[ebp]
  00065	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00068	03 f3		 add	 esi, ebx
  0006a	2b f7		 sub	 esi, edi
  0006c	8d 8c 31 f1 ff
	00 00		 lea	 ecx, DWORD PTR [ecx+esi+65521]
  00073	81 fa f1 ff 00
	00		 cmp	 edx, 65521		; 0000fff1H
  00079	72 14		 jb	 SHORT $LN3@adler32_co
  0007b	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H

; 158  :     if (sum1 >= BASE) sum1 -= BASE;

  00081	81 fa f1 ff 00
	00		 cmp	 edx, 65521		; 0000fff1H
  00087	72 06		 jb	 SHORT $LN3@adler32_co
  00089	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
$LN3@adler32_co:

; 159  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  0008f	81 f9 e2 ff 01
	00		 cmp	 ecx, 131042		; 0001ffe2H
  00095	72 06		 jb	 SHORT $LN2@adler32_co
  00097	81 e9 e2 ff 01
	00		 sub	 ecx, 131042		; 0001ffe2H
$LN2@adler32_co:

; 160  :     if (sum2 >= BASE) sum2 -= BASE;

  0009d	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  000a3	72 06		 jb	 SHORT $LN1@adler32_co
  000a5	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
$LN1@adler32_co:
  000ab	5f		 pop	 edi

; 161  :     return sum1 | (sum2 << 16);

  000ac	8b c1		 mov	 eax, ecx
  000ae	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b1	5e		 pop	 esi
  000b2	0b c2		 or	 eax, edx
  000b4	5b		 pop	 ebx

; 162  : }

  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
_adler32_combine_ ENDP
_TEXT	ENDS
PUBLIC	_adler32@12
; Function compile flags: /Ogtp
;	COMDAT _adler32@12
_TEXT	SEGMENT
_adler$ = 8						; size = 4
tv884 = 12						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32@12 PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 70   :     unsigned long sum2;
; 71   :     unsigned n;
; 72   : 
; 73   :     /* split Adler-32 into component sums */
; 74   :     sum2 = (adler >> 16) & 0xffff;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  00006	53		 push	 ebx

; 75   :     adler &= 0xffff;
; 76   : 
; 77   :     /* in case user likes doing a byte at a time, keep it fast */
; 78   :     if (len == 1) {

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	c1 ef 10	 shr	 edi, 16			; 00000010H
  00010	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00016	83 fb 01	 cmp	 ebx, 1
  00019	75 33		 jne	 SHORT $LN18@adler32

; 79   :         adler += buf[0];

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0001e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00021	03 ca		 add	 ecx, edx

; 80   :         if (adler >= BASE)

  00023	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00029	72 06		 jb	 SHORT $LN17@adler32

; 81   :             adler -= BASE;

  0002b	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
$LN17@adler32:

; 82   :         sum2 += adler;

  00031	03 f9		 add	 edi, ecx

; 83   :         if (sum2 >= BASE)

  00033	81 ff f1 ff 00
	00		 cmp	 edi, 65521		; 0000fff1H
  00039	72 06		 jb	 SHORT $LN16@adler32

; 84   :             sum2 -= BASE;

  0003b	81 ef f1 ff 00
	00		 sub	 edi, 65521		; 0000fff1H
$LN16@adler32:

; 85   :         return adler | (sum2 << 16);

  00041	8b c7		 mov	 eax, edi
  00043	c1 e0 10	 shl	 eax, 16			; 00000010H
  00046	5f		 pop	 edi
  00047	0b c1		 or	 eax, ecx
  00049	5b		 pop	 ebx

; 133  : }

  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
$LN18@adler32:
  0004e	56		 push	 esi

; 86   :     }
; 87   : 
; 88   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 89   :     if (buf == Z_NULL)

  0004f	8b 75 0c	 mov	 esi, DWORD PTR _buf$[ebp]
  00052	85 f6		 test	 esi, esi
  00054	75 0a		 jne	 SHORT $LN15@adler32

; 90   :         return 1L;

  00056	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00059	5e		 pop	 esi
  0005a	5f		 pop	 edi
  0005b	5b		 pop	 ebx

; 133  : }

  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN15@adler32:

; 91   : 
; 92   :     /* in case short lengths are provided, keep it somewhat fast */
; 93   :     if (len < 16) {

  00060	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00063	73 43		 jae	 SHORT $LN22@adler32

; 94   :         while (len--) {

  00065	85 db		 test	 ebx, ebx
  00067	74 12		 je	 SHORT $LN26@adler32
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL13@adler32:

; 95   :             adler += *buf++;

  00070	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00073	03 c8		 add	 ecx, eax
  00075	46		 inc	 esi

; 96   :             sum2 += adler;

  00076	03 f9		 add	 edi, ecx
  00078	4b		 dec	 ebx
  00079	75 f5		 jne	 SHORT $LL13@adler32
$LN26@adler32:

; 97   :         }
; 98   :         if (adler >= BASE)

  0007b	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00081	72 06		 jb	 SHORT $LN11@adler32

; 99   :             adler -= BASE;

  00083	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
$LN11@adler32:

; 100  :         MOD28(sum2);            /* only added so many BASE's */

  00089	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  0008e	f7 e7		 mul	 edi
  00090	c1 ea 0f	 shr	 edx, 15			; 0000000fH

; 101  :         return adler | (sum2 << 16);

  00093	8b c2		 mov	 eax, edx
  00095	c1 e0 04	 shl	 eax, 4
  00098	2b c2		 sub	 eax, edx
  0009a	03 c7		 add	 eax, edi
  0009c	5e		 pop	 esi

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  0009d	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a0	5f		 pop	 edi
  000a1	0b c1		 or	 eax, ecx
  000a3	5b		 pop	 ebx

; 133  : }

  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
$LN22@adler32:

; 102  :     }
; 103  : 
; 104  :     /* do length NMAX blocks -- requires just one modulo operation */
; 105  :     while (len >= NMAX) {

  000a8	81 fb b0 15 00
	00		 cmp	 ebx, 5552		; 000015b0H
  000ae	0f 82 d2 00 00
	00		 jb	 $LN9@adler32
  000b4	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  000b9	f7 e3		 mul	 ebx
  000bb	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000be	89 55 0c	 mov	 DWORD PTR tv884[ebp], edx
$LL10@adler32:

; 106  :         len -= NMAX;

  000c1	81 eb b0 15 00
	00		 sub	 ebx, 5552		; 000015b0H

; 107  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000c7	b8 5b 01 00 00	 mov	 eax, 347		; 0000015bH
  000cc	8d 64 24 00	 npad	 4
$LL8@adler32:

; 108  :         do {
; 109  :             DO16(buf);          /* 16 sums unrolled */

  000d0	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  000d3	03 ca		 add	 ecx, edx
  000d5	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  000d9	03 f9		 add	 edi, ecx
  000db	03 ca		 add	 ecx, edx
  000dd	0f b6 56 02	 movzx	 edx, BYTE PTR [esi+2]
  000e1	03 f9		 add	 edi, ecx
  000e3	03 ca		 add	 ecx, edx
  000e5	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  000e9	03 f9		 add	 edi, ecx
  000eb	03 ca		 add	 ecx, edx
  000ed	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  000f1	03 f9		 add	 edi, ecx
  000f3	03 ca		 add	 ecx, edx
  000f5	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  000f9	03 f9		 add	 edi, ecx
  000fb	03 ca		 add	 ecx, edx
  000fd	0f b6 56 06	 movzx	 edx, BYTE PTR [esi+6]
  00101	03 f9		 add	 edi, ecx
  00103	03 ca		 add	 ecx, edx
  00105	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00109	03 f9		 add	 edi, ecx
  0010b	03 ca		 add	 ecx, edx
  0010d	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  00111	03 f9		 add	 edi, ecx
  00113	03 ca		 add	 ecx, edx
  00115	0f b6 56 09	 movzx	 edx, BYTE PTR [esi+9]
  00119	03 f9		 add	 edi, ecx
  0011b	03 ca		 add	 ecx, edx
  0011d	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  00121	03 f9		 add	 edi, ecx
  00123	03 ca		 add	 ecx, edx
  00125	0f b6 56 0b	 movzx	 edx, BYTE PTR [esi+11]
  00129	03 f9		 add	 edi, ecx
  0012b	03 ca		 add	 ecx, edx
  0012d	0f b6 56 0c	 movzx	 edx, BYTE PTR [esi+12]
  00131	03 f9		 add	 edi, ecx
  00133	03 ca		 add	 ecx, edx
  00135	0f b6 56 0d	 movzx	 edx, BYTE PTR [esi+13]
  00139	03 f9		 add	 edi, ecx
  0013b	03 ca		 add	 ecx, edx
  0013d	0f b6 56 0e	 movzx	 edx, BYTE PTR [esi+14]
  00141	03 f9		 add	 edi, ecx
  00143	03 ca		 add	 ecx, edx
  00145	0f b6 56 0f	 movzx	 edx, BYTE PTR [esi+15]
  00149	03 f9		 add	 edi, ecx
  0014b	03 ca		 add	 ecx, edx
  0014d	03 f9		 add	 edi, ecx

; 110  :             buf += 16;

  0014f	83 c6 10	 add	 esi, 16			; 00000010H

; 111  :         } while (--n);

  00152	48		 dec	 eax
  00153	0f 85 77 ff ff
	ff		 jne	 $LL8@adler32

; 112  :         MOD(adler);

  00159	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  0015e	f7 e1		 mul	 ecx
  00160	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00163	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  00169	03 ca		 add	 ecx, edx

; 113  :         MOD(sum2);

  0016b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00170	f7 e7		 mul	 edi
  00172	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00175	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  0017b	03 fa		 add	 edi, edx
  0017d	ff 4d 0c	 dec	 DWORD PTR tv884[ebp]
  00180	0f 85 3b ff ff
	ff		 jne	 $LL10@adler32
$LN9@adler32:

; 114  :     }
; 115  : 
; 116  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 117  :     if (len) {                  /* avoid modulos if none remaining */

  00186	85 db		 test	 ebx, ebx
  00188	0f 84 d1 00 00
	00		 je	 $LN5@adler32

; 118  :         while (len >= 16) {

  0018e	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00191	0f 82 95 00 00
	00		 jb	 $LN32@adler32
  00197	8b c3		 mov	 eax, ebx
  00199	c1 e8 04	 shr	 eax, 4
  0019c	8d 64 24 00	 npad	 4
$LL4@adler32:

; 119  :             len -= 16;
; 120  :             DO16(buf);

  001a0	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  001a3	03 ca		 add	 ecx, edx
  001a5	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  001a9	03 f9		 add	 edi, ecx
  001ab	03 ca		 add	 ecx, edx
  001ad	0f b6 56 02	 movzx	 edx, BYTE PTR [esi+2]
  001b1	03 f9		 add	 edi, ecx
  001b3	03 ca		 add	 ecx, edx
  001b5	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  001b9	03 f9		 add	 edi, ecx
  001bb	03 ca		 add	 ecx, edx
  001bd	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  001c1	03 f9		 add	 edi, ecx
  001c3	03 ca		 add	 ecx, edx
  001c5	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  001c9	03 f9		 add	 edi, ecx
  001cb	03 ca		 add	 ecx, edx
  001cd	0f b6 56 06	 movzx	 edx, BYTE PTR [esi+6]
  001d1	03 f9		 add	 edi, ecx
  001d3	03 ca		 add	 ecx, edx
  001d5	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  001d9	03 f9		 add	 edi, ecx
  001db	03 ca		 add	 ecx, edx
  001dd	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  001e1	03 f9		 add	 edi, ecx
  001e3	03 ca		 add	 ecx, edx
  001e5	0f b6 56 09	 movzx	 edx, BYTE PTR [esi+9]
  001e9	03 f9		 add	 edi, ecx
  001eb	03 ca		 add	 ecx, edx
  001ed	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  001f1	03 f9		 add	 edi, ecx
  001f3	03 ca		 add	 ecx, edx
  001f5	0f b6 56 0b	 movzx	 edx, BYTE PTR [esi+11]
  001f9	03 f9		 add	 edi, ecx
  001fb	03 ca		 add	 ecx, edx
  001fd	0f b6 56 0c	 movzx	 edx, BYTE PTR [esi+12]
  00201	03 f9		 add	 edi, ecx
  00203	03 ca		 add	 ecx, edx
  00205	0f b6 56 0d	 movzx	 edx, BYTE PTR [esi+13]
  00209	03 f9		 add	 edi, ecx
  0020b	03 ca		 add	 ecx, edx
  0020d	0f b6 56 0e	 movzx	 edx, BYTE PTR [esi+14]
  00211	03 f9		 add	 edi, ecx
  00213	03 ca		 add	 ecx, edx
  00215	0f b6 56 0f	 movzx	 edx, BYTE PTR [esi+15]
  00219	03 f9		 add	 edi, ecx
  0021b	03 ca		 add	 ecx, edx
  0021d	83 eb 10	 sub	 ebx, 16			; 00000010H
  00220	03 f9		 add	 edi, ecx

; 121  :             buf += 16;

  00222	83 c6 10	 add	 esi, 16			; 00000010H
  00225	48		 dec	 eax
  00226	0f 85 74 ff ff
	ff		 jne	 $LL4@adler32
$LN32@adler32:

; 122  :         }
; 123  :         while (len--) {

  0022c	85 db		 test	 ebx, ebx
  0022e	74 0b		 je	 SHORT $LN30@adler32
$LL2@adler32:

; 124  :             adler += *buf++;

  00230	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00233	03 c8		 add	 ecx, eax
  00235	46		 inc	 esi

; 125  :             sum2 += adler;

  00236	03 f9		 add	 edi, ecx
  00238	4b		 dec	 ebx
  00239	75 f5		 jne	 SHORT $LL2@adler32
$LN30@adler32:

; 126  :         }
; 127  :         MOD(adler);

  0023b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00240	f7 e1		 mul	 ecx
  00242	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00245	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  0024b	03 ca		 add	 ecx, edx

; 128  :         MOD(sum2);

  0024d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00252	f7 e7		 mul	 edi
  00254	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00257	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  0025d	03 fa		 add	 edi, edx
$LN5@adler32:

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  0025f	8b c7		 mov	 eax, edi
  00261	5e		 pop	 esi
  00262	c1 e0 10	 shl	 eax, 16			; 00000010H
  00265	5f		 pop	 edi
  00266	0b c1		 or	 eax, ecx
  00268	5b		 pop	 ebx

; 133  : }

  00269	5d		 pop	 ebp
  0026a	c2 0c 00	 ret	 12			; 0000000cH
_adler32@12 ENDP
PUBLIC	_adler32_combine@12
; Function compile flags: /Ogtp
;	COMDAT _adler32_combine@12
_TEXT	SEGMENT
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 4
_adler32_combine@12 PROC				; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  :     return adler32_combine_(adler1, adler2, len2);

  00003	8b 45 10	 mov	 eax, DWORD PTR _len2$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _adler1$[ebp]
  00009	99		 cdq
  0000a	52		 push	 edx
  0000b	50		 push	 eax
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _adler2$[ebp]
  0000f	e8 00 00 00 00	 call	 _adler32_combine_
  00014	83 c4 08	 add	 esp, 8

; 171  : }

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
_adler32_combine@12 ENDP
END
