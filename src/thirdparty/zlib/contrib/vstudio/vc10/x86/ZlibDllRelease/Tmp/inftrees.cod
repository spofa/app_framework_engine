; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
_inflate_copyright DB ' inflate 1.2.8 Copyright 1995-2013 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	048H
	DW	04eH
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	_inflate_table
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
_offs$ = -124						; size = 32
_count$ = -92						; size = 32
tv614 = -60						; size = 4
_min$ = -56						; size = 4
_mask$ = -52						; size = 4
_low$ = -48						; size = 4
tv585 = -44						; size = 4
_used$ = -40						; size = 4
_base$ = -36						; size = 4
_extra$ = -32						; size = 4
_end$ = -28						; size = 4
_next$ = -24						; size = 4
_max$ = -20						; size = 4
tv1134 = -16						; size = 4
_drop$ = -12						; size = 4
_huff$ = -8						; size = 4
_root$ = -4						; size = 4
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_here$ = 16						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	8b 55 10	 mov	 edx, DWORD PTR _codes$[ebp]

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	0f b7 c8	 movzx	 ecx, ax
  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00013	0b c1		 or	 eax, ecx
  00015	53		 push	 ebx
  00016	8b 5d 18	 mov	 ebx, DWORD PTR _bits$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 14	 mov	 esi, DWORD PTR _table$[ebp]
  0001d	89 45 a4	 mov	 DWORD PTR _count$[ebp], eax
  00020	89 45 a8	 mov	 DWORD PTR _count$[ebp+4], eax
  00023	89 45 ac	 mov	 DWORD PTR _count$[ebp+8], eax
  00026	89 45 b0	 mov	 DWORD PTR _count$[ebp+12], eax
  00029	89 45 b4	 mov	 DWORD PTR _count$[ebp+16], eax
  0002c	89 45 b8	 mov	 DWORD PTR _count$[ebp+20], eax
  0002f	89 45 bc	 mov	 DWORD PTR _count$[ebp+24], eax
  00032	89 45 c0	 mov	 DWORD PTR _count$[ebp+28], eax

; 109  :     for (sym = 0; sym < codes; sym++)

  00035	33 c0		 xor	 eax, eax
  00037	57		 push	 edi
  00038	8b 7d 0c	 mov	 edi, DWORD PTR _lens$[ebp]
  0003b	85 d2		 test	 edx, edx
  0003d	74 13		 je	 SHORT $LN57@inflate_ta
  0003f	90		 npad	 1
$LL59@inflate_ta:

; 110  :         count[lens[sym]]++;

  00040	0f b7 0c 47	 movzx	 ecx, WORD PTR [edi+eax*2]
  00044	66 ff 44 4d a4	 inc	 WORD PTR _count$[ebp+ecx*2]
  00049	8d 4c 4d a4	 lea	 ecx, DWORD PTR _count$[ebp+ecx*2]
  0004d	40		 inc	 eax
  0004e	3b c2		 cmp	 eax, edx
  00050	72 ee		 jb	 SHORT $LL59@inflate_ta
$LN57@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00052	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00054	89 4d fc	 mov	 DWORD PTR _root$[ebp], ecx

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00057	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0005c	8d 64 24 00	 npad	 4
$LL56@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00060	66 83 7c 45 a4
	00		 cmp	 WORD PTR _count$[ebp+eax*2], 0
  00066	75 06		 jne	 SHORT $LN105@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00068	48		 dec	 eax
  00069	83 f8 01	 cmp	 eax, 1
  0006c	73 f2		 jae	 SHORT $LL56@inflate_ta
$LN105@inflate_ta:
  0006e	89 45 ec	 mov	 DWORD PTR _max$[ebp], eax

; 116  :     if (root > max) root = max;

  00071	3b c8		 cmp	 ecx, eax
  00073	76 05		 jbe	 SHORT $LN52@inflate_ta
  00075	89 45 fc	 mov	 DWORD PTR _root$[ebp], eax
  00078	8b c8		 mov	 ecx, eax
$LN52@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0007a	85 c0		 test	 eax, eax
  0007c	75 27		 jne	 SHORT $LN51@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  0007e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00080	c7 45 10 40 01
	00 00		 mov	 DWORD PTR _here$[ebp], 320 ; 00000140H
  00087	8b 45 10	 mov	 eax, DWORD PTR _here$[ebp]
  0008a	89 01		 mov	 DWORD PTR [ecx], eax
  0008c	83 06 04	 add	 DWORD PTR [esi], 4
  0008f	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 122  :         *(*table)++ = here;

  00091	89 01		 mov	 DWORD PTR [ecx], eax
  00093	83 06 04	 add	 DWORD PTR [esi], 4
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 123  :         *bits = 1;

  00098	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0009e	33 c0		 xor	 eax, eax
  000a0	5b		 pop	 ebx

; 306  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$LN51@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000a5	bb 01 00 00 00	 mov	 ebx, 1
  000aa	3b c3		 cmp	 eax, ebx
  000ac	76 0f		 jbe	 SHORT $LN78@inflate_ta
  000ae	8b ff		 npad	 2
$LL50@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000b0	66 83 7c 5d a4
	00		 cmp	 WORD PTR _count$[ebp+ebx*2], 0
  000b6	75 05		 jne	 SHORT $LN78@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000b8	43		 inc	 ebx
  000b9	3b d8		 cmp	 ebx, eax
  000bb	72 f3		 jb	 SHORT $LL50@inflate_ta
$LN78@inflate_ta:

; 128  :     if (root < min) root = min;

  000bd	3b cb		 cmp	 ecx, ebx
  000bf	73 03		 jae	 SHORT $LN46@inflate_ta
  000c1	89 5d fc	 mov	 DWORD PTR _root$[ebp], ebx
$LN46@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000c4	ba 01 00 00 00	 mov	 edx, 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000c9	8b ca		 mov	 ecx, edx
  000cb	eb 03 8d 49 00	 npad	 5
$LL45@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  000d0	0f b7 74 4d a4	 movzx	 esi, WORD PTR _count$[ebp+ecx*2]
  000d5	03 d2		 add	 edx, edx
  000d7	2b d6		 sub	 edx, esi

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  000d9	0f 88 90 00 00
	00		 js	 $LN79@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000df	41		 inc	 ecx
  000e0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000e3	76 eb		 jbe	 SHORT $LL45@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  000e5	85 d2		 test	 edx, edx
  000e7	7e 0f		 jle	 SHORT $LN102@inflate_ta
  000e9	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  000ed	0f 84 7c 00 00
	00		 je	 $LN79@inflate_ta
  000f3	83 f8 01	 cmp	 eax, 1

; 138  :         return -1;                      /* incomplete set */

  000f6	75 77		 jne	 SHORT $LN79@inflate_ta
$LN102@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  000f8	33 c0		 xor	 eax, eax
  000fa	66 89 45 86	 mov	 WORD PTR _offs$[ebp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  000fe	b8 02 00 00 00	 mov	 eax, 2
$LL39@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00103	66 8b 4c 05 84	 mov	 cx, WORD PTR _offs$[ebp+eax]
  00108	66 03 4c 05 a4	 add	 cx, WORD PTR _count$[ebp+eax]
  0010d	83 c0 02	 add	 eax, 2
  00110	66 89 4c 05 84	 mov	 WORD PTR _offs$[ebp+eax], cx
  00115	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00118	72 e9		 jb	 SHORT $LL39@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0011a	8b 55 10	 mov	 edx, DWORD PTR _codes$[ebp]
  0011d	8b 75 1c	 mov	 esi, DWORD PTR _work$[ebp]
  00120	33 c0		 xor	 eax, eax
  00122	85 d2		 test	 edx, edx
  00124	74 26		 je	 SHORT $LN34@inflate_ta
$LL104@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00126	66 83 3c 47 00	 cmp	 WORD PTR [edi+eax*2], 0
  0012b	74 1a		 je	 SHORT $LN35@inflate_ta
  0012d	0f b7 0c 47	 movzx	 ecx, WORD PTR [edi+eax*2]
  00131	0f b7 4c 4d 84	 movzx	 ecx, WORD PTR _offs$[ebp+ecx*2]
  00136	66 89 04 4e	 mov	 WORD PTR [esi+ecx*2], ax
  0013a	0f b7 0c 47	 movzx	 ecx, WORD PTR [edi+eax*2]
  0013e	66 ff 44 4d 84	 inc	 WORD PTR _offs$[ebp+ecx*2]
  00143	8d 4c 4d 84	 lea	 ecx, DWORD PTR _offs$[ebp+ecx*2]
$LN35@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00147	40		 inc	 eax
  00148	3b c2		 cmp	 eax, edx
  0014a	72 da		 jb	 SHORT $LL104@inflate_ta
$LN34@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0014c	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0014f	83 e8 00	 sub	 eax, 0
  00152	b9 ff ff ff ff	 mov	 ecx, -1
  00157	74 43		 je	 SHORT $LN30@inflate_ta
  00159	48		 dec	 eax
  0015a	74 1d		 je	 SHORT $LN29@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  0015c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;

  00163	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 196  :         end = -1;

  0016a	89 4d e4	 mov	 DWORD PTR _end$[ebp], ecx
  0016d	eb 3a		 jmp	 SHORT $LN31@inflate_ta
$LN79@inflate_ta:
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00171	83 c8 ff	 or	 eax, -1
  00174	5b		 pop	 ebx

; 306  : }

  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
$LN29@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  00179	b8 00 00 00 00	 mov	 eax, OFFSET ?lbase@?1??inflate_table@@9@9
  0017e	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  00183	89 45 dc	 mov	 DWORD PTR _base$[ebp], eax

; 189  :         extra = lext;
; 190  :         extra -= 257;

  00186	b8 00 00 00 00	 mov	 eax, OFFSET ?lext@?1??inflate_table@@9@9
  0018b	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  00190	89 45 e0	 mov	 DWORD PTR _extra$[ebp], eax

; 191  :         end = 256;

  00193	c7 45 e4 00 01
	00 00		 mov	 DWORD PTR _end$[ebp], 256 ; 00000100H

; 192  :         break;

  0019a	eb 0d		 jmp	 SHORT $LN31@inflate_ta
$LN30@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  0019c	89 75 e0	 mov	 DWORD PTR _extra$[ebp], esi
  0019f	89 75 dc	 mov	 DWORD PTR _base$[ebp], esi

; 184  :         end = 19;

  001a2	c7 45 e4 13 00
	00 00		 mov	 DWORD PTR _end$[ebp], 19 ; 00000013H
$LN31@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001a9	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  001ac	8b 12		 mov	 edx, DWORD PTR [edx]
  001ae	33 c0		 xor	 eax, eax

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */
; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  001b0	89 4d d0	 mov	 DWORD PTR _low$[ebp], ecx

; 207  :     used = 1U << root;          /* use root table entries */

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR _root$[ebp]
  001b6	89 45 f8	 mov	 DWORD PTR _huff$[ebp], eax
  001b9	89 45 f4	 mov	 DWORD PTR _drop$[ebp], eax
  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	d3 e0		 shl	 eax, cl
  001c3	89 55 e8	 mov	 DWORD PTR _next$[ebp], edx

; 208  :     mask = used - 1;            /* mask for comparing low */

  001c6	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  001c9	89 4d cc	 mov	 DWORD PTR _mask$[ebp], ecx

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used > ENOUGH_LENS) ||
; 212  :         (type == DISTS && used > ENOUGH_DISTS))

  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  001cf	8b f8		 mov	 edi, eax
  001d1	89 7d d4	 mov	 DWORD PTR tv585[ebp], edi
  001d4	89 45 d8	 mov	 DWORD PTR _used$[ebp], eax
  001d7	83 f9 01	 cmp	 ecx, 1
  001da	75 07		 jne	 SHORT $LN25@inflate_ta
  001dc	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  001e1	eb 0a		 jmp	 SHORT $LN112@inflate_ta
$LN25@inflate_ta:
  001e3	83 f9 02	 cmp	 ecx, 2
  001e6	75 0b		 jne	 SHORT $LN95@inflate_ta
  001e8	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
$LN112@inflate_ta:

; 213  :         return 1;

  001ed	0f 87 ee 01 00
	00		 ja	 $LN3@inflate_ta
$LN95@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  001f3	89 75 f0	 mov	 DWORD PTR tv1134[ebp], esi

; 289  :         }
; 290  :     }

  001f6	eb 0b		 jmp	 SHORT $LL24@inflate_ta
  001f8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL99@inflate_ta:
  00200	8b 7d d4	 mov	 edi, DWORD PTR tv585[ebp]
$LL24@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00203	8b 55 f4	 mov	 edx, DWORD PTR _drop$[ebp]

; 219  :         if ((int)(work[sym]) < end) {

  00206	8b 4d f0	 mov	 ecx, DWORD PTR tv1134[ebp]
  00209	8b 75 e4	 mov	 esi, DWORD PTR _end$[ebp]
  0020c	8a c3		 mov	 al, bl
  0020e	2a c2		 sub	 al, dl
  00210	88 45 11	 mov	 BYTE PTR _here$[ebp+1], al
  00213	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00216	8b c8		 mov	 ecx, eax
  00218	3b ce		 cmp	 ecx, esi
  0021a	7d 0a		 jge	 SHORT $LN110@inflate_ta

; 220  :             here.op = (unsigned char)0;

  0021c	c6 45 10 00	 mov	 BYTE PTR _here$[ebp], 0

; 221  :             here.val = work[sym];

  00220	66 89 45 12	 mov	 WORD PTR _here$[ebp+2], ax
  00224	eb 2a		 jmp	 SHORT $LN19@inflate_ta
$LN110@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  00226	7e 1e		 jle	 SHORT $LN20@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00228	8b 45 f0	 mov	 eax, DWORD PTR tv1134[ebp]
  0022b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0022e	8b 4d e0	 mov	 ecx, DWORD PTR _extra$[ebp]
  00231	03 c0		 add	 eax, eax
  00233	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00236	88 4d 10	 mov	 BYTE PTR _here$[ebp], cl

; 225  :             here.val = base[work[sym]];

  00239	8b 4d dc	 mov	 ecx, DWORD PTR _base$[ebp]
  0023c	66 8b 04 08	 mov	 ax, WORD PTR [eax+ecx]
  00240	66 89 45 12	 mov	 WORD PTR _here$[ebp+2], ax

; 226  :         }
; 227  :         else {

  00244	eb 0a		 jmp	 SHORT $LN19@inflate_ta
$LN20@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */
; 229  :             here.val = 0;

  00246	33 c9		 xor	 ecx, ecx
  00248	c6 45 10 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H
  0024c	66 89 4d 12	 mov	 WORD PTR _here$[ebp+2], cx
$LN19@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00250	8b cb		 mov	 ecx, ebx
  00252	2b ca		 sub	 ecx, edx

; 234  :         fill = 1U << curr;

  00254	8b c7		 mov	 eax, edi
  00256	8b 7d f8	 mov	 edi, DWORD PTR _huff$[ebp]
  00259	ba 01 00 00 00	 mov	 edx, 1
  0025e	d3 e2		 shl	 edx, cl
  00260	8b 4d f4	 mov	 ecx, DWORD PTR _drop$[ebp]
  00263	d3 ef		 shr	 edi, cl
  00265	8b 4d e8	 mov	 ecx, DWORD PTR _next$[ebp]

; 235  :         min = fill;                 /* save offset to next table */

  00268	89 45 c8	 mov	 DWORD PTR _min$[ebp], eax
  0026b	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00272	03 f8		 add	 edi, eax
  00274	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
  00277	8b 7d 10	 mov	 edi, DWORD PTR _here$[ebp]
  0027a	8d 9b 00 00 00
	00		 npad	 6
$LL18@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  00280	2b ce		 sub	 ecx, esi
  00282	2b c2		 sub	 eax, edx

; 238  :             next[(huff >> drop) + fill] = here;

  00284	89 39		 mov	 DWORD PTR [ecx], edi

; 239  :         } while (fill != 0);

  00286	75 f8		 jne	 SHORT $LL18@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  00288	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	d3 e0		 shl	 eax, cl

; 243  :         while (huff & incr)

  00292	8b 4d f8	 mov	 ecx, DWORD PTR _huff$[ebp]
  00295	85 c1		 test	 eax, ecx
  00297	74 0d		 je	 SHORT $LN14@inflate_ta
  00299	8d a4 24 00 00
	00 00		 npad	 7
$LL15@inflate_ta:

; 244  :             incr >>= 1;

  002a0	d1 e8		 shr	 eax, 1
  002a2	85 c1		 test	 eax, ecx
  002a4	75 fa		 jne	 SHORT $LL15@inflate_ta
$LN14@inflate_ta:

; 245  :         if (incr != 0) {

  002a6	85 c0		 test	 eax, eax
  002a8	74 0c		 je	 SHORT $LN13@inflate_ta

; 246  :             huff &= incr - 1;

  002aa	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  002ad	23 d1		 and	 edx, ecx

; 247  :             huff += incr;

  002af	03 d0		 add	 edx, eax
  002b1	89 55 f8	 mov	 DWORD PTR _huff$[ebp], edx

; 248  :         }
; 249  :         else

  002b4	eb 07		 jmp	 SHORT $LN12@inflate_ta
$LN13@inflate_ta:

; 250  :             huff = 0;

  002b6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN12@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  002bd	83 45 f0 02	 add	 DWORD PTR tv1134[ebp], 2

; 254  :         if (--(count[len]) == 0) {

  002c1	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  002c6	66 01 44 5d a4	 add	 WORD PTR _count$[ebp+ebx*2], ax
  002cb	75 16		 jne	 SHORT $LN100@inflate_ta

; 255  :             if (len == max) break;

  002cd	3b 5d ec	 cmp	 ebx, DWORD PTR _max$[ebp]
  002d0	0f 84 cb 00 00
	00		 je	 $LN81@inflate_ta

; 256  :             len = lens[work[sym]];

  002d6	8b 4d f0	 mov	 ecx, DWORD PTR tv1134[ebp]
  002d9	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  002dc	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  002df	0f b7 1c 50	 movzx	 ebx, WORD PTR [eax+edx*2]
$LN100@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  002e3	3b 5d fc	 cmp	 ebx, DWORD PTR _root$[ebp]
  002e6	0f 86 14 ff ff
	ff		 jbe	 $LL99@inflate_ta
  002ec	8b 75 cc	 mov	 esi, DWORD PTR _mask$[ebp]
  002ef	23 75 f8	 and	 esi, DWORD PTR _huff$[ebp]
  002f2	89 75 c4	 mov	 DWORD PTR tv614[ebp], esi
  002f5	3b 75 d0	 cmp	 esi, DWORD PTR _low$[ebp]
  002f8	0f 84 02 ff ff
	ff		 je	 $LL99@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  002fe	8b 55 f4	 mov	 edx, DWORD PTR _drop$[ebp]
  00301	85 d2		 test	 edx, edx
  00303	75 08		 jne	 SHORT $LN8@inflate_ta

; 263  :                 drop = root;

  00305	8b 4d fc	 mov	 ecx, DWORD PTR _root$[ebp]
  00308	89 4d f4	 mov	 DWORD PTR _drop$[ebp], ecx
  0030b	8b d1		 mov	 edx, ecx
$LN8@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0030d	8b 45 e8	 mov	 eax, DWORD PTR _next$[ebp]
  00310	8b 4d c8	 mov	 ecx, DWORD PTR _min$[ebp]
  00313	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  00316	8b cb		 mov	 ecx, ebx
  00318	2b ca		 sub	 ecx, edx
  0031a	89 45 e8	 mov	 DWORD PTR _next$[ebp], eax

; 270  :             left = (int)(1 << curr);

  0031d	b8 01 00 00 00	 mov	 eax, 1

; 271  :             while (curr + drop < max) {

  00322	03 d1		 add	 edx, ecx
  00324	d3 e0		 shl	 eax, cl
  00326	3b 55 ec	 cmp	 edx, DWORD PTR _max$[ebp]
  00329	73 1d		 jae	 SHORT $LN80@inflate_ta

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0032b	8d 74 55 a4	 lea	 esi, DWORD PTR _count$[ebp+edx*2]
  0032f	90		 npad	 1
$LL7@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00330	0f b7 3e	 movzx	 edi, WORD PTR [esi]
  00333	2b c7		 sub	 eax, edi

; 273  :                 if (left <= 0) break;

  00335	85 c0		 test	 eax, eax
  00337	7e 0c		 jle	 SHORT $LN101@inflate_ta

; 274  :                 curr++;

  00339	42		 inc	 edx
  0033a	41		 inc	 ecx
  0033b	83 c6 02	 add	 esi, 2

; 275  :                 left <<= 1;

  0033e	03 c0		 add	 eax, eax
  00340	3b 55 ec	 cmp	 edx, DWORD PTR _max$[ebp]
  00343	72 eb		 jb	 SHORT $LL7@inflate_ta
$LN101@inflate_ta:

; 271  :             while (curr + drop < max) {

  00345	8b 75 c4	 mov	 esi, DWORD PTR tv614[ebp]
$LN80@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  00348	8b 55 d8	 mov	 edx, DWORD PTR _used$[ebp]

; 280  :             if ((type == LENS && used > ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used > ENOUGH_DISTS))

  0034b	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0034e	bf 01 00 00 00	 mov	 edi, 1
  00353	d3 e7		 shl	 edi, cl
  00355	03 d7		 add	 edx, edi
  00357	89 7d d4	 mov	 DWORD PTR tv585[ebp], edi
  0035a	89 55 d8	 mov	 DWORD PTR _used$[ebp], edx
  0035d	83 f8 01	 cmp	 eax, 1
  00360	75 08		 jne	 SHORT $LN2@inflate_ta
  00362	81 fa 54 03 00
	00		 cmp	 edx, 852		; 00000354H
  00368	eb 0b		 jmp	 SHORT $LN111@inflate_ta
$LN2@inflate_ta:
  0036a	83 f8 02	 cmp	 eax, 2
  0036d	75 08		 jne	 SHORT $LN4@inflate_ta
  0036f	81 fa 50 02 00
	00		 cmp	 edx, 592		; 00000250H
$LN111@inflate_ta:
  00375	77 6a		 ja	 SHORT $LN3@inflate_ta
$LN4@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  00377	8b d6		 mov	 edx, esi

; 286  :             (*table)[low].op = (unsigned char)curr;

  00379	8b 75 14	 mov	 esi, DWORD PTR _table$[ebp]
  0037c	8b 06		 mov	 eax, DWORD PTR [esi]
  0037e	88 0c 90	 mov	 BYTE PTR [eax+edx*4], cl

; 287  :             (*table)[low].bits = (unsigned char)root;

  00381	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00383	8a 45 fc	 mov	 al, BYTE PTR _root$[ebp]
  00386	88 44 91 01	 mov	 BYTE PTR [ecx+edx*4+1], al

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  0038a	8b 06		 mov	 eax, DWORD PTR [esi]
  0038c	8b 4d e8	 mov	 ecx, DWORD PTR _next$[ebp]
  0038f	2b c8		 sub	 ecx, eax
  00391	c1 f9 02	 sar	 ecx, 2
  00394	89 55 d0	 mov	 DWORD PTR _low$[ebp], edx
  00397	66 89 4c 90 02	 mov	 WORD PTR [eax+edx*4+2], cx

; 289  :         }
; 290  :     }

  0039c	e9 62 fe ff ff	 jmp	 $LL24@inflate_ta
$LN81@inflate_ta:

; 291  : 
; 292  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 293  :        at most one remaining entry, since if the code is incomplete, the
; 294  :        maximum code length that was allowed to get this far is one bit) */
; 295  :     if (huff != 0) {

  003a1	8b 45 f8	 mov	 eax, DWORD PTR _huff$[ebp]
  003a4	85 c0		 test	 eax, eax
  003a6	74 19		 je	 SHORT $LN1@inflate_ta

; 296  :         here.op = (unsigned char)64;            /* invalid code marker */
; 297  :         here.bits = (unsigned char)(len - drop);

  003a8	2a 5d f4	 sub	 bl, BYTE PTR _drop$[ebp]

; 298  :         here.val = (unsigned short)0;

  003ab	33 d2		 xor	 edx, edx
  003ad	66 89 55 12	 mov	 WORD PTR _here$[ebp+2], dx

; 299  :         next[huff] = here;

  003b1	8b 55 e8	 mov	 edx, DWORD PTR _next$[ebp]
  003b4	c6 45 10 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H
  003b8	88 5d 11	 mov	 BYTE PTR _here$[ebp+1], bl
  003bb	8b 4d 10	 mov	 ecx, DWORD PTR _here$[ebp]
  003be	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
$LN1@inflate_ta:

; 300  :     }
; 301  : 
; 302  :     /* set return parameters */
; 303  :     *table += used;

  003c1	8b 45 d8	 mov	 eax, DWORD PTR _used$[ebp]

; 304  :     *bits = root;

  003c4	8b 55 fc	 mov	 edx, DWORD PTR _root$[ebp]
  003c7	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  003ce	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  003d1	01 08		 add	 DWORD PTR [eax], ecx
  003d3	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  003d6	5f		 pop	 edi
  003d7	5e		 pop	 esi
  003d8	89 10		 mov	 DWORD PTR [eax], edx

; 305  :     return 0;

  003da	33 c0		 xor	 eax, eax
  003dc	5b		 pop	 ebx

; 306  : }

  003dd	8b e5		 mov	 esp, ebp
  003df	5d		 pop	 ebp
  003e0	c3		 ret	 0
$LN3@inflate_ta:
  003e1	5f		 pop	 edi
  003e2	5e		 pop	 esi

; 282  :                 return 1;

  003e3	b8 01 00 00 00	 mov	 eax, 1
  003e8	5b		 pop	 ebx

; 306  : }

  003e9	8b e5		 mov	 esp, ebp
  003eb	5d		 pop	 ebp
  003ec	c3		 ret	 0
_inflate_table ENDP
END
