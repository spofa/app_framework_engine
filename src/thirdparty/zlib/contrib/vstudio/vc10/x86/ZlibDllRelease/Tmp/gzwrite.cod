; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_gz_init PROC						; COMDAT
; _state$ = esi

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = (unsigned char *)malloc(state->want);

  00000	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	50		 push	 eax
  00006	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  00009	e8 00 00 00 00	 call	 _malloc
  0000e	8b d8		 mov	 ebx, eax
  00010	83 c4 04	 add	 esp, 4
  00013	89 5e 24	 mov	 DWORD PTR [esi+36], ebx

; 23   :     if (state->in == NULL) {

  00016	85 db		 test	 ebx, ebx

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");
; 25   :         return -1;

  00018	74 28		 je	 SHORT $LN9@gz_init

; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  0001a	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  0001e	0f 85 89 00 00
	00		 jne	 $LN8@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = (unsigned char *)malloc(state->want);

  00024	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _malloc

; 32   :         if (state->out == NULL) {

  0002d	33 c9		 xor	 ecx, ecx
  0002f	83 c4 04	 add	 esp, 4
  00032	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00035	3b c1		 cmp	 eax, ecx
  00037	75 20		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00039	53		 push	 ebx
  0003a	e8 00 00 00 00	 call	 _free
  0003f	83 c4 04	 add	 esp, 4
$LN9@gz_init:

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00042	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00047	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 _gz_error
  00053	5f		 pop	 edi

; 35   :             return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5b		 pop	 ebx

; 62   : }

  00058	c3		 ret	 0
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;
; 40   :         strm->zfree = Z_NULL;
; 41   :         strm->opaque = Z_NULL;
; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  00059	6a 38		 push	 56			; 00000038H
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  00060	89 4f 20	 mov	 DWORD PTR [edi+32], ecx
  00063	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
  00066	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
  00069	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0006c	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0006f	50		 push	 eax
  00070	6a 08		 push	 8
  00072	6a 1f		 push	 31			; 0000001fH
  00074	6a 08		 push	 8
  00076	51		 push	 ecx
  00077	57		 push	 edi
  00078	e8 00 00 00 00	 call	 _deflateInit2_@32

; 44   :         if (ret != Z_OK) {

  0007d	85 c0		 test	 eax, eax
  0007f	74 2c		 je	 SHORT $LN8@gz_init

; 45   :             free(state->out);

  00081	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _free

; 46   :             free(state->in);

  0008a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _free
  00093	83 c4 08	 add	 esp, 8

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00096	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0009b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000a0	8b ce		 mov	 ecx, esi
  000a2	e8 00 00 00 00	 call	 _gz_error
  000a7	5f		 pop	 edi

; 48   :             return -1;

  000a8	83 c8 ff	 or	 eax, -1
  000ab	5b		 pop	 ebx

; 62   : }

  000ac	c3		 ret	 0
$LN8@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;
; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  000ad	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  000b1	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000b4	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000b7	75 0c		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  000b9	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 58   :         strm->next_out = state->out;

  000bc	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000bf	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 59   :         state->x.next = strm->next_out;

  000c2	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  000c5	5f		 pop	 edi
  000c6	33 c0		 xor	 eax, eax
  000c8	5b		 pop	 ebx

; 62   : }

  000c9	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_flush$ = 8						; size = 4
_gz_comp PROC						; COMDAT
; _state$ = eax

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f0		 mov	 esi, eax

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);
; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  00006	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0000a	57		 push	 edi
  0000b	8d 7e 64	 lea	 edi, DWORD PTR [esi+100]
  0000e	75 10		 jne	 SHORT $LN21@gz_comp
  00010	e8 00 00 00 00	 call	 _gz_init
  00015	83 f8 ff	 cmp	 eax, -1
  00018	75 06		 jne	 SHORT $LN21@gz_comp

; 80   :         return -1;

  0001a	5f		 pop	 edi
  0001b	0b c0		 or	 eax, eax
  0001d	5e		 pop	 esi

; 130  : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN21@gz_comp:

; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	53		 push	 ebx
  00025	74 4e		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  00027	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0002c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _write
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  0003a	85 c0		 test	 eax, eax
  0003c	78 13		 js	 SHORT $LN12@gz_comp
  0003e	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00041	75 0e		 jne	 SHORT $LN12@gz_comp

; 88   :         }
; 89   :         strm->avail_in = 0;

  00043	5b		 pop	 ebx
  00044	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0004b	5f		 pop	 edi

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5e		 pop	 esi

; 130  : }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  00051	e8 00 00 00 00	 call	 __errno
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _strerror
  0005e	8b d8		 mov	 ebx, eax
  00060	83 c4 04	 add	 esp, 4
  00063	83 c8 ff	 or	 eax, -1
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 _gz_error
  0006d	5b		 pop	 ebx
  0006e	5f		 pop	 edi

; 87   :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	5e		 pop	 esi

; 130  : }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN14@gz_comp:

; 90   :         return 0;
; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  00075	33 c0		 xor	 eax, eax
$LL11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00077	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0007b	74 11		 je	 SHORT $LN22@gz_comp
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _flush$[ebp]
  00080	85 c9		 test	 ecx, ecx
  00082	74 45		 je	 SHORT $LN8@gz_comp
  00084	83 f9 04	 cmp	 ecx, 4
  00087	75 05		 jne	 SHORT $LN22@gz_comp
  00089	83 f8 01	 cmp	 eax, 1
  0008c	75 3b		 jne	 SHORT $LN8@gz_comp
$LN22@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  0008e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00091	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00094	2b d8		 sub	 ebx, eax

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  00096	74 16		 je	 SHORT $LN23@gz_comp
  00098	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0009b	53		 push	 ebx
  0009c	50		 push	 eax
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _write
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	85 c0		 test	 eax, eax
  000a8	78 46		 js	 SHORT $LN4@gz_comp
  000aa	3b c3		 cmp	 eax, ebx
  000ac	75 42		 jne	 SHORT $LN4@gz_comp
$LN23@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  000ae	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  000b2	75 0c		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  000b4	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  000b7	89 57 10	 mov	 DWORD PTR [edi+16], edx

; 108  :                 strm->next_out = state->out;

  000ba	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000bd	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  000c0	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000c3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _flush$[ebp]
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  000c9	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]

; 115  :         ret = deflate(strm, flush);

  000cc	51		 push	 ecx
  000cd	57		 push	 edi
  000ce	e8 00 00 00 00	 call	 _deflate@8

; 116  :         if (ret == Z_STREAM_ERROR) {

  000d3	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  000d6	74 3c		 je	 SHORT $LN20@gz_comp

; 120  :         }
; 121  :         have -= strm->avail_out;

  000d8	2b 5f 10	 sub	 ebx, DWORD PTR [edi+16]

; 122  :     } while (have);

  000db	75 9a		 jne	 SHORT $LL11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  000dd	83 7d 08 04	 cmp	 DWORD PTR _flush$[ebp], 4
  000e1	75 06		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  000e3	57		 push	 edi
  000e4	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  000e9	5b		 pop	 ebx
  000ea	5f		 pop	 edi
  000eb	33 c0		 xor	 eax, eax
  000ed	5e		 pop	 esi

; 130  : }

  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  000f0	e8 00 00 00 00	 call	 __errno
  000f5	8b 10		 mov	 edx, DWORD PTR [eax]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 _strerror
  000fd	8b d8		 mov	 ebx, eax
  000ff	83 c4 04	 add	 esp, 4
  00102	83 c8 ff	 or	 eax, -1
  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 _gz_error
  0010c	5b		 pop	 ebx
  0010d	5f		 pop	 edi

; 104  :                 return -1;

  0010e	83 c8 ff	 or	 eax, -1
  00111	5e		 pop	 esi

; 130  : }

  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN20@gz_comp:

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  00114	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00119	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0011e	8b ce		 mov	 ecx, esi
  00120	e8 00 00 00 00	 call	 _gz_error
  00125	5b		 pop	 ebx
  00126	5f		 pop	 edi

; 119  :             return -1;

  00127	83 c8 ff	 or	 eax, -1
  0012a	5e		 pop	 esi

; 130  : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Ogtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
_first$ = -4						; size = 4
_len$ = 8						; size = 8
_gz_zero PROC						; COMDAT
; _state$ = esi

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);
; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00004	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00008	74 17		 je	 SHORT $LN5@gz_zero
  0000a	6a 00		 push	 0
  0000c	8b c6		 mov	 eax, esi
  0000e	e8 00 00 00 00	 call	 _gz_comp
  00013	83 c4 04	 add	 esp, 4
  00016	83 f8 ff	 cmp	 eax, -1
  00019	75 06		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  0001b	0b c0		 or	 eax, eax

; 160  :     }
; 161  :     return 0;
; 162  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN5@gz_zero:
  00021	53		 push	 ebx
  00022	57		 push	 edi

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;
; 147  :     while (len) {

  00023	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  00026	8b c7		 mov	 eax, edi
  00028	0b 45 0c	 or	 eax, DWORD PTR _len$[ebp+4]
  0002b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
  00032	75 0f		 jne	 SHORT $LN4@gz_zero
  00034	5f		 pop	 edi
  00035	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL14@gz_zero:

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;
; 147  :     while (len) {

  00040	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
$LN4@gz_zero:

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00043	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00046	33 c0		 xor	 eax, eax
  00048	33 db		 xor	 ebx, ebx
  0004a	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp+4]
  0004d	7f 08		 jg	 SHORT $LN8@gz_zero
  0004f	7c 04		 jl	 SHORT $LN13@gz_zero
  00051	3b cf		 cmp	 ecx, edi
  00053	77 02		 ja	 SHORT $LN8@gz_zero
$LN13@gz_zero:
  00055	8b f9		 mov	 edi, ecx
$LN8@gz_zero:

; 150  :         if (first) {

  00057	39 5d fc	 cmp	 DWORD PTR _first$[ebp], ebx
  0005a	74 11		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  0005c	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0005f	57		 push	 edi
  00060	53		 push	 ebx
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :             first = 0;

  0006a	89 5d fc	 mov	 DWORD PTR _first$[ebp], ebx
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  0006d	89 7e 68	 mov	 DWORD PTR [esi+104], edi

; 155  :         strm->next_in = state->in;

  00070	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00073	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 156  :         state->x.pos += n;

  00076	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00079	53		 push	 ebx
  0007a	8b c6		 mov	 eax, esi
  0007c	11 5e 0c	 adc	 DWORD PTR [esi+12], ebx
  0007f	e8 00 00 00 00	 call	 _gz_comp
  00084	83 c4 04	 add	 esp, 4
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 1a		 je	 SHORT $LN11@gz_zero

; 159  :         len -= n;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _len$[ebp]
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00092	2b c7		 sub	 eax, edi
  00094	1b cb		 sbb	 ecx, ebx
  00096	89 45 08	 mov	 DWORD PTR _len$[ebp], eax
  00099	0b c1		 or	 eax, ecx
  0009b	89 4d 0c	 mov	 DWORD PTR _len$[ebp+4], ecx
  0009e	75 a0		 jne	 SHORT $LL14@gz_zero
  000a0	5f		 pop	 edi
  000a1	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN11@gz_zero:
  000a6	5f		 pop	 edi

; 158  :             return -1;

  000a7	83 c8 ff	 or	 eax, -1
  000aa	5b		 pop	 ebx

; 160  :     }
; 161  :     return 0;
; 162  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Ogtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 541  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 542  :     int ret = Z_OK;
; 543  :     gz_statep state;
; 544  : 
; 545  :     /* get internal structure */
; 546  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	85 f6		 test	 esi, esi
  0000c	75 0b		 jne	 SHORT $LN8@gzclose_w
$LN12@gzclose_w:
  0000e	5f		 pop	 edi

; 547  :         return Z_STREAM_ERROR;

  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00014	5e		 pop	 esi

; 577  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN8@gzclose_w:

; 548  :     state = (gz_statep)file;
; 549  : 
; 550  :     /* check that we're writing */
; 551  :     if (state->mode != GZ_WRITE)

  00019	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H

; 552  :         return Z_STREAM_ERROR;

  00020	75 ec		 jne	 SHORT $LN12@gzclose_w

; 553  : 
; 554  :     /* check for seek request */
; 555  :     if (state->seek) {

  00022	39 7e 58	 cmp	 DWORD PTR [esi+88], edi
  00025	74 1b		 je	 SHORT $LN11@gzclose_w

; 556  :         state->seek = 0;
; 557  :         if (gz_zero(state, state->skip) == -1)

  00027	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0002a	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00032	e8 00 00 00 00	 call	 _gz_zero
  00037	83 c4 08	 add	 esp, 8
  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	75 03		 jne	 SHORT $LN11@gzclose_w

; 558  :             ret = state->err;

  0003f	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
$LN11@gzclose_w:

; 559  :     }
; 560  : 
; 561  :     /* flush, free memory, and close file */
; 562  :     if (gz_comp(state, Z_FINISH) == -1)

  00042	6a 04		 push	 4
  00044	8b c6		 mov	 eax, esi
  00046	e8 00 00 00 00	 call	 _gz_comp
  0004b	83 c4 04	 add	 esp, 4
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 03		 jne	 SHORT $LN4@gzclose_w

; 563  :         ret = state->err;

  00053	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
$LN4@gzclose_w:

; 564  :     if (state->size) {

  00056	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0005a	74 27		 je	 SHORT $LN3@gzclose_w

; 565  :         if (!state->direct) {

  0005c	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00060	75 15		 jne	 SHORT $LN2@gzclose_w

; 566  :             (void)deflateEnd(&(state->strm));

  00062	8d 56 64	 lea	 edx, DWORD PTR [esi+100]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _deflateEnd@4

; 567  :             free(state->out);

  0006b	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _free
  00074	83 c4 04	 add	 esp, 4
$LN2@gzclose_w:

; 568  :         }
; 569  :         free(state->in);

  00077	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN3@gzclose_w:

; 570  :     }
; 571  :     gz_error(state, Z_OK, NULL);

  00083	53		 push	 ebx
  00084	33 db		 xor	 ebx, ebx
  00086	33 c0		 xor	 eax, eax
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 _gz_error

; 572  :     free(state->path);

  0008f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _free

; 573  :     if (close(state->fd) == -1)

  00098	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _close
  000a1	83 c4 08	 add	 esp, 8
  000a4	5b		 pop	 ebx
  000a5	83 f8 ff	 cmp	 eax, -1
  000a8	75 02		 jne	 SHORT $LN1@gzclose_w

; 574  :         ret = Z_ERRNO;

  000aa	0b f8		 or	 edi, eax
$LN1@gzclose_w:

; 575  :     free(state);

  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 _free
  000b2	83 c4 04	 add	 esp, 4

; 576  :     return ret;

  000b5	8b c7		 mov	 eax, edi
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi

; 577  : }

  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Ogtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 502  :     gz_statep state;
; 503  :     z_streamp strm;
; 504  : 
; 505  :     /* get internal structure */
; 506  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 0a		 jne	 SHORT $LN8@gzsetparam
$LN6@gzsetparam:

; 507  :         return Z_STREAM_ERROR;

  0000b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00010	5e		 pop	 esi

; 536  : }

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
$LN8@gzsetparam:

; 508  :     state = (gz_statep)file;
; 509  :     strm = &(state->strm);
; 510  : 
; 511  :     /* check that we're writing and that there's no error */
; 512  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001c	75 ed		 jne	 SHORT $LN6@gzsetparam
  0001e	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00022	75 e7		 jne	 SHORT $LN6@gzsetparam

; 513  :         return Z_STREAM_ERROR;
; 514  : 
; 515  :     /* if no change is requested, then do nothing */
; 516  :     if (level == state->level && strategy == state->strategy)

  00024	53		 push	 ebx
  00025	8b 5d 10	 mov	 ebx, DWORD PTR _strategy$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 0c	 mov	 edi, DWORD PTR _level$[ebp]
  0002c	3b 7e 48	 cmp	 edi, DWORD PTR [esi+72]
  0002f	75 05		 jne	 SHORT $LN5@gzsetparam
  00031	3b 5e 4c	 cmp	 ebx, DWORD PTR [esi+76]

; 517  :         return Z_OK;

  00034	74 63		 je	 SHORT $LN14@gzsetparam
$LN5@gzsetparam:

; 518  : 
; 519  :     /* check for seek request */
; 520  :     if (state->seek) {

  00036	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0003a	74 25		 je	 SHORT $LN11@gzsetparam

; 521  :         state->seek = 0;
; 522  :         if (gz_zero(state, state->skip) == -1)

  0003c	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0003f	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00042	50		 push	 eax
  00043	51		 push	 ecx
  00044	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004b	e8 00 00 00 00	 call	 _gz_zero
  00050	83 c4 08	 add	 esp, 8
  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 09		 jne	 SHORT $LN11@gzsetparam

; 523  :             return -1;

  00058	5f		 pop	 edi
  00059	5b		 pop	 ebx
  0005a	0b c0		 or	 eax, eax
  0005c	5e		 pop	 esi

; 536  : }

  0005d	5d		 pop	 ebp
  0005e	c2 0c 00	 ret	 12			; 0000000cH
$LN11@gzsetparam:

; 524  :     }
; 525  : 
; 526  :     /* change compression parameters for subsequent input */
; 527  :     if (state->size) {

  00061	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00065	74 2c		 je	 SHORT $LN2@gzsetparam

; 528  :         /* flush previous input with previous parameters before changing */
; 529  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00067	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  0006b	74 1b		 je	 SHORT $LN1@gzsetparam
  0006d	6a 01		 push	 1
  0006f	8b c6		 mov	 eax, esi
  00071	e8 00 00 00 00	 call	 _gz_comp
  00076	83 c4 04	 add	 esp, 4
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	75 0a		 jne	 SHORT $LN1@gzsetparam

; 530  :             return state->err;

  0007e	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00081	5f		 pop	 edi
  00082	5b		 pop	 ebx
  00083	5e		 pop	 esi

; 536  : }

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
$LN1@gzsetparam:

; 531  :         deflateParams(strm, level, strategy);

  00088	53		 push	 ebx
  00089	57		 push	 edi
  0008a	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 532  :     }
; 533  :     state->level = level;

  00093	89 7e 48	 mov	 DWORD PTR [esi+72], edi

; 534  :     state->strategy = strategy;

  00096	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
$LN14@gzsetparam:

; 535  :     return Z_OK;

  00099	5f		 pop	 edi
  0009a	5b		 pop	 ebx
  0009b	33 c0		 xor	 eax, eax
  0009d	5e		 pop	 esi

; 536  : }

  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Ogtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 469  :     gz_statep state;
; 470  : 
; 471  :     /* get internal structure */
; 472  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN7@gzflush

; 473  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 494  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN7@gzflush:

; 474  :     state = (gz_statep)file;
; 475  : 
; 476  :     /* check that we're writing and that there's no error */
; 477  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 58		 jne	 SHORT $LN5@gzflush
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 52		 jne	 SHORT $LN5@gzflush

; 479  : 
; 480  :     /* check flush parameter */
; 481  :     if (flush < 0 || flush > Z_FINISH)

  00022	57		 push	 edi
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _flush$[ebp]
  00026	83 ff 04	 cmp	 edi, 4
  00029	77 3e		 ja	 SHORT $LN3@gzflush

; 483  : 
; 484  :     /* check for seek request */
; 485  :     if (state->seek) {

  0002b	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0002f	74 24		 je	 SHORT $LN1@gzflush

; 486  :         state->seek = 0;
; 487  :         if (gz_zero(state, state->skip) == -1)

  00031	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00034	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00040	e8 00 00 00 00	 call	 _gz_zero
  00045	83 c4 08	 add	 esp, 8
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	75 08		 jne	 SHORT $LN1@gzflush

; 488  :             return -1;

  0004d	5f		 pop	 edi
  0004e	0b c0		 or	 eax, eax
  00050	5e		 pop	 esi

; 494  : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
$LN1@gzflush:

; 489  :     }
; 490  : 
; 491  :     /* compress remaining data with requested flush */
; 492  :     gz_comp(state, flush);

  00055	57		 push	 edi
  00056	8b c6		 mov	 eax, esi
  00058	e8 00 00 00 00	 call	 _gz_comp

; 493  :     return state->err;

  0005d	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00060	83 c4 04	 add	 esp, 4
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 494  : }

  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
$LN3@gzflush:
  00069	5f		 pop	 edi

; 482  :         return Z_STREAM_ERROR;

  0006a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006f	5e		 pop	 esi

; 494  : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
$LN5@gzflush:

; 478  :         return Z_STREAM_ERROR;

  00074	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00079	5e		 pop	 esi

; 494  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzvprintf
; Function compile flags: /Ogtp
;	COMDAT _gzvprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_va$ = 16						; size = 4
_gzvprintf PROC						; COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 312  :     int size, len;
; 313  :     gz_statep state;
; 314  :     z_streamp strm;
; 315  : 
; 316  :     /* get internal structure */
; 317  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN9@gzvprintf

; 318  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 370  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN9@gzvprintf:

; 319  :     state = (gz_statep)file;
; 320  :     strm = &(state->strm);
; 321  : 
; 322  :     /* check that we're writing and that there's no error */
; 323  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  00018	75 16		 jne	 SHORT $LN13@gzvprintf
  0001a	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  0001e	75 10		 jne	 SHORT $LN13@gzvprintf

; 324  :         return 0;
; 325  : 
; 326  :     /* make sure we have some buffer space */
; 327  :     if (state->size == 0 && gz_init(state) == -1)

  00020	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00024	75 0f		 jne	 SHORT $LN6@gzvprintf
  00026	e8 00 00 00 00	 call	 _gz_init
  0002b	83 f8 ff	 cmp	 eax, -1
  0002e	75 05		 jne	 SHORT $LN6@gzvprintf
$LN13@gzvprintf:

; 328  :         return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 370  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN6@gzvprintf:

; 329  : 
; 330  :     /* check for seek request */
; 331  :     if (state->seek) {

  00035	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00039	74 1c		 je	 SHORT $LN4@gzvprintf

; 332  :         state->seek = 0;
; 333  :         if (gz_zero(state, state->skip) == -1)

  0003b	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0003e	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  0004a	e8 00 00 00 00	 call	 _gz_zero
  0004f	83 c4 08	 add	 esp, 8
  00052	83 f8 ff	 cmp	 eax, -1

; 334  :             return 0;

  00055	74 d9		 je	 SHORT $LN13@gzvprintf
$LN4@gzvprintf:

; 335  :     }
; 336  : 
; 337  :     /* consume whatever's left in the input buffer */
; 338  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00057	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  0005b	74 11		 je	 SHORT $LN3@gzvprintf
  0005d	6a 00		 push	 0
  0005f	8b c6		 mov	 eax, esi
  00061	e8 00 00 00 00	 call	 _gz_comp
  00066	83 c4 04	 add	 esp, 4
  00069	83 f8 ff	 cmp	 eax, -1

; 339  :         return 0;

  0006c	74 c2		 je	 SHORT $LN13@gzvprintf
$LN3@gzvprintf:

; 340  : 
; 341  :     /* do the printf() into the input buffer, put length in len */
; 342  :     size = (int)(state->size);
; 343  :     state->in[size - 1] = 0;
; 344  : #ifdef NO_vsnprintf
; 345  : #  ifdef HAS_vsprintf_void
; 346  :     (void)vsprintf((char *)(state->in), format, va);
; 347  :     for (len = 0; len < size; len++)
; 348  :         if (state->in[len] == 0) break;
; 349  : #  else
; 350  :     len = vsprintf((char *)(state->in), format, va);
; 351  : #  endif
; 352  : #else
; 353  : #  ifdef HAS_vsnprintf_void
; 354  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 355  :     len = strlen((char *)(state->in));
; 356  : #  else
; 357  :     len = vsnprintf((char *)(state->in), size, format, va);

  0006e	8b 45 10	 mov	 eax, DWORD PTR _va$[ebp]
  00071	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  00077	57		 push	 edi
  00078	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0007b	50		 push	 eax
  0007c	51		 push	 ecx
  0007d	c6 44 17 ff 00	 mov	 BYTE PTR [edi+edx-1], 0
  00082	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00085	57		 push	 edi
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _vsnprintf
  0008c	8b c8		 mov	 ecx, eax
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 358  : #  endif
; 359  : #endif
; 360  : 
; 361  :     /* check that printf() results fit in buffer */
; 362  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  00091	85 c9		 test	 ecx, ecx
  00093	7e 26		 jle	 SHORT $LN1@gzvprintf
  00095	3b cf		 cmp	 ecx, edi
  00097	7d 22		 jge	 SHORT $LN1@gzvprintf
  00099	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0009c	80 7c 07 ff 00	 cmp	 BYTE PTR [edi+eax-1], 0
  000a1	75 18		 jne	 SHORT $LN1@gzvprintf

; 364  : 
; 365  :     /* update buffer and position, defer compression until needed */
; 366  :     strm->avail_in = (unsigned)len;

  000a3	89 4e 68	 mov	 DWORD PTR [esi+104], ecx

; 367  :     strm->next_in = state->in;

  000a6	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  000a9	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 368  :     state->x.pos += len;

  000ac	8b c1		 mov	 eax, ecx
  000ae	99		 cdq
  000af	01 46 08	 add	 DWORD PTR [esi+8], eax
  000b2	5f		 pop	 edi

; 369  :     return len;

  000b3	8b c1		 mov	 eax, ecx
  000b5	11 56 0c	 adc	 DWORD PTR [esi+12], edx
  000b8	5e		 pop	 esi

; 370  : }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN1@gzvprintf:
  000bb	5f		 pop	 edi

; 363  :         return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	5e		 pop	 esi

; 370  : }

  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_gzvprintf ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Ogtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_put$ = 16						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 170  :     unsigned put = len;

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00007	56		 push	 esi

; 171  :     gz_statep state;
; 172  :     z_streamp strm;
; 173  : 
; 174  :     /* get internal structure */
; 175  :     if (file == NULL)

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	89 5d 10	 mov	 DWORD PTR _put$[ebp], ebx
  00011	3b f7		 cmp	 esi, edi

; 176  :         return 0;

  00013	74 21		 je	 SHORT $LN16@gzwrite

; 177  :     state = (gz_statep)file;
; 178  :     strm = &(state->strm);
; 179  : 
; 180  :     /* check that we're writing and that there's no error */
; 181  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001c	75 18		 jne	 SHORT $LN16@gzwrite
  0001e	39 7e 5c	 cmp	 DWORD PTR [esi+92], edi
  00021	75 13		 jne	 SHORT $LN16@gzwrite

; 183  : 
; 184  :     /* since an int is returned, make sure len fits in one, otherwise return
; 185  :        with an error (this avoids the flaw in the interface) */
; 186  :     if ((int)len < 0) {

  00023	3b df		 cmp	 ebx, edi
  00025	7d 18		 jge	 SHORT $LN28@gzwrite

; 187  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00027	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0002c	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 _gz_error
$LN16@gzwrite:

; 182  :         return 0;

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	33 c0		 xor	 eax, eax
  0003a	5b		 pop	 ebx

; 242  : }

  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
$LN28@gzwrite:

; 188  :         return 0;
; 189  :     }
; 190  : 
; 191  :     /* if len is zero, avoid unnecessary operations */
; 192  :     if (len == 0)
; 193  :         return 0;

  0003f	74 f5		 je	 SHORT $LN16@gzwrite

; 194  : 
; 195  :     /* allocate memory if this is the first time through */
; 196  :     if (state->size == 0 && gz_init(state) == -1)

  00041	39 7e 1c	 cmp	 DWORD PTR [esi+28], edi
  00044	75 0a		 jne	 SHORT $LN24@gzwrite
  00046	e8 00 00 00 00	 call	 _gz_init
  0004b	83 f8 ff	 cmp	 eax, -1

; 197  :         return 0;

  0004e	74 e6		 je	 SHORT $LN16@gzwrite
$LN24@gzwrite:

; 198  : 
; 199  :     /* check for seek request */
; 200  :     if (state->seek) {

  00050	39 7e 58	 cmp	 DWORD PTR [esi+88], edi
  00053	74 18		 je	 SHORT $LN27@gzwrite

; 201  :         state->seek = 0;
; 202  :         if (gz_zero(state, state->skip) == -1)

  00055	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00058	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0005b	50		 push	 eax
  0005c	51		 push	 ecx
  0005d	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00060	e8 00 00 00 00	 call	 _gz_zero
  00065	83 c4 08	 add	 esp, 8
  00068	83 f8 ff	 cmp	 eax, -1

; 203  :             return 0;

  0006b	74 c9		 je	 SHORT $LN16@gzwrite
$LN27@gzwrite:

; 204  :     }
; 205  : 
; 206  :     /* for small len, copy to input buffer, otherwise compress directly */
; 207  :     if (len < state->size) {

  0006d	3b 5e 1c	 cmp	 ebx, DWORD PTR [esi+28]
  00070	73 5d		 jae	 SHORT $LN10@gzwrite
$LL9@gzwrite:

; 208  :         /* copy to input buffer, compress when full */
; 209  :         do {
; 210  :             unsigned have, copy;
; 211  : 
; 212  :             if (strm->avail_in == 0)

  00072	8b 56 68	 mov	 edx, DWORD PTR [esi+104]
  00075	85 d2		 test	 edx, edx
  00077	75 06		 jne	 SHORT $LN6@gzwrite

; 213  :                 strm->next_in = state->in;

  00079	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0007c	89 46 64	 mov	 DWORD PTR [esi+100], eax
$LN6@gzwrite:

; 214  :             have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  0007f	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00082	8b 46 64	 mov	 eax, DWORD PTR [esi+100]

; 215  :             copy = state->size - have;

  00085	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00088	2b c1		 sub	 eax, ecx
  0008a	03 c2		 add	 eax, edx
  0008c	2b f8		 sub	 edi, eax

; 216  :             if (copy > len)

  0008e	3b fb		 cmp	 edi, ebx
  00090	76 02		 jbe	 SHORT $LN5@gzwrite

; 217  :                 copy = len;

  00092	8b fb		 mov	 edi, ebx
$LN5@gzwrite:

; 218  :             memcpy(state->in + have, buf, copy);

  00094	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00097	57		 push	 edi
  00098	52		 push	 edx
  00099	03 c8		 add	 ecx, eax
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _memcpy

; 219  :             strm->avail_in += copy;

  000a1	01 7e 68	 add	 DWORD PTR [esi+104], edi
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  :             state->x.pos += copy;

  000a7	01 7e 08	 add	 DWORD PTR [esi+8], edi
  000aa	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 221  :             buf = (const char *)buf + copy;

  000ae	01 7d 0c	 add	 DWORD PTR _buf$[ebp], edi

; 222  :             len -= copy;

  000b1	2b df		 sub	 ebx, edi

; 223  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000b3	74 56		 je	 SHORT $LN26@gzwrite
  000b5	6a 00		 push	 0
  000b7	8b c6		 mov	 eax, esi
  000b9	e8 00 00 00 00	 call	 _gz_comp
  000be	83 c4 04	 add	 esp, 4
  000c1	83 f8 ff	 cmp	 eax, -1
  000c4	75 ac		 jne	 SHORT $LL9@gzwrite

; 182  :         return 0;

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	33 c0		 xor	 eax, eax
  000ca	5b		 pop	 ebx

; 242  : }

  000cb	5d		 pop	 ebp
  000cc	c2 0c 00	 ret	 12			; 0000000cH
$LN10@gzwrite:

; 224  :                 return 0;
; 225  :         } while (len);
; 226  :     }
; 227  :     else {
; 228  :         /* consume whatever's left in the input buffer */
; 229  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000cf	39 7e 68	 cmp	 DWORD PTR [esi+104], edi
  000d2	74 14		 je	 SHORT $LN2@gzwrite
  000d4	57		 push	 edi
  000d5	8b c6		 mov	 eax, esi
  000d7	e8 00 00 00 00	 call	 _gz_comp
  000dc	83 c4 04	 add	 esp, 4
  000df	83 f8 ff	 cmp	 eax, -1

; 230  :             return 0;

  000e2	0f 84 4e ff ff
	ff		 je	 $LN16@gzwrite
$LN2@gzwrite:

; 231  : 
; 232  :         /* directly compress user buffer to file */
; 233  :         strm->avail_in = len;
; 234  :         strm->next_in = (z_const Bytef *)buf;

  000e8	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000eb	89 46 64	 mov	 DWORD PTR [esi+100], eax
  000ee	89 5e 68	 mov	 DWORD PTR [esi+104], ebx

; 235  :         state->x.pos += len;

  000f1	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 236  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000f4	57		 push	 edi
  000f5	8b c6		 mov	 eax, esi
  000f7	11 7e 0c	 adc	 DWORD PTR [esi+12], edi
  000fa	e8 00 00 00 00	 call	 _gz_comp
  000ff	83 c4 04	 add	 esp, 4
  00102	83 f8 ff	 cmp	 eax, -1

; 237  :             return 0;

  00105	0f 84 2b ff ff
	ff		 je	 $LN16@gzwrite
$LN26@gzwrite:

; 238  :     }
; 239  : 
; 240  :     /* input was all buffered or compressed (put will fit in int) */
; 241  :     return (int)put;

  0010b	8b 45 10	 mov	 eax, DWORD PTR _put$[ebp]
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx

; 242  : }

  00111	5d		 pop	 ebp
  00112	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
PUBLIC	_gzprintf
; Function compile flags: /Ogtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 374  :     va_list va;
; 375  :     int ret;
; 376  : 
; 377  :     va_start(va, format);
; 378  :     ret = gzvprintf(file, format, va);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00009	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _gzvprintf
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 379  :     va_end(va);
; 380  :     return ret;
; 381  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzputs@8
; Function compile flags: /Ogtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  :     int ret;
; 298  :     unsigned len;
; 299  : 
; 300  :     /* write string */
; 301  :     len = (unsigned)strlen(str);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$LL5@gzputs:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL5@gzputs
  00017	2b c6		 sub	 eax, esi
  00019	8b f0		 mov	 esi, eax

; 302  :     ret = gzwrite(file, str, len);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001e	56		 push	 esi
  0001f	52		 push	 edx
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gzwrite@12

; 303  :     return ret == 0 && len != 0 ? -1 : ret;

  00026	85 c0		 test	 eax, eax
  00028	75 07		 jne	 SHORT $LN4@gzputs
  0002a	85 f6		 test	 esi, esi
  0002c	74 03		 je	 SHORT $LN4@gzputs
  0002e	83 c8 ff	 or	 eax, -1
$LN4@gzputs:
  00031	5e		 pop	 esi

; 304  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Ogtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 249  :     unsigned have;
; 250  :     unsigned char buf[1];
; 251  :     gz_statep state;
; 252  :     z_streamp strm;
; 253  : 
; 254  :     /* get internal structure */
; 255  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 08		 jne	 SHORT $LN9@gzputc
$LN13@gzputc:

; 256  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 290  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
$LN9@gzputc:

; 257  :     state = (gz_statep)file;
; 258  :     strm = &(state->strm);
; 259  : 
; 260  :     /* check that we're writing and that there's no error */
; 261  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 7e 10 b1 79
	00 00		 cmp	 DWORD PTR [esi+16], 31153 ; 000079b1H
  0001a	75 ef		 jne	 SHORT $LN13@gzputc
  0001c	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00020	75 e9		 jne	 SHORT $LN13@gzputc

; 262  :         return -1;
; 263  : 
; 264  :     /* check for seek request */
; 265  :     if (state->seek) {

  00022	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00026	74 1c		 je	 SHORT $LN5@gzputc

; 266  :         state->seek = 0;
; 267  :         if (gz_zero(state, state->skip) == -1)

  00028	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0002b	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00037	e8 00 00 00 00	 call	 _gz_zero
  0003c	83 c4 08	 add	 esp, 8
  0003f	83 f8 ff	 cmp	 eax, -1

; 268  :             return -1;

  00042	74 c7		 je	 SHORT $LN13@gzputc
$LN5@gzputc:

; 269  :     }
; 270  : 
; 271  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 272  :        initialized) */
; 273  :     if (state->size) {

  00044	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00048	74 3b		 je	 SHORT $LN2@gzputc

; 274  :         if (strm->avail_in == 0)

  0004a	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0004d	85 c0		 test	 eax, eax
  0004f	75 06		 jne	 SHORT $LN3@gzputc

; 275  :             strm->next_in = state->in;

  00051	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00054	89 56 64	 mov	 DWORD PTR [esi+100], edx
$LN3@gzputc:

; 276  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00057	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0005a	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  0005d	2b ca		 sub	 ecx, edx
  0005f	03 c8		 add	 ecx, eax

; 277  :         if (have < state->size) {

  00061	3b 4e 1c	 cmp	 ecx, DWORD PTR [esi+28]
  00064	73 1f		 jae	 SHORT $LN2@gzputc

; 278  :             state->in[have] = c;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00069	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 279  :             strm->avail_in++;

  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	01 4e 68	 add	 DWORD PTR [esi+104], ecx

; 280  :             state->x.pos++;

  00074	01 4e 08	 add	 DWORD PTR [esi+8], ecx
  00077	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 281  :             return c & 0xff;

  0007b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00080	5e		 pop	 esi

; 290  : }

  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
$LN2@gzputc:
  00085	53		 push	 ebx

; 282  :         }
; 283  :     }
; 284  : 
; 285  :     /* no room in buffer or not initialized, use gz_write() */
; 286  :     buf[0] = c;

  00086	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]

; 287  :     if (gzwrite(file, buf, 1) != 1)

  00089	6a 01		 push	 1
  0008b	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  0008e	50		 push	 eax
  0008f	56		 push	 esi
  00090	88 5d 0b	 mov	 BYTE PTR _buf$[ebp], bl
  00093	e8 00 00 00 00	 call	 _gzwrite@12
  00098	83 f8 01	 cmp	 eax, 1
  0009b	74 09		 je	 SHORT $LN1@gzputc

; 288  :         return -1;

  0009d	5b		 pop	 ebx
  0009e	83 c8 ff	 or	 eax, -1
  000a1	5e		 pop	 esi

; 290  : }

  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
$LN1@gzputc:

; 289  :     return c & 0xff;

  000a6	8b c3		 mov	 eax, ebx
  000a8	5b		 pop	 ebx
  000a9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ae	5e		 pop	 esi

; 290  : }

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
_gzputc@8 ENDP
END
