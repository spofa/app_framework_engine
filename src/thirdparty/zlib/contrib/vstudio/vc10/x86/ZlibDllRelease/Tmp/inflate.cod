; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateMark@4
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4e		 je	 SHORT $LN1@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 47		 je	 SHORT $LN1@inflateMar

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 12		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1512 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN7@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  0002a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002d	75 18		 jne	 SHORT $LN5@inflateMar
  0002f	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00035	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00038	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	03 c1		 add	 eax, ecx

; 1512 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00047	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1512 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN1@inflateMar:

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00058	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1512 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateUndermine@8
; Function compile flags: /Ogtp
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN1@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 13		 je	 SHORT $LN1@inflateUnd

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     state->sane = !subvert;
; 1494 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1495 :     return Z_OK;
; 1496 : #else
; 1497 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1498 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1499 : #endif
; 1500 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN1@inflateUnd:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1499 : #endif
; 1500 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateCopy@8
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_copy$ = -4						; size = 4
_dest$ = 8						; size = 4
_window$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1442 :     struct inflate_state FAR *state;
; 1443 :     struct inflate_state FAR *copy;
; 1444 :     unsigned char FAR *window;
; 1445 :     unsigned wsize;
; 1446 : 
; 1447 :     /* check input */
; 1448 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1449 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	0f 84 36 01 00
	00		 je	 $LN6@inflateCop
  00010	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 2b 01 00
	00		 je	 $LN6@inflateCop
  0001b	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0001e	85 db		 test	 ebx, ebx
  00020	0f 84 20 01 00
	00		 je	 $LN6@inflateCop
  00026	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 15 01 00
	00		 je	 $LN6@inflateCop
  00031	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00035	0f 84 0b 01 00
	00		 je	 $LN6@inflateCop

; 1451 :     state = (struct inflate_state FAR *)source->state;
; 1452 : 
; 1453 :     /* allocate space */
; 1454 :     copy = (struct inflate_state FAR *)
; 1455 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0003b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0003e	57		 push	 edi
  0003f	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00044	6a 01		 push	 1
  00046	51		 push	 ecx
  00047	ff d0		 call	 eax
  00049	8b f8		 mov	 edi, eax
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	89 7d fc	 mov	 DWORD PTR _copy$[ebp], edi

; 1456 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00051	85 ff		 test	 edi, edi
  00053	74 3a		 je	 SHORT $LN11@inflateCop

; 1457 :     window = Z_NULL;
; 1458 :     if (state->window != Z_NULL) {

  00055	83 7b 34 00	 cmp	 DWORD PTR [ebx+52], 0
  00059	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0
  00060	74 3b		 je	 SHORT $LN3@inflateCop

; 1459 :         window = (unsigned char FAR *)
; 1460 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  00062	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00065	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00068	ba 01 00 00 00	 mov	 edx, 1
  0006d	d3 e2		 shl	 edx, cl
  0006f	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00072	6a 01		 push	 1
  00074	52		 push	 edx
  00075	50		 push	 eax
  00076	ff d1		 call	 ecx
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 0c	 mov	 DWORD PTR _window$[ebp], eax

; 1461 :         if (window == Z_NULL) {

  0007e	85 c0		 test	 eax, eax
  00080	75 1b		 jne	 SHORT $LN3@inflateCop

; 1462 :             ZFREE(source, copy);

  00082	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00085	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00088	57		 push	 edi
  00089	52		 push	 edx
  0008a	ff d0		 call	 eax
  0008c	83 c4 08	 add	 esp, 8
$LN11@inflateCop:

; 1463 :             return Z_MEM_ERROR;

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00096	5b		 pop	 ebx

; 1483 : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1464 :         }
; 1465 :     }
; 1466 : 
; 1467 :     /* copy state */
; 1468 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0009d	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
  000a0	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH

; 1469 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000a5	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000aa	f3 a5		 rep movsd
  000ac	8b 75 fc	 mov	 esi, DWORD PTR _copy$[ebp]
  000af	53		 push	 ebx
  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 _memcpy

; 1470 :     if (state->lencode >= state->codes &&
; 1471 :         state->lencode <= state->codes + ENOUGH - 1) {

  000b6	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  000b9	8d 8b 30 05 00
	00		 lea	 ecx, DWORD PTR [ebx+1328]
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	3b c1		 cmp	 eax, ecx
  000c4	72 36		 jb	 SHORT $LN2@inflateCop
  000c6	8d 93 bc 1b 00
	00		 lea	 edx, DWORD PTR [ebx+7100]
  000cc	3b c2		 cmp	 eax, edx
  000ce	77 2c		 ja	 SHORT $LN2@inflateCop

; 1472 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000d0	2b c3		 sub	 eax, ebx
  000d2	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  000d7	c1 f8 02	 sar	 eax, 2
  000da	8d 84 86 30 05
	00 00		 lea	 eax, DWORD PTR [esi+eax*4+1328]
  000e1	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 1473 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e4	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000e7	2b cb		 sub	 ecx, ebx
  000e9	81 e9 30 05 00
	00		 sub	 ecx, 1328		; 00000530H
  000ef	c1 f9 02	 sar	 ecx, 2
  000f2	8d 94 8e 30 05
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1328]
  000f9	89 56 50	 mov	 DWORD PTR [esi+80], edx
$LN2@inflateCop:

; 1474 :     }
; 1475 :     copy->next = copy->codes + (state->next - state->codes);

  000fc	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]

; 1476 :     if (window != Z_NULL) {

  000ff	8b 7d 0c	 mov	 edi, DWORD PTR _window$[ebp]
  00102	2b c3		 sub	 eax, ebx
  00104	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00109	c1 f8 02	 sar	 eax, 2
  0010c	8d 8c 86 30 05
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+1328]
  00113	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  00116	85 ff		 test	 edi, edi
  00118	74 18		 je	 SHORT $LN1@inflateCop

; 1477 :         wsize = 1U << state->wbits;

  0011a	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]

; 1478 :         zmemcpy(window, state->window, wsize);

  0011d	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00120	ba 01 00 00 00	 mov	 edx, 1
  00125	d3 e2		 shl	 edx, cl
  00127	52		 push	 edx
  00128	50		 push	 eax
  00129	57		 push	 edi
  0012a	e8 00 00 00 00	 call	 _memcpy
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1479 :     }
; 1480 :     copy->window = window;
; 1481 :     dest->state = (struct internal_state FAR *)copy;

  00132	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00135	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  00138	5f		 pop	 edi
  00139	89 71 1c	 mov	 DWORD PTR [ecx+28], esi
  0013c	5e		 pop	 esi

; 1482 :     return Z_OK;

  0013d	33 c0		 xor	 eax, eax
  0013f	5b		 pop	 ebx

; 1483 : }

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 08 00	 ret	 8
$LN6@inflateCop:
  00146	5e		 pop	 esi

; 1450 :         return Z_STREAM_ERROR;

  00147	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0014c	5b		 pop	 ebx

; 1483 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint@4
; Function compile flags: /Ogtp
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN1@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 1a		 je	 SHORT $LN1@inflateSyn

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0f		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 09		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1436 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00025	33 c0		 xor	 eax, eax

; 1436 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN1@inflateSyn:

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1436 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _syncsearch
_TEXT	SEGMENT
_have$ = 8						; size = 4
_len$ = 12						; size = 4
_syncsearch PROC					; COMDAT
; _buf$ = esi

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]

; 1359 :     unsigned got;
; 1360 :     unsigned next;
; 1361 : 
; 1362 :     got = *have;

  00006	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 1363 :     next = 0;

  00008	33 c0		 xor	 eax, eax

; 1364 :     while (next < len && got < 4) {

  0000a	39 45 0c	 cmp	 DWORD PTR _len$[ebp], eax
  0000d	76 41		 jbe	 SHORT $LN11@syncsearch
  0000f	53		 push	 ebx
  00010	57		 push	 edi
$LL6@syncsearch:
  00011	83 f9 04	 cmp	 ecx, 4
  00014	73 35		 jae	 SHORT $LN12@syncsearch

; 1365 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00016	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  00019	83 f9 02	 cmp	 ecx, 2
  0001c	1b ff		 sbb	 edi, edi
  0001e	81 e7 01 ff ff
	ff		 and	 edi, -255		; ffffff01H
  00024	0f b6 da	 movzx	 ebx, dl
  00027	81 c7 ff 00 00
	00		 add	 edi, 255		; 000000ffH
  0002d	3b df		 cmp	 ebx, edi
  0002f	75 03		 jne	 SHORT $LN4@syncsearch

; 1366 :             got++;

  00031	41		 inc	 ecx
  00032	eb 11		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1367 :         else if (buf[next])

  00034	84 d2		 test	 dl, dl
  00036	74 04		 je	 SHORT $LN2@syncsearch

; 1368 :             got = 0;

  00038	33 c9		 xor	 ecx, ecx

; 1369 :         else

  0003a	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1370 :             got = 4 - got;

  0003c	ba 04 00 00 00	 mov	 edx, 4
  00041	2b d1		 sub	 edx, ecx
  00043	8b ca		 mov	 ecx, edx
$LN1@syncsearch:

; 1371 :         next++;

  00045	40		 inc	 eax
  00046	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00049	72 c6		 jb	 SHORT $LL6@syncsearch
$LN12@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  0004b	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0004e	5f		 pop	 edi
  0004f	5b		 pop	 ebx
$LN11@syncsearch:
  00050	89 0a		 mov	 DWORD PTR [edx], ecx

; 1374 :     return next;
; 1375 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
PUBLIC	_inflateGetHeader@8
; Function compile flags: /Ogtp
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 20		 je	 SHORT $LN2@inflateGet
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 19		 je	 SHORT $LN2@inflateGet

; 1334 :     state = (struct inflate_state FAR *)strm->state;
; 1335 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 08 02	 test	 BYTE PTR [eax+8], 2
  00015	74 13		 je	 SHORT $LN2@inflateGet

; 1336 : 
; 1337 :     /* save header structure */
; 1338 :     state->head = head;

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  0001a	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1339 :     head->done = 0;

  0001d	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1340 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1341 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN2@inflateGet:

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1341 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateGetDictionary@12
; Function compile flags: /Ogtp
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1272 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	85 c0		 test	 eax, eax
  00009	74 54		 je	 SHORT $LN3@inflateGet@2
  0000b	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  0000e	85 f6		 test	 esi, esi
  00010	74 4d		 je	 SHORT $LN3@inflateGet@2

; 1277 :     state = (struct inflate_state FAR *)strm->state;
; 1278 : 
; 1279 :     /* copy dictionary */
; 1280 :     if (state->whave && dictionary != Z_NULL) {

  00012	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN2@inflateGet@2
  00019	57		 push	 edi
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  0001d	85 ff		 test	 edi, edi
  0001f	74 2a		 je	 SHORT $LN7@inflateGet@2

; 1281 :         zmemcpy(dictionary, state->window + state->wnext,
; 1282 :                 state->whave - state->wnext);

  00021	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00024	2b c1		 sub	 eax, ecx
  00026	50		 push	 eax
  00027	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0002a	03 c1		 add	 eax, ecx
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 _memcpy

; 1283 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1284 :                 state->window, state->wnext);

  00033	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00036	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00039	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0003c	50		 push	 eax
  0003d	2b d0		 sub	 edx, eax
  0003f	51		 push	 ecx
  00040	03 d7		 add	 edx, edi
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 _memcpy
  00048	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@inflateGet@2:
  0004b	5f		 pop	 edi
$LN2@inflateGet@2:

; 1285 :     }
; 1286 :     if (dictLength != Z_NULL)

  0004c	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	74 05		 je	 SHORT $LN1@inflateGet@2

; 1287 :         *dictLength = state->whave;

  00053	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00056	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@inflateGet@2:

; 1288 :     return Z_OK;

  00058	33 c0		 xor	 eax, eax
  0005a	5e		 pop	 esi

; 1289 : }

  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateGet@2:

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0005f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00064	5e		 pop	 esi

; 1289 : }

  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd@4
; Function compile flags: /Ogtp
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 3d		 je	 SHORT $LN2@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 36		 je	 SHORT $LN2@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2f		 je	 SHORT $LN2@inflateEnd

; 1260 :     state = (struct inflate_state FAR *)strm->state;
; 1261 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN1@inflateEnd
  00020	50		 push	 eax
  00021	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00024	50		 push	 eax
  00025	ff d1		 call	 ecx
  00027	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1262 :     ZFREE(strm, strm->state);

  0002a	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0002d	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00030	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	ff d0		 call	 eax
  00037	83 c4 08	 add	 esp, 8

; 1263 :     strm->state = Z_NULL;

  0003a	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1264 :     Tracev((stderr, "inflate: end\n"));
; 1265 :     return Z_OK;

  00041	33 c0		 xor	 eax, eax
  00043	5e		 pop	 esi

; 1266 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1259 :         return Z_STREAM_ERROR;

  00048	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004d	5e		 pop	 esi

; 1266 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = eax
; _copy$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 384  :     struct inflate_state FAR *state;
; 385  :     unsigned dist;
; 386  : 
; 387  :     state = (struct inflate_state FAR *)strm->state;

  00005	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00008	57		 push	 edi

; 388  : 
; 389  :     /* if it hasn't been done already, allocate space for the window */
; 390  :     if (state->window == Z_NULL) {

  00009	33 ff		 xor	 edi, edi
  0000b	8b d9		 mov	 ebx, ecx
  0000d	39 7e 34	 cmp	 DWORD PTR [esi+52], edi
  00010	75 28		 jne	 SHORT $LN9@updatewind

; 391  :         state->window = (unsigned char FAR *)
; 392  :                         ZALLOC(strm, 1U << state->wbits,
; 393  :                                sizeof(unsigned char));

  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	d3 e2		 shl	 edx, cl
  0001c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001f	6a 01		 push	 1
  00021	52		 push	 edx
  00022	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00025	51		 push	 ecx
  00026	ff d2		 call	 edx
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 394  :         if (state->window == Z_NULL) return 1;

  0002e	3b c7		 cmp	 eax, edi
  00030	75 08		 jne	 SHORT $LN9@updatewind
  00032	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 427  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN9@updatewind:

; 395  :     }
; 396  : 
; 397  :     /* if window not in use yet, initialize */
; 398  :     if (state->wsize == 0) {

  0003a	39 7e 28	 cmp	 DWORD PTR [esi+40], edi
  0003d	75 13		 jne	 SHORT $LN8@updatewind

; 399  :         state->wsize = 1U << state->wbits;

  0003f	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	d3 e0		 shl	 eax, cl

; 400  :         state->wnext = 0;

  00049	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 401  :         state->whave = 0;

  0004c	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  0004f	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN8@updatewind:

; 402  :     }
; 403  : 
; 404  :     /* copy state->wsize or less output bytes into the circular window */
; 405  :     if (copy >= state->wsize) {

  00052	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00055	3b d8		 cmp	 ebx, eax
  00057	72 23		 jb	 SHORT $LN7@updatewind

; 406  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _end$[ebp]
  0005c	50		 push	 eax
  0005d	2b c8		 sub	 ecx, eax
  0005f	51		 push	 ecx
  00060	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _memcpy

; 407  :         state->wnext = 0;
; 408  :         state->whave = state->wsize;

  00069	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00072	5f		 pop	 edi
  00073	89 56 2c	 mov	 DWORD PTR [esi+44], edx
  00076	5e		 pop	 esi

; 424  :         }
; 425  :     }
; 426  :     return 0;

  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 427  : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN7@updatewind:

; 409  :     }
; 410  :     else {
; 411  :         dist = state->wsize - state->wnext;

  0007c	2b 46 30	 sub	 eax, DWORD PTR [esi+48]
  0007f	8b f8		 mov	 edi, eax

; 412  :         if (dist > copy) dist = copy;

  00081	3b fb		 cmp	 edi, ebx
  00083	76 02		 jbe	 SHORT $LN5@updatewind
  00085	8b fb		 mov	 edi, ebx
$LN5@updatewind:

; 413  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00087	8b 45 08	 mov	 eax, DWORD PTR _end$[ebp]
  0008a	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0008d	03 4e 30	 add	 ecx, DWORD PTR [esi+48]
  00090	57		 push	 edi
  00091	2b c3		 sub	 eax, ebx
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _memcpy
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  :         copy -= dist;

  0009d	2b df		 sub	 ebx, edi

; 415  :         if (copy) {

  0009f	74 23		 je	 SHORT $LN4@updatewind

; 416  :             zmemcpy(state->window, end - copy, copy);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _end$[ebp]
  000a4	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000a7	53		 push	 ebx
  000a8	2b c3		 sub	 eax, ebx
  000aa	50		 push	 eax
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _memcpy

; 417  :             state->wnext = copy;
; 418  :             state->whave = state->wsize;

  000b1	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	5f		 pop	 edi
  000b8	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  000bb	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000be	5e		 pop	 esi

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000bf	33 c0		 xor	 eax, eax
  000c1	5b		 pop	 ebx

; 427  : }

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN4@updatewind:

; 419  :         }
; 420  :         else {
; 421  :             state->wnext += dist;
; 422  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c4	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000c7	01 7e 30	 add	 DWORD PTR [esi+48], edi
  000ca	39 46 30	 cmp	 DWORD PTR [esi+48], eax
  000cd	75 07		 jne	 SHORT $LN2@updatewind
  000cf	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN2@updatewind:

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000d6	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000d9	3b c8		 cmp	 ecx, eax
  000db	73 05		 jae	 SHORT $LN1@updatewind
  000dd	03 cf		 add	 ecx, edi
  000df	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
$LN1@updatewind:

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	33 c0		 xor	 eax, eax
  000e6	5b		 pop	 ebx

; 427  : }

  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = eax

; 264  : #ifdef BUILDFIXED
; 265  :     static int virgin = 1;
; 266  :     static code *lenfix, *distfix;
; 267  :     static code fixed[544];
; 268  : 
; 269  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 270  :     if (virgin) {
; 271  :         unsigned sym, bits;
; 272  :         static code *next;
; 273  : 
; 274  :         /* literal/length table */
; 275  :         sym = 0;
; 276  :         while (sym < 144) state->lens[sym++] = 8;
; 277  :         while (sym < 256) state->lens[sym++] = 9;
; 278  :         while (sym < 280) state->lens[sym++] = 7;
; 279  :         while (sym < 288) state->lens[sym++] = 8;
; 280  :         next = fixed;
; 281  :         lenfix = next;
; 282  :         bits = 9;
; 283  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 284  : 
; 285  :         /* distance table */
; 286  :         sym = 0;
; 287  :         while (sym < 32) state->lens[sym++] = 5;
; 288  :         distfix = next;
; 289  :         bits = 5;
; 290  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 291  : 
; 292  :         /* do this just once */
; 293  :         virgin = 0;
; 294  :     }
; 295  : #else /* !BUILDFIXED */
; 296  : #   include "inffixed.h"
; 297  : #endif /* BUILDFIXED */
; 298  :     state->lencode = lenfix;

  00000	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 299  :     state->lenbits = 9;

  00007	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 300  :     state->distcode = distfix;

  0000e	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 301  :     state->distbits = 5;

  00015	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 302  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflatePrime@12
; Function compile flags: /Ogtp
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	3b c2		 cmp	 eax, edx
  0000a	74 53		 je	 SHORT $LN4@inflatePri
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	3b c2		 cmp	 eax, edx
  00011	74 4c		 je	 SHORT $LN4@inflatePri

; 238  :     state = (struct inflate_state FAR *)strm->state;
; 239  :     if (bits < 0) {

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00016	3b ca		 cmp	 ecx, edx
  00018	7d 0c		 jge	 SHORT $LN3@inflatePri

; 240  :         state->hold = 0;

  0001a	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 241  :         state->bits = 0;

  0001d	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 242  :         return Z_OK;

  00020	33 c0		 xor	 eax, eax

; 249  : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  00026	56		 push	 esi

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00027	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002a	7f 29		 jg	 SHORT $LN1@inflatePri
  0002c	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  0002f	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  00032	83 fe 20	 cmp	 esi, 32			; 00000020H
  00035	77 1e		 ja	 SHORT $LN1@inflatePri

; 245  :     value &= (1L << bits) - 1;

  00037	57		 push	 edi
  00038	bf 01 00 00 00	 mov	 edi, 1
  0003d	d3 e7		 shl	 edi, cl

; 246  :     state->hold += value << state->bits;

  0003f	8b ca		 mov	 ecx, edx

; 247  :     state->bits += bits;

  00041	89 70 3c	 mov	 DWORD PTR [eax+60], esi
  00044	4f		 dec	 edi
  00045	23 7d 10	 and	 edi, DWORD PTR _value$[ebp]
  00048	d3 e7		 shl	 edi, cl
  0004a	01 78 38	 add	 DWORD PTR [eax+56], edi
  0004d	5f		 pop	 edi

; 248  :     return Z_OK;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 249  : }

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflatePri:

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	5e		 pop	 esi

; 249  : }

  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0005f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 249  : }

  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateResetKeep@4
; Function compile flags: /Ogtp
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	3b ce		 cmp	 ecx, esi
  0000b	74 62		 je	 SHORT $LN2@inflateRes
  0000d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00010	3b c6		 cmp	 eax, esi
  00012	74 5b		 je	 SHORT $LN2@inflateRes

; 110  :     state = (struct inflate_state FAR *)strm->state;
; 111  :     strm->total_in = strm->total_out = state->total = 0;

  00014	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  00017	89 71 14	 mov	 DWORD PTR [ecx+20], esi
  0001a	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 112  :     strm->msg = Z_NULL;

  0001d	89 71 18	 mov	 DWORD PTR [ecx+24], esi

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00020	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00023	3b d6		 cmp	 edx, esi
  00025	74 06		 je	 SHORT $LN1@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00027	83 e2 01	 and	 edx, 1
  0002a	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN1@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->dmax = 32768U;
; 119  :     state->head = Z_NULL;
; 120  :     state->hold = 0;
; 121  :     state->bits = 0;
; 122  :     state->lencode = state->distcode = state->next = state->codes;

  0002d	8d 88 30 05 00
	00		 lea	 ecx, DWORD PTR [eax+1328]
  00033	89 30		 mov	 DWORD PTR [eax], esi
  00035	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00038	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  0003b	89 70 20	 mov	 DWORD PTR [eax+32], esi
  0003e	89 70 38	 mov	 DWORD PTR [eax+56], esi
  00041	89 70 3c	 mov	 DWORD PTR [eax+60], esi
  00044	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [eax+20], 32768 ; 00008000H
  0004b	89 48 6c	 mov	 DWORD PTR [eax+108], ecx
  0004e	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00051	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 123  :     state->sane = 1;

  00054	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 124  :     state->back = -1;

  0005e	c7 80 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7108], -1

; 125  :     Tracev((stderr, "inflate: reset\n"));
; 126  :     return Z_OK;

  00068	33 c0		 xor	 eax, eax
  0006a	5e		 pop	 esi

; 127  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN2@inflateRes:

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0006f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00074	5e		 pop	 esi

; 127  : }

  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
PUBLIC	_inflateSetDictionary@12
; Function compile flags: /Ogtp
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	85 c0		 test	 eax, eax
  00009	0f 84 85 00 00
	00		 je	 $LN5@inflateSet
  0000f	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00012	85 f6		 test	 esi, esi
  00014	74 7e		 je	 SHORT $LN5@inflateSet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if (state->wrap != 0 && state->mode != DICT)

  00016	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001a	53		 push	 ebx
  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _dictionary$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 10	 mov	 edi, DWORD PTR _dictLength$[ebp]
  00022	74 11		 je	 SHORT $LN4@inflateSet
  00024	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00027	74 11		 je	 SHORT $LN9@inflateSet

; 1304 :         return Z_STREAM_ERROR;

  00029	5f		 pop	 edi
  0002a	5b		 pop	 ebx
  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00030	5e		 pop	 esi

; 1324 : }

  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflateSet:

; 1305 : 
; 1306 :     /* check for correct dictionary identifier */
; 1307 :     if (state->mode == DICT) {

  00035	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00038	75 27		 jne	 SHORT $LN2@inflateSet
$LN9@inflateSet:

; 1308 :         dictid = adler32(0L, Z_NULL, 0);
; 1309 :         dictid = adler32(dictid, dictionary, dictLength);

  0003a	57		 push	 edi
  0003b	53		 push	 ebx
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	e8 00 00 00 00	 call	 _adler32@12
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _adler32@12

; 1310 :         if (dictid != state->check)

  0004d	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  00050	74 0c		 je	 SHORT $LN10@inflateSet

; 1311 :             return Z_DATA_ERROR;

  00052	5f		 pop	 edi
  00053	5b		 pop	 ebx
  00054	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00059	5e		 pop	 esi

; 1324 : }

  0005a	5d		 pop	 ebp
  0005b	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:

; 1310 :         if (dictid != state->check)

  0005e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
$LN2@inflateSet:

; 1312 :     }
; 1313 : 
; 1314 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1315 :        existing dictionary if appropriate */
; 1316 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00061	03 df		 add	 ebx, edi
  00063	53		 push	 ebx
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 _updatewindow
  0006b	83 c4 04	 add	 esp, 4

; 1317 :     if (ret) {

  0006e	85 c0		 test	 eax, eax
  00070	74 12		 je	 SHORT $LN1@inflateSet

; 1318 :         state->mode = MEM;

  00072	5f		 pop	 edi
  00073	5b		 pop	 ebx
  00074	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH

; 1319 :         return Z_MEM_ERROR;

  0007a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007f	5e		 pop	 esi

; 1324 : }

  00080	5d		 pop	 ebp
  00081	c2 0c 00	 ret	 12			; 0000000cH
$LN1@inflateSet:
  00084	5f		 pop	 edi
  00085	5b		 pop	 ebx

; 1320 :     }
; 1321 :     state->havedict = 1;

  00086	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1322 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1323 :     return Z_OK;

  0008d	33 c0		 xor	 eax, eax
  0008f	5e		 pop	 esi

; 1324 : }

  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00094	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00099	5e		 pop	 esi

; 1324 : }

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflate@8
; Function compile flags: /Ogtp
;	COMDAT _inflate@8
_TEXT	SEGMENT
_in$ = -48						; size = 4
tv3076 = -44						; size = 4
tv2364 = -44						; size = 4
tv2360 = -44						; size = 4
tv2303 = -44						; size = 4
tv2288 = -44						; size = 4
tv2173 = -44						; size = 4
tv2157 = -44						; size = 4
tv2134 = -44						; size = 4
_from$ = -44						; size = 4
_ret$ = -40						; size = 4
tv2314 = -36						; size = 4
tv2131 = -36						; size = 4
_last$ = -36						; size = 4
_out$ = -32						; size = 4
tv2387 = -28						; size = 4
tv2362 = -28						; size = 4
tv2357 = -28						; size = 4
tv2289 = -28						; size = 4
_len$ = -28						; size = 4
_put$ = -24						; size = 4
_hbuf$ = -20						; size = 4
_left$ = -16						; size = 4
_here$ = -12						; size = 4
_copy$ = -12						; size = 4
_next$ = -8						; size = 4
_have$ = -4						; size = 4
tv1325 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 609  :     struct inflate_state FAR *state;
; 610  :     z_const unsigned char FAR *next;    /* next input */
; 611  :     unsigned char FAR *put;     /* next output */
; 612  :     unsigned have, left;        /* available input and output */
; 613  :     unsigned long hold;         /* bit buffer */
; 614  :     unsigned bits;              /* bits in bit buffer */
; 615  :     unsigned in, out;           /* save starting available input and output */
; 616  :     unsigned copy;              /* number of stored or match bytes to copy */
; 617  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 618  :     code here;                  /* current decoding table entry */
; 619  :     code last;                  /* parent table entry */
; 620  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 621  :     int ret;                    /* return code */
; 622  : #ifdef GUNZIP
; 623  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 624  : #endif
; 625  :     static const unsigned short order[19] = /* permutation of code lengths */
; 626  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 627  : 
; 628  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 629  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 30	 sub	 esp, 48			; 00000030H
  00009	57		 push	 edi
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 52 14 00
	00		 je	 $LN498@inflate
  00012	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  00015	85 ff		 test	 edi, edi
  00017	0f 84 47 14 00
	00		 je	 $LN498@inflate
  0001d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00021	0f 84 3d 14 00
	00		 je	 $LN498@inflate
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 0a		 jne	 SHORT $LN499@inflate
  0002c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00030	0f 85 2e 14 00
	00		 jne	 $LN498@inflate
$LN499@inflate:

; 631  : 
; 632  :     state = (struct inflate_state FAR *)strm->state;
; 633  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00036	83 3f 0b	 cmp	 DWORD PTR [edi], 11	; 0000000bH
  00039	75 06		 jne	 SHORT $LN496@inflate
  0003b	c7 07 0c 00 00
	00		 mov	 DWORD PTR [edi], 12	; 0000000cH
$LN496@inflate:

; 634  :     LOAD();

  00041	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00044	8b 10		 mov	 edx, DWORD PTR [eax]
  00046	89 4d e8	 mov	 DWORD PTR _put$[ebp], ecx
  00049	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	53		 push	 ebx
  00050	8b 5f 38	 mov	 ebx, DWORD PTR [edi+56]
  00053	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 635  :     in = have;

  00056	89 45 d0	 mov	 DWORD PTR _in$[ebp], eax

; 636  :     out = left;
; 637  :     ret = Z_OK;
; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00059	8b 07		 mov	 eax, DWORD PTR [edi]
  0005b	56		 push	 esi
  0005c	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  0005f	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  00062	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00065	89 4d e0	 mov	 DWORD PTR _out$[ebp], ecx
  00068	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0006f	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00072	0f 87 6a 12 00
	00		 ja	 $LN12@inflate
$LL493@inflate:
  00078	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN783@inflate[eax*4]
$LN489@inflate:

; 640  :         case HEAD:
; 641  :             if (state->wrap == 0) {

  0007f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00082	85 c0		 test	 eax, eax
  00084	75 0b		 jne	 SHORT $LN487@inflate

; 642  :                 state->mode = TYPEDO;

  00086	c7 07 0c 00 00
	00		 mov	 DWORD PTR [edi], 12	; 0000000cH

; 643  :                 break;

  0008c	e9 46 12 00 00	 jmp	 $LN490@inflate
$LN487@inflate:

; 644  :             }
; 645  :             NEEDBITS(16);

  00091	83 fe 10	 cmp	 esi, 16			; 00000010H
  00094	73 22		 jae	 SHORT $LN486@inflate
$LL484@inflate:
  00096	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  0009a	0f 84 95 12 00
	00		 je	 $inf_leave$80535
  000a0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000a3	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  000a6	8b ce		 mov	 ecx, esi
  000a8	d3 e0		 shl	 eax, cl
  000aa	42		 inc	 edx
  000ab	83 c6 08	 add	 esi, 8
  000ae	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  000b1	03 d8		 add	 ebx, eax
  000b3	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b6	72 de		 jb	 SHORT $LL484@inflate
$LN486@inflate:

; 646  : #ifdef GUNZIP
; 647  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000b8	f6 47 08 02	 test	 BYTE PTR [edi+8], 2
  000bc	74 3b		 je	 SHORT $LN478@inflate
  000be	81 fb 1f 8b 00
	00		 cmp	 ebx, 35615		; 00008b1fH
  000c4	75 33		 jne	 SHORT $LN478@inflate

; 648  :                 state->check = crc32(0L, Z_NULL, 0);

  000c6	6a 00		 push	 0
  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 _crc32@12

; 649  :                 CRC2(state->check, hold);

  000d1	6a 02		 push	 2
  000d3	8d 4d ec	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  000d6	51		 push	 ecx
  000d7	50		 push	 eax
  000d8	89 47 18	 mov	 DWORD PTR [edi+24], eax
  000db	66 89 5d ec	 mov	 WORD PTR _hbuf$[ebp], bx
  000df	e8 00 00 00 00	 call	 _crc32@12

; 650  :                 INITBITS();
; 651  :                 state->mode = FLAGS;
; 652  :                 break;

  000e4	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  000e7	33 db		 xor	 ebx, ebx
  000e9	89 47 18	 mov	 DWORD PTR [edi+24], eax
  000ec	33 f6		 xor	 esi, esi
  000ee	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  000f4	e9 de 11 00 00	 jmp	 $LN490@inflate
$LN478@inflate:

; 653  :             }
; 654  :             state->flags = 0;           /* expect zlib header */
; 655  :             if (state->head != Z_NULL)

  000f9	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000fc	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00103	85 c0		 test	 eax, eax
  00105	74 07		 je	 SHORT $LN471@inflate

; 656  :                 state->head->done = -1;

  00107	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN471@inflate:

; 657  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 658  : #else
; 659  :             if (
; 660  : #endif
; 661  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  0010e	f6 47 08 01	 test	 BYTE PTR [edi+8], 1
  00112	0f 84 9f 00 00
	00		 je	 $LN469@inflate
  00118	0f b6 c3	 movzx	 eax, bl
  0011b	c1 e0 08	 shl	 eax, 8
  0011e	8b d3		 mov	 edx, ebx
  00120	c1 ea 08	 shr	 edx, 8
  00123	03 c2		 add	 eax, edx
  00125	33 d2		 xor	 edx, edx
  00127	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0012c	f7 f1		 div	 ecx
  0012e	85 d2		 test	 edx, edx
  00130	0f 85 81 00 00
	00		 jne	 $LN469@inflate

; 665  :             }
; 666  :             if (BITS(4) != Z_DEFLATED) {

  00136	8b d3		 mov	 edx, ebx
  00138	80 e2 0f	 and	 dl, 15			; 0000000fH
  0013b	80 fa 08	 cmp	 dl, 8
  0013e	74 12		 je	 SHORT $LN467@inflate

; 667  :                 strm->msg = (char *)"unknown compression method";

  00140	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 668  :                 state->mode = BAD;
; 669  :                 break;

  00143	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00146	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0014d	e9 7f 11 00 00	 jmp	 $LN782@inflate
$LN467@inflate:

; 670  :             }
; 671  :             DROPBITS(4);
; 672  :             len = BITS(4) + 8;
; 673  :             if (state->wbits == 0)

  00152	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00155	c1 eb 04	 shr	 ebx, 4
  00158	8b cb		 mov	 ecx, ebx
  0015a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0015d	83 ee 04	 sub	 esi, 4
  00160	83 c1 08	 add	 ecx, 8
  00163	85 c0		 test	 eax, eax
  00165	75 3a		 jne	 SHORT $LN464@inflate

; 674  :                 state->wbits = len;

  00167	89 4f 24	 mov	 DWORD PTR [edi+36], ecx
$LN462@inflate:

; 679  :             }
; 680  :             state->dmax = 1U << len;

  0016a	ba 01 00 00 00	 mov	 edx, 1

; 681  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 682  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0016f	6a 00		 push	 0
  00171	d3 e2		 shl	 edx, cl
  00173	6a 00		 push	 0
  00175	6a 00		 push	 0
  00177	89 57 14	 mov	 DWORD PTR [edi+20], edx
  0017a	e8 00 00 00 00	 call	 _adler32@12
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 683  :             state->mode = hold & 0x200 ? DICTID : TYPE;
; 684  :             INITBITS();
; 685  :             break;

  00182	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00185	c1 eb 08	 shr	 ebx, 8
  00188	f7 d3		 not	 ebx
  0018a	83 e3 02	 and	 ebx, 2
  0018d	83 cb 09	 or	 ebx, 9
  00190	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00193	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00196	89 1f		 mov	 DWORD PTR [edi], ebx
  00198	33 db		 xor	 ebx, ebx
  0019a	33 f6		 xor	 esi, esi
  0019c	e9 36 11 00 00	 jmp	 $LN490@inflate
$LN464@inflate:

; 675  :             else if (len > state->wbits) {

  001a1	3b c8		 cmp	 ecx, eax
  001a3	76 c5		 jbe	 SHORT $LN462@inflate

; 676  :                 strm->msg = (char *)"invalid window size";

  001a5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 677  :                 state->mode = BAD;
; 678  :                 break;

  001a8	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  001ab	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  001b2	e9 1a 11 00 00	 jmp	 $LN782@inflate
$LN469@inflate:

; 662  :                 strm->msg = (char *)"incorrect header check";

  001b7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001ba	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 663  :                 state->mode = BAD;
; 664  :                 break;

  001c1	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  001c4	e9 08 11 00 00	 jmp	 $LN782@inflate
$LN457@inflate:

; 686  : #ifdef GUNZIP
; 687  :         case FLAGS:
; 688  :             NEEDBITS(16);

  001c9	83 fe 10	 cmp	 esi, 16			; 00000010H
  001cc	73 24		 jae	 SHORT $LN456@inflate
  001ce	8b ff		 npad	 2
$LL454@inflate:
  001d0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  001d4	0f 84 5b 11 00
	00		 je	 $inf_leave$80535
  001da	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001dd	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  001e0	8b ce		 mov	 ecx, esi
  001e2	d3 e0		 shl	 eax, cl
  001e4	42		 inc	 edx
  001e5	83 c6 08	 add	 esi, 8
  001e8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  001eb	03 d8		 add	 ebx, eax
  001ed	83 fe 10	 cmp	 esi, 16			; 00000010H
  001f0	72 de		 jb	 SHORT $LL454@inflate
$LN456@inflate:

; 689  :             state->flags = (int)(hold);

  001f2	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 690  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  001f5	80 fb 08	 cmp	 bl, 8
  001f8	74 0f		 je	 SHORT $LN448@inflate

; 691  :                 strm->msg = (char *)"unknown compression method";

  001fa	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001fd	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 692  :                 state->mode = BAD;
; 693  :                 break;

  00204	e9 c8 10 00 00	 jmp	 $LN782@inflate
$LN448@inflate:

; 694  :             }
; 695  :             if (state->flags & 0xe000) {

  00209	f7 c3 00 e0 00
	00		 test	 ebx, 57344		; 0000e000H
  0020f	74 0f		 je	 SHORT $LN447@inflate

; 696  :                 strm->msg = (char *)"unknown header flags set";

  00211	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00214	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 697  :                 state->mode = BAD;
; 698  :                 break;

  0021b	e9 b1 10 00 00	 jmp	 $LN782@inflate
$LN447@inflate:

; 699  :             }
; 700  :             if (state->head != Z_NULL)

  00220	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00223	85 c0		 test	 eax, eax
  00225	74 0a		 je	 SHORT $LN446@inflate

; 701  :                 state->head->text = (int)((hold >> 8) & 1);

  00227	8b cb		 mov	 ecx, ebx
  00229	c1 e9 08	 shr	 ecx, 8
  0022c	83 e1 01	 and	 ecx, 1
  0022f	89 08		 mov	 DWORD PTR [eax], ecx
$LN446@inflate:

; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00231	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  00238	74 1e		 je	 SHORT $LN442@inflate
  0023a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0023d	6a 02		 push	 2
  0023f	8d 55 ec	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00242	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  00245	52		 push	 edx
  00246	c1 eb 08	 shr	 ebx, 8
  00249	50		 push	 eax
  0024a	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  0024d	e8 00 00 00 00	 call	 _crc32@12
  00252	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00255	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN442@inflate:

; 703  :             INITBITS();

  00258	33 db		 xor	 ebx, ebx
  0025a	33 f6		 xor	 esi, esi

; 704  :             state->mode = TIME;

  0025c	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2

; 705  :         case TIME:
; 706  :             NEEDBITS(32);

  00262	eb 0c		 jmp	 SHORT $LL434@inflate
$LN437@inflate:
  00264	83 fe 20	 cmp	 esi, 32			; 00000020H
  00267	73 29		 jae	 SHORT $LN436@inflate
  00269	8d a4 24 00 00
	00 00		 npad	 7
$LL434@inflate:
  00270	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00274	0f 84 bb 10 00
	00		 je	 $inf_leave$80535
  0027a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0027d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00280	8b ce		 mov	 ecx, esi
  00282	d3 e0		 shl	 eax, cl
  00284	42		 inc	 edx
  00285	83 c6 08	 add	 esi, 8
  00288	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0028b	03 d8		 add	 ebx, eax
  0028d	83 fe 20	 cmp	 esi, 32			; 00000020H
  00290	72 de		 jb	 SHORT $LL434@inflate
$LN436@inflate:

; 707  :             if (state->head != Z_NULL)

  00292	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00295	85 c0		 test	 eax, eax
  00297	74 03		 je	 SHORT $LN428@inflate

; 708  :                 state->head->time = hold;

  00299	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN428@inflate:

; 709  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0029c	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  002a3	74 2e		 je	 SHORT $LN424@inflate
  002a5	8b cb		 mov	 ecx, ebx
  002a7	c1 e9 08	 shr	 ecx, 8
  002aa	6a 04		 push	 4
  002ac	8d 45 ec	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002af	88 4d ed	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  002b2	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  002b5	8b d3		 mov	 edx, ebx
  002b7	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  002ba	50		 push	 eax
  002bb	c1 ea 10	 shr	 edx, 16			; 00000010H
  002be	c1 eb 18	 shr	 ebx, 24			; 00000018H
  002c1	51		 push	 ecx
  002c2	88 55 ee	 mov	 BYTE PTR _hbuf$[ebp+2], dl
  002c5	88 5d ef	 mov	 BYTE PTR _hbuf$[ebp+3], bl
  002c8	e8 00 00 00 00	 call	 _crc32@12
  002cd	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  002d0	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN424@inflate:

; 710  :             INITBITS();

  002d3	33 db		 xor	 ebx, ebx
  002d5	33 f6		 xor	 esi, esi

; 711  :             state->mode = OS;

  002d7	c7 07 03 00 00
	00		 mov	 DWORD PTR [edi], 3

; 712  :         case OS:
; 713  :             NEEDBITS(16);

  002dd	eb 05		 jmp	 SHORT $LL416@inflate
$LN419@inflate:
  002df	83 fe 10	 cmp	 esi, 16			; 00000010H
  002e2	73 22		 jae	 SHORT $LN418@inflate
$LL416@inflate:
  002e4	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  002e8	0f 84 47 10 00
	00		 je	 $inf_leave$80535
  002ee	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002f1	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  002f4	8b ce		 mov	 ecx, esi
  002f6	d3 e0		 shl	 eax, cl
  002f8	42		 inc	 edx
  002f9	83 c6 08	 add	 esi, 8
  002fc	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  002ff	03 d8		 add	 ebx, eax
  00301	83 fe 10	 cmp	 esi, 16			; 00000010H
  00304	72 de		 jb	 SHORT $LL416@inflate
$LN418@inflate:

; 714  :             if (state->head != Z_NULL) {

  00306	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00309	85 c0		 test	 eax, eax
  0030b	74 16		 je	 SHORT $LN410@inflate

; 715  :                 state->head->xflags = (int)(hold & 0xff);

  0030d	8b cb		 mov	 ecx, ebx
  0030f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00315	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 716  :                 state->head->os = (int)(hold >> 8);

  00318	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  0031b	8b c3		 mov	 eax, ebx
  0031d	c1 e8 08	 shr	 eax, 8
  00320	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN410@inflate:

; 717  :             }
; 718  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00323	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  0032a	74 1e		 je	 SHORT $LN406@inflate
  0032c	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0032f	6a 02		 push	 2
  00331	8d 55 ec	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00334	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  00337	52		 push	 edx
  00338	c1 eb 08	 shr	 ebx, 8
  0033b	50		 push	 eax
  0033c	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  0033f	e8 00 00 00 00	 call	 _crc32@12
  00344	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00347	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN406@inflate:

; 719  :             INITBITS();

  0034a	33 db		 xor	 ebx, ebx
  0034c	33 f6		 xor	 esi, esi

; 720  :             state->mode = EXLEN;

  0034e	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], 4
$LN707@inflate:

; 721  :         case EXLEN:
; 722  :             if (state->flags & 0x0400) {

  00354	f7 47 10 00 04
	00 00		 test	 DWORD PTR [edi+16], 1024 ; 00000400H
  0035b	74 61		 je	 SHORT $LN401@inflate

; 723  :                 NEEDBITS(16);

  0035d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00360	73 22		 jae	 SHORT $LN399@inflate
$LL397@inflate:
  00362	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00366	0f 84 c9 0f 00
	00		 je	 $inf_leave$80535
  0036c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0036f	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00372	8b ce		 mov	 ecx, esi
  00374	d3 e0		 shl	 eax, cl
  00376	42		 inc	 edx
  00377	83 c6 08	 add	 esi, 8
  0037a	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0037d	03 d8		 add	 ebx, eax
  0037f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00382	72 de		 jb	 SHORT $LL397@inflate
$LN399@inflate:

; 724  :                 state->length = (unsigned)(hold);
; 725  :                 if (state->head != Z_NULL)

  00384	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00387	89 5f 40	 mov	 DWORD PTR [edi+64], ebx
  0038a	85 c0		 test	 eax, eax
  0038c	74 03		 je	 SHORT $LN391@inflate

; 726  :                     state->head->extra_len = (unsigned)hold;

  0038e	89 58 14	 mov	 DWORD PTR [eax+20], ebx
$LN391@inflate:

; 727  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00391	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  00398	74 1e		 je	 SHORT $LN387@inflate
  0039a	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0039d	6a 02		 push	 2
  0039f	8d 4d ec	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  003a2	88 5d ec	 mov	 BYTE PTR _hbuf$[ebp], bl
  003a5	51		 push	 ecx
  003a6	c1 eb 08	 shr	 ebx, 8
  003a9	52		 push	 edx
  003aa	88 5d ed	 mov	 BYTE PTR _hbuf$[ebp+1], bl
  003ad	e8 00 00 00 00	 call	 _crc32@12
  003b2	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  003b5	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN387@inflate:

; 728  :                 INITBITS();

  003b8	33 db		 xor	 ebx, ebx
  003ba	33 f6		 xor	 esi, esi

; 729  :             }
; 730  :             else if (state->head != Z_NULL)

  003bc	eb 0e		 jmp	 SHORT $LN382@inflate
$LN401@inflate:
  003be	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  003c1	85 c0		 test	 eax, eax
  003c3	74 07		 je	 SHORT $LN382@inflate

; 731  :                 state->head->extra = Z_NULL;

  003c5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN382@inflate:

; 732  :             state->mode = EXTRA;

  003cc	c7 07 05 00 00
	00		 mov	 DWORD PTR [edi], 5
$LN709@inflate:

; 733  :         case EXTRA:
; 734  :             if (state->flags & 0x0400) {

  003d2	f7 47 10 00 04
	00 00		 test	 DWORD PTR [edi+16], 1024 ; 00000400H
  003d9	0f 84 93 00 00
	00		 je	 $LN375@inflate

; 735  :                 copy = state->length;

  003df	8b 47 40	 mov	 eax, DWORD PTR [edi+64]

; 736  :                 if (copy > have) copy = have;

  003e2	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  003e5	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  003e8	3b c1		 cmp	 eax, ecx
  003ea	76 05		 jbe	 SHORT $LN379@inflate
  003ec	8b c1		 mov	 eax, ecx
  003ee	89 4d f4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN379@inflate:

; 737  :                 if (copy) {

  003f1	85 c0		 test	 eax, eax
  003f3	74 73		 je	 SHORT $LN378@inflate

; 738  :                     if (state->head != Z_NULL &&
; 739  :                         state->head->extra != Z_NULL) {

  003f5	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  003f8	85 c9		 test	 ecx, ecx
  003fa	74 3e		 je	 SHORT $LN746@inflate
  003fc	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  003ff	89 4d d4	 mov	 DWORD PTR tv2134[ebp], ecx
  00402	85 c9		 test	 ecx, ecx
  00404	74 34		 je	 SHORT $LN746@inflate

; 740  :                         len = state->head->extra_len - state->length;

  00406	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00409	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0040c	2b 4f 40	 sub	 ecx, DWORD PTR [edi+64]

; 741  :                         zmemcpy(state->head->extra + len, next,
; 742  :                                 len + copy > state->head->extra_max ?
; 743  :                                 state->head->extra_max - len : copy);

  0040f	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00412	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  00415	03 c8		 add	 ecx, eax
  00417	3b ca		 cmp	 ecx, edx
  00419	76 05		 jbe	 SHORT $LN502@inflate
  0041b	2b 55 e4	 sub	 edx, DWORD PTR _len$[ebp]
  0041e	8b c2		 mov	 eax, edx
$LN502@inflate:
  00420	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00423	50		 push	 eax
  00424	8b 45 d4	 mov	 eax, DWORD PTR tv2134[ebp]
  00427	03 45 e4	 add	 eax, DWORD PTR _len$[ebp]
  0042a	52		 push	 edx
  0042b	50		 push	 eax
  0042c	e8 00 00 00 00	 call	 _memcpy
  00431	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00434	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00437	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN746@inflate:

; 744  :                     }
; 745  :                     if (state->flags & 0x0200)

  0043a	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  00441	74 1a		 je	 SHORT $LN376@inflate

; 746  :                         state->check = crc32(state->check, next, copy);

  00443	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00446	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00449	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0044c	52		 push	 edx
  0044d	50		 push	 eax
  0044e	51		 push	 ecx
  0044f	e8 00 00 00 00	 call	 _crc32@12
  00454	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00457	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0045a	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
$LN376@inflate:

; 747  :                     have -= copy;

  0045d	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 748  :                     next += copy;

  00460	03 d0		 add	 edx, eax

; 749  :                     state->length -= copy;

  00462	29 47 40	 sub	 DWORD PTR [edi+64], eax
  00465	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
$LN378@inflate:

; 750  :                 }
; 751  :                 if (state->length) goto inf_leave;

  00468	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  0046c	0f 85 c3 0e 00
	00		 jne	 $inf_leave$80535
$LN375@inflate:

; 752  :             }
; 753  :             state->length = 0;

  00472	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0

; 754  :             state->mode = NAME;

  00479	c7 07 06 00 00
	00		 mov	 DWORD PTR [edi], 6
$LN710@inflate:

; 755  :         case NAME:
; 756  :             if (state->flags & 0x0800) {

  0047f	f7 47 10 00 08
	00 00		 test	 DWORD PTR [edi+16], 2048 ; 00000800H
  00486	0f 84 84 00 00
	00		 je	 $LN373@inflate

; 757  :                 if (have == 0) goto inf_leave;

  0048c	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00490	0f 84 9f 0e 00
	00		 je	 $inf_leave$80535

; 758  :                 copy = 0;

  00496	33 c0		 xor	 eax, eax
$LL371@inflate:

; 759  :                 do {
; 760  :                     len = (unsigned)(next[copy++]);

  00498	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0049c	40		 inc	 eax
  0049d	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 761  :                     if (state->head != Z_NULL &&
; 762  :                             state->head->name != Z_NULL &&
; 763  :                             state->length < state->head->name_max)

  004a0	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  004a3	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  004a6	85 c0		 test	 eax, eax
  004a8	74 21		 je	 SHORT $LN370@inflate
  004aa	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  004ad	89 4d d4	 mov	 DWORD PTR tv2157[ebp], ecx
  004b0	85 c9		 test	 ecx, ecx
  004b2	74 17		 je	 SHORT $LN370@inflate
  004b4	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  004b7	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  004ba	73 0f		 jae	 SHORT $LN370@inflate

; 764  :                         state->head->name[state->length++] = len;

  004bc	8b 55 d4	 mov	 edx, DWORD PTR tv2157[ebp]
  004bf	8a 45 e4	 mov	 al, BYTE PTR _len$[ebp]
  004c2	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  004c5	ff 47 40	 inc	 DWORD PTR [edi+64]
  004c8	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LN370@inflate:

; 765  :                 } while (len && copy < have);

  004cb	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  004cf	74 08		 je	 SHORT $LN367@inflate
  004d1	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  004d4	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  004d7	72 bf		 jb	 SHORT $LL371@inflate
$LN367@inflate:

; 766  :                 if (state->flags & 0x0200)

  004d9	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  004e0	74 17		 je	 SHORT $LN366@inflate

; 767  :                     state->check = crc32(state->check, next, copy);

  004e2	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  004e5	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  004e8	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  004eb	51		 push	 ecx
  004ec	52		 push	 edx
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 _crc32@12
  004f3	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  004f6	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN366@inflate:

; 768  :                 have -= copy;

  004f9	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  004fc	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 769  :                 next += copy;

  004ff	03 d0		 add	 edx, eax

; 770  :                 if (len) goto inf_leave;

  00501	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00505	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00508	0f 85 27 0e 00
	00		 jne	 $inf_leave$80535

; 771  :             }
; 772  :             else if (state->head != Z_NULL)

  0050e	eb 0e		 jmp	 SHORT $LN363@inflate
$LN373@inflate:
  00510	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00513	85 c0		 test	 eax, eax
  00515	74 07		 je	 SHORT $LN363@inflate

; 773  :                 state->head->name = Z_NULL;

  00517	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN363@inflate:

; 774  :             state->length = 0;

  0051e	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0

; 775  :             state->mode = COMMENT;

  00525	c7 07 07 00 00
	00		 mov	 DWORD PTR [edi], 7
$LN714@inflate:

; 776  :         case COMMENT:
; 777  :             if (state->flags & 0x1000) {

  0052b	f7 47 10 00 10
	00 00		 test	 DWORD PTR [edi+16], 4096 ; 00001000H
  00532	0f 84 84 00 00
	00		 je	 $LN361@inflate

; 778  :                 if (have == 0) goto inf_leave;

  00538	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  0053c	0f 84 f3 0d 00
	00		 je	 $inf_leave$80535

; 779  :                 copy = 0;

  00542	33 c0		 xor	 eax, eax
$LL359@inflate:

; 780  :                 do {
; 781  :                     len = (unsigned)(next[copy++]);

  00544	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00548	40		 inc	 eax
  00549	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 782  :                     if (state->head != Z_NULL &&
; 783  :                             state->head->comment != Z_NULL &&
; 784  :                             state->length < state->head->comm_max)

  0054c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0054f	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  00552	85 c0		 test	 eax, eax
  00554	74 21		 je	 SHORT $LN358@inflate
  00556	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00559	89 4d d4	 mov	 DWORD PTR tv2173[ebp], ecx
  0055c	85 c9		 test	 ecx, ecx
  0055e	74 17		 je	 SHORT $LN358@inflate
  00560	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00563	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  00566	73 0f		 jae	 SHORT $LN358@inflate

; 785  :                         state->head->comment[state->length++] = len;

  00568	8b 55 d4	 mov	 edx, DWORD PTR tv2173[ebp]
  0056b	8a 45 e4	 mov	 al, BYTE PTR _len$[ebp]
  0056e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00571	ff 47 40	 inc	 DWORD PTR [edi+64]
  00574	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
$LN358@inflate:

; 786  :                 } while (len && copy < have);

  00577	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  0057b	74 08		 je	 SHORT $LN355@inflate
  0057d	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00580	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  00583	72 bf		 jb	 SHORT $LL359@inflate
$LN355@inflate:

; 787  :                 if (state->flags & 0x0200)

  00585	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  0058c	74 17		 je	 SHORT $LN354@inflate

; 788  :                     state->check = crc32(state->check, next, copy);

  0058e	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00591	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00594	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00597	51		 push	 ecx
  00598	52		 push	 edx
  00599	50		 push	 eax
  0059a	e8 00 00 00 00	 call	 _crc32@12
  0059f	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  005a2	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN354@inflate:

; 789  :                 have -= copy;

  005a5	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  005a8	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 790  :                 next += copy;

  005ab	03 d0		 add	 edx, eax

; 791  :                 if (len) goto inf_leave;

  005ad	83 7d e4 00	 cmp	 DWORD PTR _len$[ebp], 0
  005b1	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  005b4	0f 85 7b 0d 00
	00		 jne	 $inf_leave$80535

; 792  :             }
; 793  :             else if (state->head != Z_NULL)

  005ba	eb 0e		 jmp	 SHORT $LN351@inflate
$LN361@inflate:
  005bc	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  005bf	85 c0		 test	 eax, eax
  005c1	74 07		 je	 SHORT $LN351@inflate

; 794  :                 state->head->comment = Z_NULL;

  005c3	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN351@inflate:

; 795  :             state->mode = HCRC;

  005ca	c7 07 08 00 00
	00		 mov	 DWORD PTR [edi], 8
$LN718@inflate:

; 796  :         case HCRC:
; 797  :             if (state->flags & 0x0200) {

  005d0	f7 47 10 00 02
	00 00		 test	 DWORD PTR [edi+16], 512	; 00000200H
  005d7	74 44		 je	 SHORT $LN336@inflate

; 798  :                 NEEDBITS(16);

  005d9	83 fe 10	 cmp	 esi, 16			; 00000010H
  005dc	73 24		 jae	 SHORT $LN347@inflate
  005de	8b ff		 npad	 2
$LL345@inflate:
  005e0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  005e4	0f 84 4b 0d 00
	00		 je	 $inf_leave$80535
  005ea	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  005ed	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  005f0	8b ce		 mov	 ecx, esi
  005f2	d3 e0		 shl	 eax, cl
  005f4	42		 inc	 edx
  005f5	83 c6 08	 add	 esi, 8
  005f8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  005fb	03 d8		 add	 ebx, eax
  005fd	83 fe 10	 cmp	 esi, 16			; 00000010H
  00600	72 de		 jb	 SHORT $LL345@inflate
$LN347@inflate:

; 799  :                 if (hold != (state->check & 0xffff)) {

  00602	0f b7 4f 18	 movzx	 ecx, WORD PTR [edi+24]
  00606	3b d9		 cmp	 ebx, ecx
  00608	74 0f		 je	 SHORT $LN338@inflate

; 800  :                     strm->msg = (char *)"header crc mismatch";

  0060a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0060d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 801  :                     state->mode = BAD;
; 802  :                     break;

  00614	e9 b8 0c 00 00	 jmp	 $LN782@inflate
$LN338@inflate:

; 803  :                 }
; 804  :                 INITBITS();

  00619	33 db		 xor	 ebx, ebx
  0061b	33 f6		 xor	 esi, esi
$LN336@inflate:

; 805  :             }
; 806  :             if (state->head != Z_NULL) {

  0061d	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00620	85 c0		 test	 eax, eax
  00622	74 16		 je	 SHORT $LN335@inflate

; 807  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00624	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00627	c1 f9 09	 sar	 ecx, 9
  0062a	83 e1 01	 and	 ecx, 1
  0062d	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 808  :                 state->head->done = 1;

  00630	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00633	c7 42 30 01 00
	00 00		 mov	 DWORD PTR [edx+48], 1
$LN335@inflate:

; 809  :             }
; 810  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0063a	6a 00		 push	 0
  0063c	6a 00		 push	 0
  0063e	6a 00		 push	 0
  00640	e8 00 00 00 00	 call	 _crc32@12
  00645	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 811  :             state->mode = TYPE;
; 812  :             break;

  00648	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0064b	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0064e	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00651	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  00657	e9 7b 0c 00 00	 jmp	 $LN490@inflate
$LN333@inflate:

; 813  : #endif
; 814  :         case DICTID:
; 815  :             NEEDBITS(32);

  0065c	83 fe 20	 cmp	 esi, 32			; 00000020H
  0065f	73 22		 jae	 SHORT $LN332@inflate
$LL330@inflate:
  00661	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00665	0f 84 ca 0c 00
	00		 je	 $inf_leave$80535
  0066b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0066e	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00671	8b ce		 mov	 ecx, esi
  00673	d3 e0		 shl	 eax, cl
  00675	42		 inc	 edx
  00676	83 c6 08	 add	 esi, 8
  00679	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0067c	03 d8		 add	 ebx, eax
  0067e	83 fe 20	 cmp	 esi, 32			; 00000020H
  00681	72 de		 jb	 SHORT $LL330@inflate
$LN332@inflate:

; 816  :             strm->adler = state->check = ZSWAP32(hold);

  00683	8b cb		 mov	 ecx, ebx
  00685	8b c3		 mov	 eax, ebx
  00687	c1 e0 10	 shl	 eax, 16			; 00000010H
  0068a	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00690	03 c8		 add	 ecx, eax
  00692	8b c3		 mov	 eax, ebx
  00694	c1 e8 08	 shr	 eax, 8
  00697	c1 e1 08	 shl	 ecx, 8
  0069a	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0069f	03 c1		 add	 eax, ecx
  006a1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  006a4	c1 eb 18	 shr	 ebx, 24			; 00000018H
  006a7	03 c3		 add	 eax, ebx
  006a9	89 47 18	 mov	 DWORD PTR [edi+24], eax
  006ac	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 817  :             INITBITS();

  006af	33 db		 xor	 ebx, ebx
  006b1	33 f6		 xor	 esi, esi

; 818  :             state->mode = DICT;

  006b3	c7 07 0a 00 00
	00		 mov	 DWORD PTR [edi], 10	; 0000000aH
$LN720@inflate:

; 819  :         case DICT:
; 820  :             if (state->havedict == 0) {

  006b9	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  006bd	0f 84 2d 0c 00
	00		 je	 $LN579@inflate

; 823  :             }
; 824  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  006c3	6a 00		 push	 0
  006c5	6a 00		 push	 0
  006c7	6a 00		 push	 0
  006c9	e8 00 00 00 00	 call	 _adler32@12
  006ce	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  006d1	89 47 18	 mov	 DWORD PTR [edi+24], eax
  006d4	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 825  :             state->mode = TYPE;

  006d7	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  006da	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
$LN316@inflate:

; 826  :         case TYPE:
; 827  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  006e0	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  006e4	0f 84 4b 0c 00
	00		 je	 $inf_leave$80535
  006ea	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  006ee	0f 84 41 0c 00
	00		 je	 $inf_leave$80535
$LN315@inflate:

; 828  :         case TYPEDO:
; 829  :             if (state->last) {

  006f4	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  006f8	74 14		 je	 SHORT $LN308@inflate

; 830  :                 BYTEBITS();

  006fa	8b ce		 mov	 ecx, esi
  006fc	83 e1 07	 and	 ecx, 7
  006ff	d3 eb		 shr	 ebx, cl
  00701	2b f1		 sub	 esi, ecx

; 831  :                 state->mode = CHECK;

  00703	c7 07 1a 00 00
	00		 mov	 DWORD PTR [edi], 26	; 0000001aH

; 832  :                 break;

  00709	e9 c9 0b 00 00	 jmp	 $LN490@inflate
$LN308@inflate:

; 833  :             }
; 834  :             NEEDBITS(3);

  0070e	83 fe 03	 cmp	 esi, 3
  00711	73 22		 jae	 SHORT $LN307@inflate
$LL305@inflate:
  00713	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00717	0f 84 18 0c 00
	00		 je	 $inf_leave$80535
  0071d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00720	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00723	8b ce		 mov	 ecx, esi
  00725	d3 e0		 shl	 eax, cl
  00727	42		 inc	 edx
  00728	83 c6 08	 add	 esi, 8
  0072b	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0072e	03 d8		 add	 ebx, eax
  00730	83 fe 03	 cmp	 esi, 3
  00733	72 de		 jb	 SHORT $LL305@inflate
$LN307@inflate:

; 835  :             state->last = BITS(1);

  00735	8b cb		 mov	 ecx, ebx

; 836  :             DROPBITS(1);

  00737	d1 eb		 shr	 ebx, 1

; 837  :             switch (BITS(2)) {

  00739	8b c3		 mov	 eax, ebx
  0073b	83 e1 01	 and	 ecx, 1
  0073e	83 e0 03	 and	 eax, 3
  00741	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00744	83 f8 03	 cmp	 eax, 3
  00747	77 57		 ja	 SHORT $LN286@inflate
  00749	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN784@inflate[eax*4]
$LN294@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  00750	c1 eb 02	 shr	 ebx, 2
  00753	c7 07 0d 00 00
	00		 mov	 DWORD PTR [edi], 13	; 0000000dH
  00759	83 ee 03	 sub	 esi, 3

; 863  :             break;

  0075c	e9 76 0b 00 00	 jmp	 $LN490@inflate
$LN293@inflate:

; 838  :             case 0:                             /* stored block */
; 839  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 840  :                         state->last ? " (last)" : ""));
; 841  :                 state->mode = STORED;
; 842  :                 break;
; 843  :             case 1:                             /* fixed block */
; 844  :                 fixedtables(state);

  00761	8b c7		 mov	 eax, edi
  00763	e8 00 00 00 00	 call	 _fixedtables

; 845  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 846  :                         state->last ? " (last)" : ""));
; 847  :                 state->mode = LEN_;             /* decode codes */
; 848  :                 if (flush == Z_TREES) {

  00768	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0076c	c7 07 13 00 00
	00		 mov	 DWORD PTR [edi], 19	; 00000013H
  00772	75 2c		 jne	 SHORT $LN286@inflate

; 849  :                     DROPBITS(2);

  00774	c1 eb 02	 shr	 ebx, 2
  00777	83 ee 03	 sub	 esi, 3

; 850  :                     goto inf_leave;

  0077a	e9 b6 0b 00 00	 jmp	 $inf_leave$80535
$LN288@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  0077f	c1 eb 02	 shr	 ebx, 2
  00782	c7 07 10 00 00
	00		 mov	 DWORD PTR [edi], 16	; 00000010H
  00788	83 ee 03	 sub	 esi, 3

; 863  :             break;

  0078b	e9 47 0b 00 00	 jmp	 $LN490@inflate
$LN287@inflate:

; 851  :                 }
; 852  :                 break;
; 853  :             case 2:                             /* dynamic block */
; 854  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 855  :                         state->last ? " (last)" : ""));
; 856  :                 state->mode = TABLE;
; 857  :                 break;
; 858  :             case 3:
; 859  :                 strm->msg = (char *)"invalid block type";

  00790	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00793	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 860  :                 state->mode = BAD;

  0079a	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH
$LN286@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  007a0	c1 eb 02	 shr	 ebx, 2
  007a3	83 ee 03	 sub	 esi, 3

; 863  :             break;

  007a6	e9 2c 0b 00 00	 jmp	 $LN490@inflate
$LN282@inflate:

; 864  :         case STORED:
; 865  :             BYTEBITS();                         /* go to byte boundary */

  007ab	8b ce		 mov	 ecx, esi
  007ad	83 e1 07	 and	 ecx, 7
  007b0	2b f1		 sub	 esi, ecx
  007b2	d3 eb		 shr	 ebx, cl

; 866  :             NEEDBITS(32);

  007b4	83 fe 20	 cmp	 esi, 32			; 00000020H
  007b7	73 29		 jae	 SHORT $LN278@inflate
  007b9	8d a4 24 00 00
	00 00		 npad	 7
$LL276@inflate:
  007c0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  007c4	0f 84 6b 0b 00
	00		 je	 $inf_leave$80535
  007ca	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  007cd	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  007d0	8b ce		 mov	 ecx, esi
  007d2	d3 e0		 shl	 eax, cl
  007d4	42		 inc	 edx
  007d5	83 c6 08	 add	 esi, 8
  007d8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  007db	03 d8		 add	 ebx, eax
  007dd	83 fe 20	 cmp	 esi, 32			; 00000020H
  007e0	72 de		 jb	 SHORT $LL276@inflate
$LN278@inflate:

; 867  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  007e2	8b cb		 mov	 ecx, ebx
  007e4	8b c3		 mov	 eax, ebx
  007e6	f7 d1		 not	 ecx
  007e8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007ed	c1 e9 10	 shr	 ecx, 16			; 00000010H
  007f0	3b c1		 cmp	 eax, ecx
  007f2	74 0f		 je	 SHORT $LN270@inflate

; 868  :                 strm->msg = (char *)"invalid stored block lengths";

  007f4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  007f7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 869  :                 state->mode = BAD;
; 870  :                 break;

  007fe	e9 ce 0a 00 00	 jmp	 $LN782@inflate
$LN270@inflate:

; 871  :             }
; 872  :             state->length = (unsigned)hold & 0xffff;
; 873  :             Tracev((stderr, "inflate:       stored length %u\n",
; 874  :                     state->length));
; 875  :             INITBITS();

  00803	33 db		 xor	 ebx, ebx
  00805	33 f6		 xor	 esi, esi

; 876  :             state->mode = COPY_;
; 877  :             if (flush == Z_TREES) goto inf_leave;

  00807	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0080b	89 47 40	 mov	 DWORD PTR [edi+64], eax
  0080e	c7 07 0e 00 00
	00		 mov	 DWORD PTR [edi], 14	; 0000000eH
  00814	0f 84 1b 0b 00
	00		 je	 $inf_leave$80535
$LN266@inflate:

; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  0081a	c7 07 0f 00 00
	00		 mov	 DWORD PTR [edi], 15	; 0000000fH
$LN264@inflate:

; 880  :         case COPY:
; 881  :             copy = state->length;

  00820	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00823	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 882  :             if (copy) {

  00826	85 c0		 test	 eax, eax
  00828	0f 84 73 06 00
	00		 je	 $LN263@inflate

; 883  :                 if (copy > have) copy = have;

  0082e	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  00831	3b c1		 cmp	 eax, ecx
  00833	76 05		 jbe	 SHORT $LN262@inflate
  00835	8b c1		 mov	 eax, ecx
  00837	89 4d f4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN262@inflate:

; 884  :                 if (copy > left) copy = left;

  0083a	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  0083d	3b c1		 cmp	 eax, ecx
  0083f	76 05		 jbe	 SHORT $LN261@inflate
  00841	8b c1		 mov	 eax, ecx
  00843	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN261@inflate:

; 885  :                 if (copy == 0) goto inf_leave;

  00846	85 c0		 test	 eax, eax
  00848	0f 84 e7 0a 00
	00		 je	 $inf_leave$80535

; 886  :                 zmemcpy(put, next, copy);

  0084e	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00851	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00854	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  00857	51		 push	 ecx
  00858	52		 push	 edx
  00859	50		 push	 eax
  0085a	e8 00 00 00 00	 call	 _memcpy

; 887  :                 have -= copy;

  0085f	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]

; 888  :                 next += copy;

  00862	01 45 f8	 add	 DWORD PTR _next$[ebp], eax
  00865	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 889  :                 left -= copy;

  00868	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax

; 890  :                 put += copy;

  0086b	01 45 e8	 add	 DWORD PTR _put$[ebp], eax

; 891  :                 state->length -= copy;
; 892  :                 break;

  0086e	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00871	83 c4 0c	 add	 esp, 12			; 0000000cH
  00874	29 47 40	 sub	 DWORD PTR [edi+64], eax
  00877	e9 5b 0a 00 00	 jmp	 $LN490@inflate
$LN258@inflate:

; 893  :             }
; 894  :             Tracev((stderr, "inflate:       stored end\n"));
; 895  :             state->mode = TYPE;
; 896  :             break;
; 897  :         case TABLE:
; 898  :             NEEDBITS(14);

  0087c	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0087f	73 22		 jae	 SHORT $LN257@inflate
$LL255@inflate:
  00881	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00885	0f 84 aa 0a 00
	00		 je	 $inf_leave$80535
  0088b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0088e	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00891	8b ce		 mov	 ecx, esi
  00893	d3 e0		 shl	 eax, cl
  00895	42		 inc	 edx
  00896	83 c6 08	 add	 esi, 8
  00899	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  0089c	03 d8		 add	 ebx, eax
  0089e	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  008a1	72 de		 jb	 SHORT $LL255@inflate
$LN257@inflate:

; 899  :             state->nlen = BITS(5) + 257;

  008a3	8b cb		 mov	 ecx, ebx
  008a5	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 900  :             DROPBITS(5);

  008a8	c1 eb 05	 shr	 ebx, 5
  008ab	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H

; 901  :             state->ndist = BITS(5) + 1;

  008b1	8b c3		 mov	 eax, ebx
  008b3	89 4f 60	 mov	 DWORD PTR [edi+96], ecx

; 902  :             DROPBITS(5);

  008b6	c1 eb 05	 shr	 ebx, 5

; 903  :             state->ncode = BITS(4) + 4;

  008b9	8b cb		 mov	 ecx, ebx
  008bb	83 e0 1f	 and	 eax, 31			; 0000001fH
  008be	83 e1 0f	 and	 ecx, 15			; 0000000fH
  008c1	40		 inc	 eax
  008c2	83 c1 04	 add	 ecx, 4

; 904  :             DROPBITS(4);

  008c5	c1 eb 04	 shr	 ebx, 4
  008c8	83 ee 0e	 sub	 esi, 14			; 0000000eH

; 905  : #ifndef PKZIP_BUG_WORKAROUND
; 906  :             if (state->nlen > 286 || state->ndist > 30) {

  008cb	81 7f 60 1e 01
	00 00		 cmp	 DWORD PTR [edi+96], 286	; 0000011eH
  008d2	89 47 64	 mov	 DWORD PTR [edi+100], eax
  008d5	89 4f 5c	 mov	 DWORD PTR [edi+92], ecx
  008d8	0f 87 e5 00 00
	00		 ja	 $LN239@inflate
  008de	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  008e1	0f 87 dc 00 00
	00		 ja	 $LN239@inflate

; 910  :             }
; 911  : #endif
; 912  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 913  :             state->have = 0;

  008e7	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], 0

; 914  :             state->mode = LENLENS;

  008ee	c7 07 11 00 00
	00		 mov	 DWORD PTR [edi], 17	; 00000011H
$LN724@inflate:

; 915  :         case LENLENS:
; 916  :             while (state->have < state->ncode) {

  008f4	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  008f7	3b 4f 5c	 cmp	 ecx, DWORD PTR [edi+92]
  008fa	73 51		 jae	 SHORT $LN527@inflate
  008fc	8d 64 24 00	 npad	 4
$LL237@inflate:

; 917  :                 NEEDBITS(3);

  00900	83 fe 03	 cmp	 esi, 3
  00903	73 22		 jae	 SHORT $LN234@inflate
$LL232@inflate:
  00905	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00909	0f 84 26 0a 00
	00		 je	 $inf_leave$80535
  0090f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00912	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00915	8b ce		 mov	 ecx, esi
  00917	d3 e0		 shl	 eax, cl
  00919	42		 inc	 edx
  0091a	83 c6 08	 add	 esi, 8
  0091d	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00920	03 d8		 add	 ebx, eax
  00922	83 fe 03	 cmp	 esi, 3
  00925	72 de		 jb	 SHORT $LL232@inflate
$LN234@inflate:

; 918  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00927	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  0092a	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00932	8b cb		 mov	 ecx, ebx
  00934	83 e1 07	 and	 ecx, 7
  00937	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  0093c	ff 47 68	 inc	 DWORD PTR [edi+104]
  0093f	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]

; 919  :                 DROPBITS(3);

  00942	c1 eb 03	 shr	 ebx, 3
  00945	83 ee 03	 sub	 esi, 3
  00948	3b 4f 5c	 cmp	 ecx, DWORD PTR [edi+92]
  0094b	72 b3		 jb	 SHORT $LL237@inflate
$LN527@inflate:

; 920  :             }
; 921  :             while (state->have < 19)

  0094d	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00952	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  00955	73 23		 jae	 SHORT $LN222@inflate
  00957	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL223@inflate:

; 922  :                 state->lens[order[state->have++]] = 0;

  00960	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00963	0f b7 0c 55 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[edx*2]
  0096b	33 d2		 xor	 edx, edx
  0096d	66 89 54 4f 70	 mov	 WORD PTR [edi+ecx*2+112], dx
  00972	ff 47 68	 inc	 DWORD PTR [edi+104]
  00975	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  00978	72 e6		 jb	 SHORT $LL223@inflate
$LN222@inflate:

; 923  :             state->next = state->codes;

  0097a	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  00980	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00983	89 01		 mov	 DWORD PTR [ecx], eax

; 924  :             state->lencode = (const code FAR *)(state->next);

  00985	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 925  :             state->lenbits = 7;
; 926  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 927  :                                 &(state->lenbits), state->work);

  00988	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  0098e	52		 push	 edx
  0098f	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  00992	50		 push	 eax
  00993	51		 push	 ecx
  00994	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
  0099a	6a 13		 push	 19			; 00000013H
  0099c	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  0099f	50		 push	 eax
  009a0	6a 00		 push	 0
  009a2	e8 00 00 00 00	 call	 _inflate_table

; 930  :                 state->mode = BAD;
; 931  :                 break;

  009a7	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  009aa	83 c4 18	 add	 esp, 24			; 00000018H
  009ad	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax
  009b0	85 c0		 test	 eax, eax
  009b2	74 1e		 je	 SHORT $LN221@inflate

; 928  :             if (ret) {
; 929  :                 strm->msg = (char *)"invalid code lengths set";

  009b4	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  009b7	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 930  :                 state->mode = BAD;
; 931  :                 break;

  009be	e9 0e 09 00 00	 jmp	 $LN782@inflate
$LN239@inflate:

; 907  :                 strm->msg = (char *)"too many length or distance symbols";

  009c3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  009c6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 908  :                 state->mode = BAD;
; 909  :                 break;

  009cd	e9 ff 08 00 00	 jmp	 $LN782@inflate
$LN221@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 934  :             state->have = 0;

  009d2	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], 0

; 935  :             state->mode = CODELENS;

  009d9	c7 07 12 00 00
	00		 mov	 DWORD PTR [edi], 18	; 00000012H
$LN528@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  009df	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  009e2	03 47 60	 add	 eax, DWORD PTR [edi+96]
  009e5	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  009e8	0f 83 e5 01 00
	00		 jae	 $LN218@inflate
  009ee	8b ff		 npad	 2
$LL219@inflate:

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  009f0	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  009f3	b8 01 00 00 00	 mov	 eax, 1
  009f8	d3 e0		 shl	 eax, cl
  009fa	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  009fd	48		 dec	 eax
  009fe	23 c3		 and	 eax, ebx
  00a00	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]

; 940  :                     if ((unsigned)(here.bits) <= bits) break;

  00a03	8b c1		 mov	 eax, ecx
  00a05	c1 e8 08	 shr	 eax, 8
  00a08	0f b6 c0	 movzx	 eax, al
  00a0b	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx
  00a0e	3b c6		 cmp	 eax, esi
  00a10	76 3f		 jbe	 SHORT $LN555@inflate
$LL217@inflate:

; 941  :                     PULLBYTE();

  00a12	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a16	0f 84 19 09 00
	00		 je	 $inf_leave$80535
  00a1c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00a1f	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00a22	8b ce		 mov	 ecx, esi
  00a24	d3 e0		 shl	 eax, cl
  00a26	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00a29	42		 inc	 edx
  00a2a	83 c6 08	 add	 esi, 8
  00a2d	03 d8		 add	 ebx, eax
  00a2f	b8 01 00 00 00	 mov	 eax, 1
  00a34	d3 e0		 shl	 eax, cl
  00a36	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00a39	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00a3c	48		 dec	 eax
  00a3d	23 c3		 and	 eax, ebx
  00a3f	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00a42	8b c1		 mov	 eax, ecx
  00a44	c1 e8 08	 shr	 eax, 8
  00a47	0f b6 c0	 movzx	 eax, al
  00a4a	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx
  00a4d	3b c6		 cmp	 eax, esi
  00a4f	77 c1		 ja	 SHORT $LL217@inflate
$LN555@inflate:

; 942  :                 }
; 943  :                 if (here.val < 16) {

  00a51	8b c1		 mov	 eax, ecx
  00a53	c1 e8 10	 shr	 eax, 16			; 00000010H
  00a56	89 45 d4	 mov	 DWORD PTR tv2303[ebp], eax
  00a59	66 83 f8 10	 cmp	 ax, 16			; 00000010H
  00a5d	73 1a		 jae	 SHORT $LN778@inflate

; 944  :                     DROPBITS(here.bits);

  00a5f	c1 e9 08	 shr	 ecx, 8
  00a62	0f b6 c9	 movzx	 ecx, cl
  00a65	d3 eb		 shr	 ebx, cl
  00a67	2b f1		 sub	 esi, ecx

; 945  :                     state->lens[state->have++] = here.val;

  00a69	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00a6c	66 89 44 4f 70	 mov	 WORD PTR [edi+ecx*2+112], ax
  00a71	ff 47 68	 inc	 DWORD PTR [edi+104]

; 946  :                 }
; 947  :                 else {

  00a74	e9 4b 01 00 00	 jmp	 $LN727@inflate
$LN778@inflate:

; 948  :                     if (here.val == 16) {

  00a79	75 6f		 jne	 SHORT $LN205@inflate

; 949  :                         NEEDBITS(here.bits + 2);

  00a7b	8b c1		 mov	 eax, ecx
  00a7d	c1 e8 08	 shr	 eax, 8
  00a80	0f b6 c0	 movzx	 eax, al
  00a83	83 c0 02	 add	 eax, 2
  00a86	3b f0		 cmp	 esi, eax
  00a88	73 30		 jae	 SHORT $LN203@inflate
  00a8a	8d 9b 00 00 00
	00		 npad	 6
$LL201@inflate:
  00a90	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a94	0f 84 9b 08 00
	00		 je	 $inf_leave$80535
  00a9a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00a9d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00aa0	8b ce		 mov	 ecx, esi
  00aa2	d3 e0		 shl	 eax, cl
  00aa4	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  00aa7	42		 inc	 edx
  00aa8	83 c6 08	 add	 esi, 8
  00aab	03 d8		 add	 ebx, eax
  00aad	0f b6 c5	 movzx	 eax, ch
  00ab0	83 c0 02	 add	 eax, 2
  00ab3	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00ab6	3b f0		 cmp	 esi, eax
  00ab8	72 d6		 jb	 SHORT $LL201@inflate
$LN203@inflate:

; 950  :                         DROPBITS(here.bits);
; 951  :                         if (state->have == 0) {

  00aba	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00abd	0f b6 cd	 movzx	 ecx, ch
  00ac0	d3 eb		 shr	 ebx, cl
  00ac2	2b f1		 sub	 esi, ecx
  00ac4	85 c0		 test	 eax, eax
  00ac6	0f 84 29 01 00
	00		 je	 $LN560@inflate

; 955  :                         }
; 956  :                         len = state->lens[state->have - 1];

  00acc	0f b7 4c 47 6e	 movzx	 ecx, WORD PTR [edi+eax*2+110]

; 957  :                         copy = 3 + BITS(2);

  00ad1	8b c3		 mov	 eax, ebx
  00ad3	83 e0 03	 and	 eax, 3
  00ad6	83 c0 03	 add	 eax, 3

; 958  :                         DROPBITS(2);

  00ad9	c1 eb 02	 shr	 ebx, 2
  00adc	89 4d e4	 mov	 DWORD PTR _len$[ebp], ecx
  00adf	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  00ae2	83 ee 02	 sub	 esi, 2

; 959  :                     }
; 960  :                     else if (here.val == 17) {

  00ae5	e9 a5 00 00 00	 jmp	 $LN156@inflate
$LN205@inflate:
  00aea	66 83 7d f6 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 961  :                         NEEDBITS(here.bits + 3);

  00aef	0f b6 cd	 movzx	 ecx, ch
  00af2	89 4d dc	 mov	 DWORD PTR tv2314[ebp], ecx
  00af5	75 47		 jne	 SHORT $LN170@inflate
  00af7	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00afa	3b f0		 cmp	 esi, eax
  00afc	73 29		 jae	 SHORT $LN185@inflate
  00afe	8b ff		 npad	 2
$LL183@inflate:
  00b00	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b04	0f 84 2b 08 00
	00		 je	 $inf_leave$80535
  00b0a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b0d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00b10	8b ce		 mov	 ecx, esi
  00b12	d3 e0		 shl	 eax, cl
  00b14	8b 4d dc	 mov	 ecx, DWORD PTR tv2314[ebp]
  00b17	42		 inc	 edx
  00b18	83 c6 08	 add	 esi, 8
  00b1b	03 d8		 add	 ebx, eax
  00b1d	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00b20	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00b23	3b f0		 cmp	 esi, eax
  00b25	72 d9		 jb	 SHORT $LL183@inflate
$LN185@inflate:

; 962  :                         DROPBITS(here.bits);

  00b27	d3 eb		 shr	 ebx, cl

; 963  :                         len = 0;
; 964  :                         copy = 3 + BITS(3);

  00b29	8b c3		 mov	 eax, ebx
  00b2b	83 e0 07	 and	 eax, 7
  00b2e	83 c0 03	 add	 eax, 3
  00b31	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 965  :                         DROPBITS(3);

  00b34	c1 eb 03	 shr	 ebx, 3
  00b37	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 966  :                     }
; 967  :                     else {

  00b3c	eb 43		 jmp	 SHORT $LN779@inflate
$LN170@inflate:

; 968  :                         NEEDBITS(here.bits + 7);

  00b3e	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00b41	3b f0		 cmp	 esi, eax
  00b43	73 27		 jae	 SHORT $LN169@inflate
$LL167@inflate:
  00b45	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b49	0f 84 e6 07 00
	00		 je	 $inf_leave$80535
  00b4f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b52	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00b55	8b ce		 mov	 ecx, esi
  00b57	d3 e0		 shl	 eax, cl
  00b59	8b 4d dc	 mov	 ecx, DWORD PTR tv2314[ebp]
  00b5c	42		 inc	 edx
  00b5d	83 c6 08	 add	 esi, 8
  00b60	03 d8		 add	 ebx, eax
  00b62	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00b65	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00b68	3b f0		 cmp	 esi, eax
  00b6a	72 d9		 jb	 SHORT $LL167@inflate
$LN169@inflate:

; 969  :                         DROPBITS(here.bits);

  00b6c	d3 eb		 shr	 ebx, cl

; 970  :                         len = 0;
; 971  :                         copy = 11 + BITS(7);

  00b6e	8b c3		 mov	 eax, ebx
  00b70	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b73	83 c0 0b	 add	 eax, 11			; 0000000bH
  00b76	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 972  :                         DROPBITS(7);

  00b79	c1 eb 07	 shr	 ebx, 7
  00b7c	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN779@inflate:
  00b81	2b c1		 sub	 eax, ecx
  00b83	03 f0		 add	 esi, eax
  00b85	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  00b88	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN156@inflate:

; 973  :                     }
; 974  :                     if (state->have + copy > state->nlen + state->ndist) {

  00b8f	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00b92	03 c8		 add	 ecx, eax
  00b94	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00b97	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00b9a	3b c8		 cmp	 ecx, eax
  00b9c	77 66		 ja	 SHORT $LN561@inflate

; 976  :                         state->mode = BAD;
; 977  :                         break;
; 978  :                     }
; 979  :                     while (copy--)

  00b9e	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00ba2	74 20		 je	 SHORT $LN727@inflate
  00ba4	8b 45 e4	 mov	 eax, DWORD PTR _len$[ebp]
  00ba7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL154@inflate:

; 980  :                         state->lens[state->have++] = (unsigned short)len;

  00bb0	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00bb3	ff 4d f4	 dec	 DWORD PTR _copy$[ebp]
  00bb6	66 89 44 4f 70	 mov	 WORD PTR [edi+ecx*2+112], ax
  00bbb	ff 47 68	 inc	 DWORD PTR [edi+104]
  00bbe	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00bc2	75 ec		 jne	 SHORT $LL154@inflate
$LN727@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00bc4	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00bc7	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00bca	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  00bcd	0f 82 1d fe ff
	ff		 jb	 $LL219@inflate
$LN218@inflate:

; 981  :                 }
; 982  :             }
; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  00bd3	83 3f 1d	 cmp	 DWORD PTR [edi], 29	; 0000001dH
  00bd6	0f 84 fb 06 00
	00		 je	 $LN490@inflate

; 986  : 
; 987  :             /* check for end-of-block code (better have one) */
; 988  :             if (state->lens[256] == 0) {

  00bdc	66 83 bf 70 02
	00 00 00	 cmp	 WORD PTR [edi+624], 0
  00be4	75 2d		 jne	 SHORT $LN151@inflate

; 989  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00be6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00be9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 990  :                 state->mode = BAD;
; 991  :                 break;

  00bf0	e9 dc 06 00 00	 jmp	 $LN782@inflate
$LN560@inflate:

; 952  :                             strm->msg = (char *)"invalid bit length repeat";

  00bf5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00bf8	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 953  :                             state->mode = BAD;
; 954  :                             break;

  00bff	e9 cd 06 00 00	 jmp	 $LN782@inflate
$LN561@inflate:

; 975  :                         strm->msg = (char *)"invalid bit length repeat";

  00c04	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c07	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 981  :                 }
; 982  :             }
; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  00c0e	e9 be 06 00 00	 jmp	 $LN782@inflate
$LN151@inflate:

; 992  :             }
; 993  : 
; 994  :             /* build code tables -- note: do not change the lenbits or distbits
; 995  :                values here (9 and 6) without reading the comments in inftrees.h
; 996  :                concerning the ENOUGH constants, which depend on those values */
; 997  :             state->next = state->codes;

  00c13	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  00c19	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00c1c	89 01		 mov	 DWORD PTR [ecx], eax

; 998  :             state->lencode = (const code FAR *)(state->next);

  00c1e	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 999  :             state->lenbits = 9;
; 1000 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1001 :                                 &(state->lenbits), state->work);

  00c21	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  00c27	52		 push	 edx
  00c28	8b 57 60	 mov	 edx, DWORD PTR [edi+96]
  00c2b	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  00c2e	50		 push	 eax
  00c2f	51		 push	 ecx
  00c30	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  00c36	52		 push	 edx
  00c37	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  00c3a	50		 push	 eax
  00c3b	6a 01		 push	 1
  00c3d	e8 00 00 00 00	 call	 _inflate_table
  00c42	83 c4 18	 add	 esp, 24			; 00000018H
  00c45	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1002 :             if (ret) {

  00c48	85 c0		 test	 eax, eax
  00c4a	74 12		 je	 SHORT $LN150@inflate

; 1003 :                 strm->msg = (char *)"invalid literal/lengths set";

  00c4c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]

; 1004 :                 state->mode = BAD;
; 1005 :                 break;

  00c4f	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00c52	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00c59	e9 73 06 00 00	 jmp	 $LN782@inflate
$LN150@inflate:

; 1006 :             }
; 1007 :             state->distcode = (const code FAR *)(state->next);

  00c5e	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]
  00c61	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00c64	89 57 50	 mov	 DWORD PTR [edi+80], edx

; 1008 :             state->distbits = 6;
; 1009 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1010 :                             &(state->next), &(state->distbits), state->work);

  00c67	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  00c6d	52		 push	 edx
  00c6e	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  00c71	50		 push	 eax
  00c72	51		 push	 ecx
  00c73	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  00c76	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  00c7c	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00c7f	50		 push	 eax
  00c80	8d 54 4f 70	 lea	 edx, DWORD PTR [edi+ecx*2+112]
  00c84	52		 push	 edx
  00c85	6a 02		 push	 2
  00c87	e8 00 00 00 00	 call	 _inflate_table

; 1013 :                 state->mode = BAD;
; 1014 :                 break;

  00c8c	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00c8f	83 c4 18	 add	 esp, 24			; 00000018H
  00c92	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax
  00c95	85 c0		 test	 eax, eax
  00c97	74 0f		 je	 SHORT $LN149@inflate

; 1011 :             if (ret) {
; 1012 :                 strm->msg = (char *)"invalid distances set";

  00c99	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c9c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1013 :                 state->mode = BAD;
; 1014 :                 break;

  00ca3	e9 29 06 00 00	 jmp	 $LN782@inflate
$LN149@inflate:

; 1015 :             }
; 1016 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1017 :             state->mode = LEN_;
; 1018 :             if (flush == Z_TREES) goto inf_leave;

  00ca8	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00cac	c7 07 13 00 00
	00		 mov	 DWORD PTR [edi], 19	; 00000013H
  00cb2	0f 84 7d 06 00
	00		 je	 $inf_leave$80535
$LN148@inflate:

; 1019 :         case LEN_:
; 1020 :             state->mode = LEN;

  00cb8	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H
$LN146@inflate:

; 1021 :         case LEN:
; 1022 :             if (have >= 6 && left >= 258) {

  00cbe	83 7d fc 06	 cmp	 DWORD PTR _have$[ebp], 6
  00cc2	72 6e		 jb	 SHORT $LN145@inflate
  00cc4	81 7d f0 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00ccb	72 65		 jb	 SHORT $LN145@inflate

; 1023 :                 RESTORE();

  00ccd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00cd0	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  00cd3	8b 55 f0	 mov	 edx, DWORD PTR _left$[ebp]
  00cd6	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00cd9	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00cdc	89 08		 mov	 DWORD PTR [eax], ecx

; 1024 :                 inflate_fast(strm, out);

  00cde	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  00ce1	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00ce4	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  00ce7	51		 push	 ecx
  00ce8	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00ceb	50		 push	 eax
  00cec	89 5f 38	 mov	 DWORD PTR [edi+56], ebx
  00cef	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  00cf2	e8 00 00 00 00	 call	 _inflate_fast

; 1025 :                 LOAD();

  00cf7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00cfa	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00cfd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00d00	8b 5f 38	 mov	 ebx, DWORD PTR [edi+56]
  00d03	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  00d06	89 55 e8	 mov	 DWORD PTR _put$[ebp], edx
  00d09	8b 10		 mov	 edx, DWORD PTR [eax]
  00d0b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00d0e	83 c4 08	 add	 esp, 8

; 1026 :                 if (state->mode == TYPE)

  00d11	83 3f 0b	 cmp	 DWORD PTR [edi], 11	; 0000000bH
  00d14	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  00d17	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00d1a	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00d1d	0f 85 b4 05 00
	00		 jne	 $LN490@inflate

; 1027 :                     state->back = -1;

  00d23	c7 87 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+7108], -1

; 1028 :                 break;

  00d2d	e9 a5 05 00 00	 jmp	 $LN490@inflate
$LN145@inflate:

; 1029 :             }
; 1030 :             state->back = 0;
; 1031 :             for (;;) {
; 1032 :                 here = state->lencode[BITS(state->lenbits)];

  00d32	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00d35	b8 01 00 00 00	 mov	 eax, 1
  00d3a	d3 e0		 shl	 eax, cl
  00d3c	c7 87 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+7108], 0
  00d46	48		 dec	 eax
  00d47	23 c3		 and	 eax, ebx
  00d49	8b c8		 mov	 ecx, eax
  00d4b	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00d4e	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1033 :                 if ((unsigned)(here.bits) <= bits) break;

  00d51	8b c8		 mov	 ecx, eax
  00d53	c1 e9 08	 shr	 ecx, 8
  00d56	0f b6 c9	 movzx	 ecx, cl
  00d59	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00d5c	3b ce		 cmp	 ecx, esi
  00d5e	76 3f		 jbe	 SHORT $LN562@inflate
$LL137@inflate:

; 1034 :                 PULLBYTE();

  00d60	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d64	0f 84 cb 05 00
	00		 je	 $inf_leave$80535
  00d6a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d6d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00d70	8b ce		 mov	 ecx, esi
  00d72	d3 e0		 shl	 eax, cl
  00d74	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00d77	42		 inc	 edx
  00d78	83 c6 08	 add	 esi, 8
  00d7b	03 d8		 add	 ebx, eax
  00d7d	b8 01 00 00 00	 mov	 eax, 1
  00d82	d3 e0		 shl	 eax, cl
  00d84	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00d87	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00d8a	48		 dec	 eax
  00d8b	23 c3		 and	 eax, ebx
  00d8d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00d90	8b c8		 mov	 ecx, eax
  00d92	c1 e9 08	 shr	 ecx, 8
  00d95	0f b6 c9	 movzx	 ecx, cl
  00d98	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00d9b	3b ce		 cmp	 ecx, esi
  00d9d	77 c1		 ja	 SHORT $LL137@inflate
$LN562@inflate:

; 1035 :             }
; 1036 :             if (here.op && (here.op & 0xf0) == 0) {

  00d9f	84 c0		 test	 al, al
  00da1	0f 84 c0 00 00
	00		 je	 $LN119@inflate
  00da7	a8 f0		 test	 al, 240			; 000000f0H
  00da9	0f 85 b8 00 00
	00		 jne	 $LN119@inflate

; 1037 :                 last = here;
; 1038 :                 for (;;) {
; 1039 :                     here = state->lencode[last.val +
; 1040 :                             (BITS(last.bits + last.op) >> last.bits)];

  00daf	8b c8		 mov	 ecx, eax
  00db1	c1 e9 08	 shr	 ecx, 8
  00db4	89 4d d4	 mov	 DWORD PTR tv2288[ebp], ecx
  00db7	0f b6 c9	 movzx	 ecx, cl
  00dba	89 4d e4	 mov	 DWORD PTR tv2289[ebp], ecx
  00dbd	0f b6 c8	 movzx	 ecx, al
  00dc0	03 4d e4	 add	 ecx, DWORD PTR tv2289[ebp]
  00dc3	89 45 dc	 mov	 DWORD PTR _last$[ebp], eax
  00dc6	b8 01 00 00 00	 mov	 eax, 1
  00dcb	d3 e0		 shl	 eax, cl
  00dcd	8b 4d e4	 mov	 ecx, DWORD PTR tv2289[ebp]
  00dd0	48		 dec	 eax
  00dd1	23 c3		 and	 eax, ebx
  00dd3	d3 e8		 shr	 eax, cl
  00dd5	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  00dd8	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00ddb	03 c1		 add	 eax, ecx
  00ddd	8b c8		 mov	 ecx, eax
  00ddf	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00de2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1041 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00de5	0f b6 4d d4	 movzx	 ecx, BYTE PTR tv2288[ebp]
  00de9	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00dec	c1 e8 08	 shr	 eax, 8
  00def	0f b6 c0	 movzx	 eax, al
  00df2	03 c1		 add	 eax, ecx
  00df4	3b c6		 cmp	 eax, esi
  00df6	76 5e		 jbe	 SHORT $LN122@inflate
  00df8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL129@inflate:

; 1042 :                     PULLBYTE();

  00e00	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00e04	0f 84 2b 05 00
	00		 je	 $inf_leave$80535
  00e0a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00e0d	8b ce		 mov	 ecx, esi
  00e0f	d3 e0		 shl	 eax, cl
  00e11	8b 4d dc	 mov	 ecx, DWORD PTR _last$[ebp]
  00e14	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00e17	42		 inc	 edx
  00e18	03 d8		 add	 ebx, eax
  00e1a	0f b6 c5	 movzx	 eax, ch
  00e1d	89 45 e4	 mov	 DWORD PTR tv2387[ebp], eax
  00e20	0f b6 c9	 movzx	 ecx, cl
  00e23	03 c8		 add	 ecx, eax
  00e25	b8 01 00 00 00	 mov	 eax, 1
  00e2a	d3 e0		 shl	 eax, cl
  00e2c	8b 4d e4	 mov	 ecx, DWORD PTR tv2387[ebp]
  00e2f	83 c6 08	 add	 esi, 8
  00e32	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00e35	48		 dec	 eax
  00e36	23 c3		 and	 eax, ebx
  00e38	d3 e8		 shr	 eax, cl
  00e3a	0f b7 4d de	 movzx	 ecx, WORD PTR _last$[ebp+2]
  00e3e	03 c1		 add	 eax, ecx
  00e40	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00e43	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00e46	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00e49	c1 e8 08	 shr	 eax, 8
  00e4c	0f b6 c0	 movzx	 eax, al
  00e4f	03 45 e4	 add	 eax, DWORD PTR tv2387[ebp]
  00e52	3b c6		 cmp	 eax, esi
  00e54	77 aa		 ja	 SHORT $LL129@inflate
$LN122@inflate:

; 1043 :                 }
; 1044 :                 DROPBITS(last.bits);

  00e56	0f b6 4d dd	 movzx	 ecx, BYTE PTR _last$[ebp+1]

; 1045 :                 state->back += last.bits;

  00e5a	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  00e5d	d3 eb		 shr	 ebx, cl
  00e5f	2b f1		 sub	 esi, ecx
  00e61	89 8f c4 1b 00
	00		 mov	 DWORD PTR [edi+7108], ecx
$LN119@inflate:

; 1046 :             }
; 1047 :             DROPBITS(here.bits);

  00e67	8b c8		 mov	 ecx, eax
  00e69	c1 e9 08	 shr	 ecx, 8
  00e6c	0f b6 c9	 movzx	 ecx, cl

; 1048 :             state->back += here.bits;

  00e6f	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
  00e75	d3 eb		 shr	 ebx, cl
  00e77	2b f1		 sub	 esi, ecx
  00e79	89 4d e4	 mov	 DWORD PTR tv2289[ebp], ecx

; 1049 :             state->length = (unsigned)here.val;

  00e7c	8b c8		 mov	 ecx, eax
  00e7e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00e81	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1050 :             if ((int)(here.op) == 0) {

  00e84	84 c0		 test	 al, al
  00e86	75 0b		 jne	 SHORT $LN116@inflate

; 1051 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1052 :                         "inflate:         literal '%c'\n" :
; 1053 :                         "inflate:         literal 0x%02x\n", here.val));
; 1054 :                 state->mode = LIT;

  00e88	c7 07 19 00 00
	00		 mov	 DWORD PTR [edi], 25	; 00000019H

; 1055 :                 break;

  00e8e	e9 44 04 00 00	 jmp	 $LN490@inflate
$LN116@inflate:

; 1056 :             }
; 1057 :             if (here.op & 32) {

  00e93	a8 20		 test	 al, 32			; 00000020H
  00e95	74 15		 je	 SHORT $LN115@inflate

; 1058 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1059 :                 state->back = -1;

  00e97	c7 87 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+7108], -1
$LN263@inflate:

; 1060 :                 state->mode = TYPE;

  00ea1	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH

; 1061 :                 break;

  00ea7	e9 2b 04 00 00	 jmp	 $LN490@inflate
$LN115@inflate:

; 1062 :             }
; 1063 :             if (here.op & 64) {

  00eac	a8 40		 test	 al, 64			; 00000040H
  00eae	74 0f		 je	 SHORT $LN114@inflate

; 1064 :                 strm->msg = (char *)"invalid literal/length code";

  00eb0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00eb3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1065 :                 state->mode = BAD;
; 1066 :                 break;

  00eba	e9 12 04 00 00	 jmp	 $LN782@inflate
$LN114@inflate:

; 1067 :             }
; 1068 :             state->extra = (unsigned)(here.op) & 15;

  00ebf	0f b6 c8	 movzx	 ecx, al
  00ec2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00ec5	89 4f 48	 mov	 DWORD PTR [edi+72], ecx

; 1069 :             state->mode = LENEXT;

  00ec8	c7 07 15 00 00
	00		 mov	 DWORD PTR [edi], 21	; 00000015H
$LN113@inflate:

; 1070 :         case LENEXT:
; 1071 :             if (state->extra) {

  00ece	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00ed1	85 c0		 test	 eax, eax
  00ed3	74 47		 je	 SHORT $LN730@inflate

; 1072 :                 NEEDBITS(state->extra);

  00ed5	3b f0		 cmp	 esi, eax
  00ed7	73 29		 jae	 SHORT $LN110@inflate
  00ed9	8d a4 24 00 00
	00 00		 npad	 7
$LL108@inflate:
  00ee0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ee4	0f 84 4b 04 00
	00		 je	 $inf_leave$80535
  00eea	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00eed	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ef0	8b ce		 mov	 ecx, esi
  00ef2	d3 e0		 shl	 eax, cl
  00ef4	42		 inc	 edx
  00ef5	83 c6 08	 add	 esi, 8
  00ef8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00efb	03 d8		 add	 ebx, eax
  00efd	3b 77 48	 cmp	 esi, DWORD PTR [edi+72]
  00f00	72 de		 jb	 SHORT $LL108@inflate
$LN110@inflate:

; 1073 :                 state->length += BITS(state->extra);

  00f02	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00f05	b8 01 00 00 00	 mov	 eax, 1
  00f0a	d3 e0		 shl	 eax, cl

; 1074 :                 DROPBITS(state->extra);

  00f0c	2b f1		 sub	 esi, ecx
  00f0e	48		 dec	 eax
  00f0f	23 c3		 and	 eax, ebx
  00f11	01 47 40	 add	 DWORD PTR [edi+64], eax
  00f14	d3 eb		 shr	 ebx, cl

; 1075 :                 state->back += state->extra;

  00f16	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
$LN730@inflate:

; 1076 :             }
; 1077 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1078 :             state->was = state->length;

  00f1c	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00f1f	89 8f c8 1b 00
	00		 mov	 DWORD PTR [edi+7112], ecx

; 1079 :             state->mode = DIST;

  00f25	c7 07 16 00 00
	00		 mov	 DWORD PTR [edi], 22	; 00000016H
$LN731@inflate:

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  00f2b	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00f2e	b8 01 00 00 00	 mov	 eax, 1
  00f33	d3 e0		 shl	 eax, cl
  00f35	48		 dec	 eax
  00f36	23 c3		 and	 eax, ebx
  00f38	8b c8		 mov	 ecx, eax
  00f3a	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00f3d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1083 :                 if ((unsigned)(here.bits) <= bits) break;

  00f40	8b c8		 mov	 ecx, eax
  00f42	c1 e9 08	 shr	 ecx, 8
  00f45	0f b6 c9	 movzx	 ecx, cl
  00f48	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00f4b	3b ce		 cmp	 ecx, esi
  00f4d	76 40		 jbe	 SHORT $LN567@inflate
  00f4f	90		 npad	 1
$LL98@inflate:

; 1084 :                 PULLBYTE();

  00f50	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f54	0f 84 db 03 00
	00		 je	 $inf_leave$80535
  00f5a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00f5d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00f60	8b ce		 mov	 ecx, esi
  00f62	d3 e0		 shl	 eax, cl
  00f64	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00f67	42		 inc	 edx
  00f68	83 c6 08	 add	 esi, 8
  00f6b	03 d8		 add	 ebx, eax
  00f6d	b8 01 00 00 00	 mov	 eax, 1
  00f72	d3 e0		 shl	 eax, cl
  00f74	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00f77	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00f7a	48		 dec	 eax
  00f7b	23 c3		 and	 eax, ebx
  00f7d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00f80	8b c8		 mov	 ecx, eax
  00f82	c1 e9 08	 shr	 ecx, 8
  00f85	0f b6 c9	 movzx	 ecx, cl
  00f88	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00f8b	3b ce		 cmp	 ecx, esi
  00f8d	77 c1		 ja	 SHORT $LL98@inflate
$LN567@inflate:

; 1085 :             }
; 1086 :             if ((here.op & 0xf0) == 0) {

  00f8f	a8 f0		 test	 al, 240			; 000000f0H
  00f91	0f 85 b0 00 00
	00		 jne	 $LN80@inflate

; 1087 :                 last = here;
; 1088 :                 for (;;) {
; 1089 :                     here = state->distcode[last.val +
; 1090 :                             (BITS(last.bits + last.op) >> last.bits)];

  00f97	8b c8		 mov	 ecx, eax
  00f99	c1 e9 08	 shr	 ecx, 8
  00f9c	89 4d d4	 mov	 DWORD PTR tv2288[ebp], ecx
  00f9f	0f b6 c9	 movzx	 ecx, cl
  00fa2	89 4d e4	 mov	 DWORD PTR tv2289[ebp], ecx
  00fa5	0f b6 c8	 movzx	 ecx, al
  00fa8	03 4d e4	 add	 ecx, DWORD PTR tv2289[ebp]
  00fab	89 45 dc	 mov	 DWORD PTR _last$[ebp], eax
  00fae	b8 01 00 00 00	 mov	 eax, 1
  00fb3	d3 e0		 shl	 eax, cl
  00fb5	8b 4d e4	 mov	 ecx, DWORD PTR tv2289[ebp]
  00fb8	48		 dec	 eax
  00fb9	23 c3		 and	 eax, ebx
  00fbb	d3 e8		 shr	 eax, cl
  00fbd	8b 4d f4	 mov	 ecx, DWORD PTR _here$[ebp]
  00fc0	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00fc3	03 c1		 add	 eax, ecx
  00fc5	8b c8		 mov	 ecx, eax
  00fc7	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00fca	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1091 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fcd	0f b6 4d d4	 movzx	 ecx, BYTE PTR tv2288[ebp]
  00fd1	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  00fd4	c1 e8 08	 shr	 eax, 8
  00fd7	0f b6 c0	 movzx	 eax, al
  00fda	03 c1		 add	 eax, ecx
  00fdc	3b c6		 cmp	 eax, esi
  00fde	76 56		 jbe	 SHORT $LN83@inflate
$LL90@inflate:

; 1092 :                     PULLBYTE();

  00fe0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00fe4	0f 84 4b 03 00
	00		 je	 $inf_leave$80535
  00fea	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00fed	8b ce		 mov	 ecx, esi
  00fef	d3 e0		 shl	 eax, cl
  00ff1	8b 4d dc	 mov	 ecx, DWORD PTR _last$[ebp]
  00ff4	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ff7	42		 inc	 edx
  00ff8	03 d8		 add	 ebx, eax
  00ffa	0f b6 c5	 movzx	 eax, ch
  00ffd	89 45 e4	 mov	 DWORD PTR tv2387[ebp], eax
  01000	0f b6 c9	 movzx	 ecx, cl
  01003	03 c8		 add	 ecx, eax
  01005	b8 01 00 00 00	 mov	 eax, 1
  0100a	d3 e0		 shl	 eax, cl
  0100c	8b 4d e4	 mov	 ecx, DWORD PTR tv2387[ebp]
  0100f	83 c6 08	 add	 esi, 8
  01012	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  01015	48		 dec	 eax
  01016	23 c3		 and	 eax, ebx
  01018	d3 e8		 shr	 eax, cl
  0101a	0f b7 4d de	 movzx	 ecx, WORD PTR _last$[ebp+2]
  0101e	03 c1		 add	 eax, ecx
  01020	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  01023	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01026	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax
  01029	c1 e8 08	 shr	 eax, 8
  0102c	0f b6 c0	 movzx	 eax, al
  0102f	03 45 e4	 add	 eax, DWORD PTR tv2387[ebp]
  01032	3b c6		 cmp	 eax, esi
  01034	77 aa		 ja	 SHORT $LL90@inflate
$LN83@inflate:

; 1093 :                 }
; 1094 :                 DROPBITS(last.bits);

  01036	0f b6 4d dd	 movzx	 ecx, BYTE PTR _last$[ebp+1]

; 1095 :                 state->back += last.bits;

  0103a	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  0103d	d3 eb		 shr	 ebx, cl
  0103f	2b f1		 sub	 esi, ecx
  01041	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
$LN80@inflate:

; 1096 :             }
; 1097 :             DROPBITS(here.bits);

  01047	8b c8		 mov	 ecx, eax
  01049	c1 e9 08	 shr	 ecx, 8
  0104c	0f b6 c9	 movzx	 ecx, cl

; 1098 :             state->back += here.bits;

  0104f	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
  01055	d3 eb		 shr	 ebx, cl
  01057	2b f1		 sub	 esi, ecx
  01059	89 4d e4	 mov	 DWORD PTR tv2289[ebp], ecx

; 1099 :             if (here.op & 64) {

  0105c	a8 40		 test	 al, 64			; 00000040H
  0105e	74 0f		 je	 SHORT $LN77@inflate

; 1100 :                 strm->msg = (char *)"invalid distance code";

  01060	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01063	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1101 :                 state->mode = BAD;
; 1102 :                 break;

  0106a	e9 62 02 00 00	 jmp	 $LN782@inflate
$LN77@inflate:

; 1103 :             }
; 1104 :             state->offset = (unsigned)here.val;

  0106f	8b c8		 mov	 ecx, eax

; 1105 :             state->extra = (unsigned)(here.op) & 15;

  01071	0f b6 c0	 movzx	 eax, al
  01074	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01077	83 e0 0f	 and	 eax, 15			; 0000000fH
  0107a	89 4f 44	 mov	 DWORD PTR [edi+68], ecx
  0107d	89 47 48	 mov	 DWORD PTR [edi+72], eax

; 1106 :             state->mode = DISTEXT;

  01080	c7 07 17 00 00
	00		 mov	 DWORD PTR [edi], 23	; 00000017H
$LN76@inflate:

; 1107 :         case DISTEXT:
; 1108 :             if (state->extra) {

  01086	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  01089	85 c0		 test	 eax, eax
  0108b	74 40		 je	 SHORT $LN75@inflate

; 1109 :                 NEEDBITS(state->extra);

  0108d	3b f0		 cmp	 esi, eax
  0108f	73 22		 jae	 SHORT $LN73@inflate
$LL71@inflate:
  01091	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  01095	0f 84 9a 02 00
	00		 je	 $inf_leave$80535
  0109b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0109e	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  010a1	8b ce		 mov	 ecx, esi
  010a3	d3 e0		 shl	 eax, cl
  010a5	42		 inc	 edx
  010a6	83 c6 08	 add	 esi, 8
  010a9	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  010ac	03 d8		 add	 ebx, eax
  010ae	3b 77 48	 cmp	 esi, DWORD PTR [edi+72]
  010b1	72 de		 jb	 SHORT $LL71@inflate
$LN73@inflate:

; 1110 :                 state->offset += BITS(state->extra);

  010b3	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  010b6	b8 01 00 00 00	 mov	 eax, 1
  010bb	d3 e0		 shl	 eax, cl

; 1111 :                 DROPBITS(state->extra);

  010bd	2b f1		 sub	 esi, ecx
  010bf	48		 dec	 eax
  010c0	23 c3		 and	 eax, ebx
  010c2	01 47 44	 add	 DWORD PTR [edi+68], eax
  010c5	d3 eb		 shr	 ebx, cl

; 1112 :                 state->back += state->extra;

  010c7	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
$LN75@inflate:

; 1113 :             }
; 1114 : #ifdef INFLATE_STRICT
; 1115 :             if (state->offset > state->dmax) {
; 1116 :                 strm->msg = (char *)"invalid distance too far back";
; 1117 :                 state->mode = BAD;
; 1118 :                 break;
; 1119 :             }
; 1120 : #endif
; 1121 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1122 :             state->mode = MATCH;

  010cd	c7 07 18 00 00
	00		 mov	 DWORD PTR [edi], 24	; 00000018H
$LN734@inflate:

; 1123 :         case MATCH:
; 1124 :             if (left == 0) goto inf_leave;

  010d3	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  010d7	0f 84 58 02 00
	00		 je	 $inf_leave$80535

; 1125 :             copy = out - left;

  010dd	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  010e0	2b 4d f0	 sub	 ecx, DWORD PTR _left$[ebp]

; 1126 :             if (state->offset > copy) {         /* copy from window */

  010e3	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  010e6	3b c1		 cmp	 eax, ecx
  010e8	76 54		 jbe	 SHORT $LN60@inflate

; 1127 :                 copy = state->offset - copy;

  010ea	2b c1		 sub	 eax, ecx
  010ec	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1128 :                 if (copy > state->whave) {

  010ef	3b 47 2c	 cmp	 eax, DWORD PTR [edi+44]
  010f2	76 18		 jbe	 SHORT $LN58@inflate

; 1129 :                     if (state->sane) {

  010f4	83 bf c0 1b 00
	00 00		 cmp	 DWORD PTR [edi+7104], 0
  010fb	74 0f		 je	 SHORT $LN58@inflate

; 1130 :                         strm->msg = (char *)"invalid distance too far back";

  010fd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01100	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1131 :                         state->mode = BAD;
; 1132 :                         break;

  01107	e9 c5 01 00 00	 jmp	 $LN782@inflate
$LN58@inflate:

; 1133 :                     }
; 1134 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1135 :                     Trace((stderr, "inflate.c too far\n"));
; 1136 :                     copy -= state->whave;
; 1137 :                     if (copy > state->length) copy = state->length;
; 1138 :                     if (copy > left) copy = left;
; 1139 :                     left -= copy;
; 1140 :                     state->length -= copy;
; 1141 :                     do {
; 1142 :                         *put++ = 0;
; 1143 :                     } while (--copy);
; 1144 :                     if (state->length == 0) state->mode = LEN;
; 1145 :                     break;
; 1146 : #endif
; 1147 :                 }
; 1148 :                 if (copy > state->wnext) {

  0110c	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  0110f	3b c1		 cmp	 eax, ecx
  01111	76 0f		 jbe	 SHORT $LN57@inflate

; 1149 :                     copy -= state->wnext;

  01113	2b c1		 sub	 eax, ecx

; 1150 :                     from = state->window + (state->wsize - copy);

  01115	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  01118	03 4f 28	 add	 ecx, DWORD PTR [edi+40]
  0111b	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
  0111e	2b c8		 sub	 ecx, eax

; 1151 :                 }
; 1152 :                 else

  01120	eb 0b		 jmp	 SHORT $LN780@inflate
$LN57@inflate:

; 1153 :                     from = state->window + (state->wnext - copy);

  01122	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  01125	2b c8		 sub	 ecx, eax
  01127	03 4f 30	 add	 ecx, DWORD PTR [edi+48]
  0112a	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
$LN780@inflate:
  0112d	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx

; 1154 :                 if (copy > state->length) copy = state->length;

  01130	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  01133	89 4d dc	 mov	 DWORD PTR tv2131[ebp], ecx
  01136	3b c1		 cmp	 eax, ecx
  01138	76 15		 jbe	 SHORT $LN54@inflate
  0113a	8b c1		 mov	 eax, ecx

; 1155 :             }
; 1156 :             else {                              /* copy from output */

  0113c	eb 0e		 jmp	 SHORT $LN781@inflate
$LN60@inflate:

; 1157 :                 from = put - state->offset;

  0113e	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  01141	2b c8		 sub	 ecx, eax

; 1158 :                 copy = state->length;

  01143	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  01146	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx
  01149	89 45 dc	 mov	 DWORD PTR tv2131[ebp], eax
$LN781@inflate:
  0114c	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN54@inflate:

; 1159 :             }
; 1160 :             if (copy > left) copy = left;

  0114f	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  01152	3b c1		 cmp	 eax, ecx
  01154	76 05		 jbe	 SHORT $LN53@inflate
  01156	8b c1		 mov	 eax, ecx
  01158	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax
$LN53@inflate:

; 1161 :             left -= copy;

  0115b	2b c8		 sub	 ecx, eax
  0115d	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx

; 1162 :             state->length -= copy;

  01160	8b 4d dc	 mov	 ecx, DWORD PTR tv2131[ebp]
  01163	2b c8		 sub	 ecx, eax

; 1165 :             } while (--copy);

  01165	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  01168	89 4f 40	 mov	 DWORD PTR [edi+64], ecx
  0116b	8b 4d d4	 mov	 ecx, DWORD PTR _from$[ebp]
  0116e	2b 4d e8	 sub	 ecx, DWORD PTR _put$[ebp]
  01171	89 4d d4	 mov	 DWORD PTR tv3076[ebp], ecx
  01174	eb 03		 jmp	 SHORT $LN52@inflate
$LL735@inflate:
  01176	8b 4d d4	 mov	 ecx, DWORD PTR tv3076[ebp]
$LN52@inflate:

; 1163 :             do {
; 1164 :                 *put++ = *from++;

  01179	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  0117c	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  0117f	88 08		 mov	 BYTE PTR [eax], cl
  01181	40		 inc	 eax

; 1165 :             } while (--copy);

  01182	ff 4d f4	 dec	 DWORD PTR _copy$[ebp]
  01185	89 45 e8	 mov	 DWORD PTR _put$[ebp], eax
  01188	75 ec		 jne	 SHORT $LL735@inflate

; 1166 :             if (state->length == 0) state->mode = LEN;

  0118a	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  0118e	0f 85 43 01 00
	00		 jne	 $LN490@inflate
  01194	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H

; 1167 :             break;

  0119a	e9 38 01 00 00	 jmp	 $LN490@inflate
$LN48@inflate:

; 1168 :         case LIT:
; 1169 :             if (left == 0) goto inf_leave;

  0119f	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  011a3	0f 84 8c 01 00
	00		 je	 $inf_leave$80535

; 1170 :             *put++ = (unsigned char)(state->length);

  011a9	8b 45 e8	 mov	 eax, DWORD PTR _put$[ebp]
  011ac	8a 4f 40	 mov	 cl, BYTE PTR [edi+64]
  011af	88 08		 mov	 BYTE PTR [eax], cl
  011b1	40		 inc	 eax

; 1171 :             left--;

  011b2	ff 4d f0	 dec	 DWORD PTR _left$[ebp]
  011b5	89 45 e8	 mov	 DWORD PTR _put$[ebp], eax

; 1172 :             state->mode = LEN;

  011b8	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H

; 1173 :             break;

  011be	e9 14 01 00 00	 jmp	 $LN490@inflate
$LN46@inflate:

; 1174 :         case CHECK:
; 1175 :             if (state->wrap) {

  011c3	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  011c7	0f 84 ac 00 00
	00		 je	 $LN31@inflate

; 1176 :                 NEEDBITS(32);

  011cd	83 fe 20	 cmp	 esi, 32			; 00000020H
  011d0	73 22		 jae	 SHORT $LN43@inflate
$LL41@inflate:
  011d2	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  011d6	0f 84 59 01 00
	00		 je	 $inf_leave$80535
  011dc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011df	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  011e2	8b ce		 mov	 ecx, esi
  011e4	d3 e0		 shl	 eax, cl
  011e6	42		 inc	 edx
  011e7	83 c6 08	 add	 esi, 8
  011ea	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  011ed	03 d8		 add	 ebx, eax
  011ef	83 fe 20	 cmp	 esi, 32			; 00000020H
  011f2	72 de		 jb	 SHORT $LL41@inflate
$LN43@inflate:

; 1177 :                 out -= left;

  011f4	8b 45 e0	 mov	 eax, DWORD PTR _out$[ebp]
  011f7	2b 45 f0	 sub	 eax, DWORD PTR _left$[ebp]

; 1178 :                 strm->total_out += out;

  011fa	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  011fd	01 41 14	 add	 DWORD PTR [ecx+20], eax

; 1179 :                 state->total += out;

  01200	01 47 1c	 add	 DWORD PTR [edi+28], eax
  01203	89 45 e0	 mov	 DWORD PTR _out$[ebp], eax

; 1180 :                 if (out)

  01206	85 c0		 test	 eax, eax
  01208	74 29		 je	 SHORT $LN35@inflate

; 1181 :                     strm->adler = state->check =
; 1182 :                         UPDATE(state->check, put - out, out);

  0120a	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  0120d	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  01210	50		 push	 eax
  01211	2b c8		 sub	 ecx, eax
  01213	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  01217	51		 push	 ecx
  01218	52		 push	 edx
  01219	74 07		 je	 SHORT $LN504@inflate
  0121b	e8 00 00 00 00	 call	 _crc32@12
  01220	eb 05		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  01222	e8 00 00 00 00	 call	 _adler32@12
$LN505@inflate:
  01227	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0122a	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0122d	89 47 18	 mov	 DWORD PTR [edi+24], eax
  01230	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN35@inflate:

; 1183 :                 out = left;
; 1184 :                 if ((
; 1185 : #ifdef GUNZIP
; 1186 :                      state->flags ? hold :
; 1187 : #endif
; 1188 :                      ZSWAP32(hold)) != state->check) {

  01233	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  01237	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
  0123a	89 45 e0	 mov	 DWORD PTR _out$[ebp], eax
  0123d	8b c3		 mov	 eax, ebx
  0123f	75 23		 jne	 SHORT $LN507@inflate
  01241	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01246	8b cb		 mov	 ecx, ebx
  01248	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0124b	03 c1		 add	 eax, ecx
  0124d	8b cb		 mov	 ecx, ebx
  0124f	c1 e9 08	 shr	 ecx, 8
  01252	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01258	c1 e0 08	 shl	 eax, 8
  0125b	03 c1		 add	 eax, ecx
  0125d	8b cb		 mov	 ecx, ebx
  0125f	c1 e9 18	 shr	 ecx, 24			; 00000018H
  01262	03 c1		 add	 eax, ecx
$LN507@inflate:
  01264	3b 47 18	 cmp	 eax, DWORD PTR [edi+24]
  01267	74 0c		 je	 SHORT $LN33@inflate

; 1189 :                     strm->msg = (char *)"incorrect data check";

  01269	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0126c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1190 :                     state->mode = BAD;
; 1191 :                     break;

  01273	eb 5c		 jmp	 SHORT $LN782@inflate
$LN33@inflate:

; 1192 :                 }
; 1193 :                 INITBITS();

  01275	33 db		 xor	 ebx, ebx
  01277	33 f6		 xor	 esi, esi
$LN31@inflate:

; 1194 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1195 :             }
; 1196 : #ifdef GUNZIP
; 1197 :             state->mode = LENGTH;

  01279	c7 07 1b 00 00
	00		 mov	 DWORD PTR [edi], 27	; 0000001bH
$LN738@inflate:

; 1198 :         case LENGTH:
; 1199 :             if (state->wrap && state->flags) {

  0127f	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  01283	0f 84 96 00 00
	00		 je	 $LN16@inflate
  01289	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0128d	0f 84 8c 00 00
	00		 je	 $LN16@inflate

; 1200 :                 NEEDBITS(32);

  01293	83 fe 20	 cmp	 esi, 32			; 00000020H
  01296	73 2a		 jae	 SHORT $LN27@inflate
  01298	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL25@inflate:
  012a0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  012a4	0f 84 8b 00 00
	00		 je	 $inf_leave$80535
  012aa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  012ad	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  012b0	8b ce		 mov	 ecx, esi
  012b2	d3 e0		 shl	 eax, cl
  012b4	42		 inc	 edx
  012b5	83 c6 08	 add	 esi, 8
  012b8	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  012bb	03 d8		 add	 ebx, eax
  012bd	83 fe 20	 cmp	 esi, 32			; 00000020H
  012c0	72 de		 jb	 SHORT $LL25@inflate
$LN27@inflate:

; 1201 :                 if (hold != (state->total & 0xffffffffUL)) {

  012c2	3b 5f 1c	 cmp	 ebx, DWORD PTR [edi+28]
  012c5	74 54		 je	 SHORT $LN18@inflate

; 1202 :                     strm->msg = (char *)"incorrect length check";

  012c7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  012ca	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
$LN782@inflate:

; 1203 :                     state->mode = BAD;

  012d1	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH
$LN490@inflate:

; 636  :     out = left;
; 637  :     ret = Z_OK;
; 638  :     for (;;)
; 639  :         switch (state->mode) {

  012d7	8b 07		 mov	 eax, DWORD PTR [edi]
  012d9	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  012dc	0f 86 96 ed ff
	ff		 jbe	 $LL493@inflate
$LN12@inflate:

; 1216 :             goto inf_leave;
; 1217 :         case MEM:
; 1218 :             return Z_MEM_ERROR;
; 1219 :         case SYNC:
; 1220 :         default:
; 1221 :             return Z_STREAM_ERROR;

  012e2	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN776@inflate:
  012e7	5e		 pop	 esi
  012e8	5b		 pop	 ebx
  012e9	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  012ea	8b e5		 mov	 esp, ebp
  012ec	5d		 pop	 ebp
  012ed	c2 08 00	 ret	 8
$LN579@inflate:

; 821  :                 RESTORE();

  012f0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  012f3	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  012f6	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  012f9	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  012fc	89 10		 mov	 DWORD PTR [eax], edx
  012fe	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  01301	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01304	89 50 04	 mov	 DWORD PTR [eax+4], edx
  01307	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  0130a	5e		 pop	 esi
  0130b	89 5f 38	 mov	 DWORD PTR [edi+56], ebx
  0130e	5b		 pop	 ebx

; 822  :                 return Z_NEED_DICT;

  0130f	b8 02 00 00 00	 mov	 eax, 2
  01314	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  01315	8b e5		 mov	 esp, ebp
  01317	5d		 pop	 ebp
  01318	c2 08 00	 ret	 8
$LN18@inflate:

; 1204 :                     break;
; 1205 :                 }
; 1206 :                 INITBITS();

  0131b	33 db		 xor	 ebx, ebx
  0131d	33 f6		 xor	 esi, esi
$LN16@inflate:

; 1207 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1208 :             }
; 1209 : #endif
; 1210 :             state->mode = DONE;

  0131f	c7 07 1c 00 00
	00		 mov	 DWORD PTR [edi], 28	; 0000001cH
$LN743@inflate:

; 1211 :         case DONE:
; 1212 :             ret = Z_STREAM_END;

  01325	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1213 :             goto inf_leave;

  0132c	eb 07		 jmp	 SHORT $inf_leave$80535
$LN14@inflate:

; 1214 :         case BAD:
; 1215 :             ret = Z_DATA_ERROR;

  0132e	c7 45 d8 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH
$inf_leave$80535:

; 1222 :         }
; 1223 : 
; 1224 :     /*
; 1225 :        Return from inflate(), updating the total counts and the check value.
; 1226 :        If there was no progress during the inflate() call, return a buffer
; 1227 :        error.  Call updatewindow() to create and/or update the window state.
; 1228 :        Note: a memory error from inflate() is non-recoverable.
; 1229 :      */
; 1230 :   inf_leave:
; 1231 :     RESTORE();

  01335	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01338	8b 4d e8	 mov	 ecx, DWORD PTR _put$[ebp]
  0133b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0133e	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  01341	89 10		 mov	 DWORD PTR [eax], edx
  01343	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  01346	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01349	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1232 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1233 :             (state->mode < CHECK || flush != Z_FINISH)))

  0134c	83 7f 28 00	 cmp	 DWORD PTR [edi+40], 0
  01350	89 5f 38	 mov	 DWORD PTR [edi+56], ebx
  01353	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  01356	75 1a		 jne	 SHORT $LN6@inflate
  01358	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  0135b	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0135e	74 3f		 je	 SHORT $LN5@inflate
  01360	8b 07		 mov	 eax, DWORD PTR [edi]
  01362	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  01365	7d 38		 jge	 SHORT $LN5@inflate
  01367	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0136a	7c 06		 jl	 SHORT $LN6@inflate
  0136c	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01370	74 2d		 je	 SHORT $LN5@inflate
$LN6@inflate:

; 1234 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01372	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01375	8b 4d e0	 mov	 ecx, DWORD PTR _out$[ebp]
  01378	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0137b	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0137e	52		 push	 edx
  0137f	e8 00 00 00 00	 call	 _updatewindow
  01384	83 c4 04	 add	 esp, 4
  01387	85 c0		 test	 eax, eax
  01389	74 14		 je	 SHORT $LN5@inflate

; 1235 :             state->mode = MEM;

  0138b	c7 07 1e 00 00
	00		 mov	 DWORD PTR [edi], 30	; 0000001eH
$LN13@inflate:
  01391	5e		 pop	 esi
  01392	5b		 pop	 ebx

; 1236 :             return Z_MEM_ERROR;

  01393	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01398	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  01399	8b e5		 mov	 esp, ebp
  0139b	5d		 pop	 ebp
  0139c	c2 08 00	 ret	 8
$LN5@inflate:

; 1237 :         }
; 1238 :     in -= strm->avail_in;

  0139f	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  013a2	8b 45 d0	 mov	 eax, DWORD PTR _in$[ebp]
  013a5	2b 46 04	 sub	 eax, DWORD PTR [esi+4]

; 1239 :     out -= strm->avail_out;

  013a8	8b 5d e0	 mov	 ebx, DWORD PTR _out$[ebp]
  013ab	2b 5e 10	 sub	 ebx, DWORD PTR [esi+16]

; 1240 :     strm->total_in += in;

  013ae	01 46 08	 add	 DWORD PTR [esi+8], eax

; 1241 :     strm->total_out += out;

  013b1	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 1242 :     state->total += out;

  013b4	01 5f 1c	 add	 DWORD PTR [edi+28], ebx

; 1243 :     if (state->wrap && out)

  013b7	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  013bb	89 45 d0	 mov	 DWORD PTR _in$[ebp], eax
  013be	74 31		 je	 SHORT $LN4@inflate
  013c0	85 db		 test	 ebx, ebx
  013c2	74 2d		 je	 SHORT $LN4@inflate

; 1244 :         strm->adler = state->check =
; 1245 :             UPDATE(state->check, strm->next_out - out, out);

  013c4	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  013c8	53		 push	 ebx
  013c9	74 11		 je	 SHORT $LN508@inflate
  013cb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  013ce	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  013d1	2b c3		 sub	 eax, ebx
  013d3	50		 push	 eax
  013d4	51		 push	 ecx
  013d5	e8 00 00 00 00	 call	 _crc32@12
  013da	eb 0f		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  013dc	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  013df	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  013e2	2b d3		 sub	 edx, ebx
  013e4	52		 push	 edx
  013e5	50		 push	 eax
  013e6	e8 00 00 00 00	 call	 _adler32@12
$LN509@inflate:
  013eb	89 47 18	 mov	 DWORD PTR [edi+24], eax
  013ee	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN4@inflate:

; 1246 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1247 :                       (state->mode == TYPE ? 128 : 0) +
; 1248 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  013f1	8b 07		 mov	 eax, DWORD PTR [edi]
  013f3	83 f8 13	 cmp	 eax, 19			; 00000013H
  013f6	74 0c		 je	 SHORT $LN510@inflate
  013f8	c7 45 08 00 00
	00 00		 mov	 DWORD PTR tv1325[ebp], 0
  013ff	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  01402	75 07		 jne	 SHORT $LN511@inflate
$LN510@inflate:
  01404	c7 45 08 00 01
	00 00		 mov	 DWORD PTR tv1325[ebp], 256 ; 00000100H
$LN511@inflate:
  0140b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0140e	f7 d9		 neg	 ecx
  01410	1b c9		 sbb	 ecx, ecx
  01412	33 d2		 xor	 edx, edx
  01414	83 e1 40	 and	 ecx, 64			; 00000040H
  01417	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0141a	0f 95 c2	 setne	 dl
  0141d	03 4d 08	 add	 ecx, DWORD PTR tv1325[ebp]
  01420	4a		 dec	 edx
  01421	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  01427	03 d1		 add	 edx, ecx
  01429	03 57 3c	 add	 edx, DWORD PTR [edi+60]

; 1249 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0142c	83 7d d0 00	 cmp	 DWORD PTR _in$[ebp], 0
  01430	89 56 2c	 mov	 DWORD PTR [esi+44], edx
  01433	75 04		 jne	 SHORT $LN1@inflate
  01435	85 db		 test	 ebx, ebx
  01437	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01439	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0143d	75 19		 jne	 SHORT $LN701@inflate
$LN2@inflate:
  0143f	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
  01442	85 c0		 test	 eax, eax
  01444	0f 85 9d fe ff
	ff		 jne	 $LN776@inflate

; 1250 :         ret = Z_BUF_ERROR;

  0144a	5e		 pop	 esi
  0144b	5b		 pop	 ebx
  0144c	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  01451	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  01452	8b e5		 mov	 esp, ebp
  01454	5d		 pop	 ebp
  01455	c2 08 00	 ret	 8
$LN701@inflate:

; 1250 :         ret = Z_BUF_ERROR;

  01458	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
  0145b	5e		 pop	 esi
  0145c	5b		 pop	 ebx
  0145d	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  0145e	8b e5		 mov	 esp, ebp
  01460	5d		 pop	 ebp
  01461	c2 08 00	 ret	 8
$LN498@inflate:

; 630  :         return Z_STREAM_ERROR;

  01464	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01469	5f		 pop	 edi

; 1251 :     return ret;
; 1252 : }

  0146a	8b e5		 mov	 esp, ebp
  0146c	5d		 pop	 ebp
  0146d	c2 08 00	 ret	 8
$LN783@inflate:
  01470	00 00 00 00	 DD	 $LN489@inflate
  01474	00 00 00 00	 DD	 $LN457@inflate
  01478	00 00 00 00	 DD	 $LN437@inflate
  0147c	00 00 00 00	 DD	 $LN419@inflate
  01480	00 00 00 00	 DD	 $LN707@inflate
  01484	00 00 00 00	 DD	 $LN709@inflate
  01488	00 00 00 00	 DD	 $LN710@inflate
  0148c	00 00 00 00	 DD	 $LN714@inflate
  01490	00 00 00 00	 DD	 $LN718@inflate
  01494	00 00 00 00	 DD	 $LN333@inflate
  01498	00 00 00 00	 DD	 $LN720@inflate
  0149c	00 00 00 00	 DD	 $LN316@inflate
  014a0	00 00 00 00	 DD	 $LN315@inflate
  014a4	00 00 00 00	 DD	 $LN282@inflate
  014a8	00 00 00 00	 DD	 $LN266@inflate
  014ac	00 00 00 00	 DD	 $LN264@inflate
  014b0	00 00 00 00	 DD	 $LN258@inflate
  014b4	00 00 00 00	 DD	 $LN724@inflate
  014b8	00 00 00 00	 DD	 $LN528@inflate
  014bc	00 00 00 00	 DD	 $LN148@inflate
  014c0	00 00 00 00	 DD	 $LN146@inflate
  014c4	00 00 00 00	 DD	 $LN113@inflate
  014c8	00 00 00 00	 DD	 $LN731@inflate
  014cc	00 00 00 00	 DD	 $LN76@inflate
  014d0	00 00 00 00	 DD	 $LN734@inflate
  014d4	00 00 00 00	 DD	 $LN48@inflate
  014d8	00 00 00 00	 DD	 $LN46@inflate
  014dc	00 00 00 00	 DD	 $LN738@inflate
  014e0	00 00 00 00	 DD	 $LN743@inflate
  014e4	00 00 00 00	 DD	 $LN14@inflate
  014e8	00 00 00 00	 DD	 $LN13@inflate
$LN784@inflate:
  014ec	00 00 00 00	 DD	 $LN294@inflate
  014f0	00 00 00 00	 DD	 $LN293@inflate
  014f4	00 00 00 00	 DD	 $LN288@inflate
  014f8	00 00 00 00	 DD	 $LN287@inflate
_inflate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	3b ca		 cmp	 ecx, edx
  0000a	74 1a		 je	 SHORT $LN1@inflateRes@2
  0000c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0000f	3b c2		 cmp	 eax, edx
  00011	74 13		 je	 SHORT $LN1@inflateRes@2

; 135  :     state = (struct inflate_state FAR *)strm->state;
; 136  :     state->wsize = 0;
; 137  :     state->whave = 0;
; 138  :     state->wnext = 0;
; 139  :     return inflateResetKeep(strm);

  00013	51		 push	 ecx
  00014	89 50 28	 mov	 DWORD PTR [eax+40], edx
  00017	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  0001a	89 50 30	 mov	 DWORD PTR [eax+48], edx
  0001d	e8 00 00 00 00	 call	 _inflateResetKeep@4

; 140  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN1@inflateRes@2:

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00026	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 140  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_inflateReset@4 ENDP
PUBLIC	_inflateSync@4
; Function compile flags: /Ogtp
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_out$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 d2 00 00
	00		 je	 $LN6@inflateSyn@2
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 c7 00 00
	00		 je	 $LN6@inflateSyn@2

; 1387 :     state = (struct inflate_state FAR *)strm->state;
; 1388 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 11		 jne	 SHORT $LN5@inflateSyn@2
  00021	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00025	73 0b		 jae	 SHORT $LN5@inflateSyn@2
  00027	5f		 pop	 edi
  00028	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0002d	5b		 pop	 ebx

; 1418 : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN5@inflateSyn@2:

; 1389 : 
; 1390 :     /* if first time, start search in bit buffer */
; 1391 :     if (state->mode != SYNC) {

  00032	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00035	56		 push	 esi
  00036	74 57		 je	 SHORT $LN4@inflateSyn@2

; 1392 :         state->mode = SYNC;
; 1393 :         state->hold <<= state->bits & 7;

  00038	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0003b	8b c8		 mov	 ecx, eax
  0003d	83 e1 07	 and	 ecx, 7
  00040	d3 67 38	 shl	 DWORD PTR [edi+56], cl

; 1394 :         state->bits -= state->bits & 7;

  00043	2b c1		 sub	 eax, ecx

; 1395 :         len = 0;

  00045	33 c9		 xor	 ecx, ecx
  00047	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  0004d	89 47 3c	 mov	 DWORD PTR [edi+60], eax

; 1396 :         while (state->bits >= 8) {

  00050	83 f8 08	 cmp	 eax, 8
  00053	72 24		 jb	 SHORT $LN2@inflateSyn@2
  00055	8b 77 38	 mov	 esi, DWORD PTR [edi+56]
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@inflateSyn@2:

; 1397 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 57 38	 mov	 dl, BYTE PTR [edi+56]

; 1398 :             state->hold >>= 8;
; 1399 :             state->bits -= 8;

  00063	83 e8 08	 sub	 eax, 8
  00066	88 54 0d 08	 mov	 BYTE PTR _buf$[ebp+ecx], dl
  0006a	c1 ee 08	 shr	 esi, 8
  0006d	41		 inc	 ecx
  0006e	89 77 38	 mov	 DWORD PTR [edi+56], esi
  00071	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  00074	83 f8 08	 cmp	 eax, 8
  00077	73 e7		 jae	 SHORT $LL3@inflateSyn@2
$LN2@inflateSyn@2:

; 1400 :         }
; 1401 :         state->have = 0;

  00079	8d 47 68	 lea	 eax, DWORD PTR [edi+104]

; 1402 :         syncsearch(&(state->have), buf, len);

  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	8d 75 08	 lea	 esi, DWORD PTR _buf$[ebp]
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00087	e8 00 00 00 00	 call	 _syncsearch
  0008c	83 c4 08	 add	 esp, 8
$LN4@inflateSyn@2:

; 1403 :     }
; 1404 : 
; 1405 :     /* search available input */
; 1406 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0008f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00092	8b 33		 mov	 esi, DWORD PTR [ebx]
  00094	8d 47 68	 lea	 eax, DWORD PTR [edi+104]
  00097	51		 push	 ecx
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _syncsearch

; 1407 :     strm->avail_in -= len;
; 1408 :     strm->next_in += len;
; 1409 :     strm->total_in += len;

  0009e	01 43 08	 add	 DWORD PTR [ebx+8], eax
  000a1	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a4	01 03		 add	 DWORD PTR [ebx], eax
  000a6	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  000a9	83 c4 08	 add	 esp, 8

; 1410 : 
; 1411 :     /* return no joy or set up to restart inflate() on a new block */
; 1412 :     if (state->have != 4) return Z_DATA_ERROR;

  000ac	83 7f 68 04	 cmp	 DWORD PTR [edi+104], 4
  000b0	74 0c		 je	 SHORT $LN1@inflateSyn@2
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi
  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	5b		 pop	 ebx

; 1418 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN1@inflateSyn@2:

; 1413 :     in = strm->total_in;  out = strm->total_out;

  000be	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]

; 1414 :     inflateReset(strm);

  000c1	53		 push	 ebx
  000c2	89 55 08	 mov	 DWORD PTR _out$[ebp], edx
  000c5	e8 00 00 00 00	 call	 _inflateReset@4

; 1415 :     strm->total_in = in;  strm->total_out = out;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]
  000cd	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  000d0	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  000d3	5e		 pop	 esi

; 1416 :     state->mode = TYPE;

  000d4	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000da	5f		 pop	 edi

; 1417 :     return Z_OK;

  000db	33 c0		 xor	 eax, eax
  000dd	5b		 pop	 ebx

; 1418 : }

  000de	5d		 pop	 ebp
  000df	c2 04 00	 ret	 4
$LN6@inflateSyn@2:
  000e2	5f		 pop	 edi

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e3	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e8	5b		 pop	 ebx

; 1418 : }

  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset2@8
; Function compile flags: /Ogtp
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 c9		 test	 ecx, ecx
  00009	74 74		 je	 SHORT $LN7@inflateRes@3
  0000b	8b 79 1c	 mov	 edi, DWORD PTR [ecx+28]
  0000e	85 ff		 test	 edi, edi
  00010	74 6d		 je	 SHORT $LN7@inflateRes@3

; 151  :     state = (struct inflate_state FAR *)strm->state;
; 152  : 
; 153  :     /* extract wrap request from windowBits parameter */
; 154  :     if (windowBits < 0) {

  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN6@inflateRes@3

; 155  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 156  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 157  :     }
; 158  :     else {

  0001f	eb 0e		 jmp	 SHORT $LN4@inflateRes@3
$LN6@inflateRes@3:

; 159  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 160  : #ifdef GUNZIP
; 161  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN4@inflateRes@3

; 162  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN4@inflateRes@3:

; 163  : #endif
; 164  :     }
; 165  : 
; 166  :     /* set number of window bits, free window if different */
; 167  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 16		 je	 SHORT $LN3@inflateRes@3
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 05		 jl	 SHORT $LN2@inflateRes@3
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7e 0c		 jle	 SHORT $LN3@inflateRes@3
$LN2@inflateRes@3:
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 168  :         return Z_STREAM_ERROR;

  0003f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00044	5f		 pop	 edi

; 178  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN3@inflateRes@3:

; 169  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00049	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004c	85 c0		 test	 eax, eax
  0004e	74 1c		 je	 SHORT $LN1@inflateRes@3
  00050	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00053	74 17		 je	 SHORT $LN1@inflateRes@3

; 170  :         ZFREE(strm, state->window);

  00055	50		 push	 eax
  00056	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00059	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  0005c	50		 push	 eax
  0005d	ff d1		 call	 ecx

; 171  :         state->window = Z_NULL;

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00062	83 c4 08	 add	 esp, 8
  00065	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN1@inflateRes@3:

; 172  :     }
; 173  : 
; 174  :     /* update state and reset the rest of it */
; 175  :     state->wrap = wrap;
; 176  :     state->wbits = (unsigned)windowBits;
; 177  :     return inflateReset(strm);

  0006c	51		 push	 ecx
  0006d	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00070	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00073	e8 00 00 00 00	 call	 _inflateReset@4
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	5f		 pop	 edi

; 178  : }

  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN7@inflateRes@3:

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00084	5f		 pop	 edi

; 178  : }

  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
PUBLIC	_inflateInit2_@16
; Function compile flags: /Ogtp
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :     int ret;
; 187  :     struct inflate_state FAR *state;
; 188  : 
; 189  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 190  :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	0f 84 9b 00 00
	00		 je	 $LN6@inflateIni
  00011	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00014	0f 85 92 00 00
	00		 jne	 $LN6@inflateIni
  0001a	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001e	0f 85 88 00 00
	00		 jne	 $LN6@inflateIni

; 192  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00028	3b f3		 cmp	 esi, ebx
  0002a	75 09		 jne	 SHORT $LN5@inflateIni
  0002c	5e		 pop	 esi
  0002d	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  00030	5b		 pop	 ebx

; 220  : }

  00031	5d		 pop	 ebp
  00032	c2 10 00	 ret	 16			; 00000010H
$LN5@inflateIni:

; 193  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00035	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 194  :     if (strm->zalloc == (alloc_func)0) {

  00038	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  0003b	75 0a		 jne	 SHORT $LN4@inflateIni

; 195  : #ifdef Z_SOLO
; 196  :         return Z_STREAM_ERROR;
; 197  : #else
; 198  :         strm->zalloc = zcalloc;

  0003d	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 199  :         strm->opaque = (voidpf)0;

  00044	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
$LN4@inflateIni:

; 200  : #endif
; 201  :     }
; 202  :     if (strm->zfree == (free_func)0)

  00047	39 5e 24	 cmp	 DWORD PTR [esi+36], ebx
  0004a	75 07		 jne	 SHORT $LN3@inflateIni

; 203  : #ifdef Z_SOLO
; 204  :         return Z_STREAM_ERROR;
; 205  : #else
; 206  :         strm->zfree = zcfree;

  0004c	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN3@inflateIni:

; 207  : #endif
; 208  :     state = (struct inflate_state FAR *)
; 209  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00053	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00056	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00059	57		 push	 edi
  0005a	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0005f	6a 01		 push	 1
  00061	50		 push	 eax
  00062	ff d1		 call	 ecx
  00064	8b f8		 mov	 edi, eax
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00069	3b fb		 cmp	 edi, ebx
  0006b	75 0c		 jne	 SHORT $LN2@inflateIni
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00074	5b		 pop	 ebx

; 220  : }

  00075	5d		 pop	 ebp
  00076	c2 10 00	 ret	 16			; 00000010H
$LN2@inflateIni:

; 211  :     Tracev((stderr, "inflate: allocated\n"));
; 212  :     strm->state = (struct internal_state FAR *)state;
; 213  :     state->window = Z_NULL;
; 214  :     ret = inflateReset2(strm, windowBits);

  00079	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  0007c	52		 push	 edx
  0007d	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00080	56		 push	 esi
  00081	89 5f 34	 mov	 DWORD PTR [edi+52], ebx
  00084	e8 00 00 00 00	 call	 _inflateReset2@8
  00089	8b d8		 mov	 ebx, eax

; 215  :     if (ret != Z_OK) {

  0008b	85 db		 test	 ebx, ebx
  0008d	74 14		 je	 SHORT $LN1@inflateIni

; 216  :         ZFREE(strm, state);

  0008f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00092	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00095	57		 push	 edi
  00096	50		 push	 eax
  00097	ff d1		 call	 ecx
  00099	83 c4 08	 add	 esp, 8

; 217  :         strm->state = Z_NULL;

  0009c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN1@inflateIni:

; 218  :     }
; 219  :     return ret;

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	8b c3		 mov	 eax, ebx
  000a7	5b		 pop	 ebx

; 220  : }

  000a8	5d		 pop	 ebp
  000a9	c2 10 00	 ret	 16			; 00000010H
$LN6@inflateIni:

; 191  :         return Z_VERSION_ERROR;

  000ac	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000b1	5b		 pop	 ebx

; 220  : }

  000b2	5d		 pop	 ebp
  000b3	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
PUBLIC	_inflateInit_@12
; Function compile flags: /Ogtp
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	6a 0f		 push	 15			; 0000000fH
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_@16

; 228  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
END
