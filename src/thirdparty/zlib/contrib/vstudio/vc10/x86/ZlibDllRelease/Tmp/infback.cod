; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	_inflate_fast:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 26		 je	 SHORT $LN1@inflateBac
  0000b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 1f		 je	 SHORT $LN1@inflateBac
  00012	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00015	85 c0		 test	 eax, eax
  00017	74 18		 je	 SHORT $LN1@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00019	51		 push	 ecx
  0001a	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001d	51		 push	 ecx
  0001e	ff d0		 call	 eax
  00020	83 c4 08	 add	 esp, 8

; 637  :     strm->state = Z_NULL;

  00023	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  0002a	33 c0		 xor	 eax, eax
  0002c	5e		 pop	 esi

; 640  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00031	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00036	5e		 pop	 esi

; 640  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = eax

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 121  :     state->distcode = distfix;

  0000e	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  00015	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 123  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Ogtp
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00003	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	0f 84 a7 00 00
	00		 je	 $LN6@inflateBac@2
  00011	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00014	0f 85 9e 00 00
	00		 jne	 $LN6@inflateBac@2
  0001a	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001e	0f 85 94 00 00
	00		 jne	 $LN6@inflateBac@2

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00028	57		 push	 edi
  00029	3b f3		 cmp	 esi, ebx
  0002b	74 7f		 je	 SHORT $LN4@inflateBac@2
  0002d	39 5d 10	 cmp	 DWORD PTR _window$[ebp], ebx
  00030	74 7a		 je	 SHORT $LN4@inflateBac@2
  00032	8b 7d 0c	 mov	 edi, DWORD PTR _windowBits$[ebp]
  00035	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00038	83 f8 07	 cmp	 eax, 7
  0003b	77 6f		 ja	 SHORT $LN4@inflateBac@2

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003d	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00040	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00043	75 0a		 jne	 SHORT $LN3@inflateBac@2

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0004c	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
$LN3@inflateBac@2:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  0004f	39 5e 24	 cmp	 DWORD PTR [esi+36], ebx
  00052	75 07		 jne	 SHORT $LN2@inflateBac@2

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  00054	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  0005b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0005e	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00061	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00066	6a 01		 push	 1
  00068	51		 push	 ecx
  00069	ff d2		 call	 edx
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	3b c3		 cmp	 eax, ebx
  00070	75 0c		 jne	 SHORT $LN1@inflateBac@2
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00079	5b		 pop	 ebx

; 70   : }

  0007a	5d		 pop	 ebp
  0007b	c2 14 00	 ret	 20			; 00000014H
$LN1@inflateBac@2:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  0007e	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = windowBits;
; 65   :     state->wsize = 1U << windowBits;

  00081	8b cf		 mov	 ecx, edi
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	d3 e2		 shl	 edx, cl

; 66   :     state->window = window;

  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _window$[ebp]
  0008d	89 78 24	 mov	 DWORD PTR [eax+36], edi
  00090	5f		 pop	 edi

; 67   :     state->wnext = 0;

  00091	89 58 30	 mov	 DWORD PTR [eax+48], ebx

; 68   :     state->whave = 0;

  00094	89 58 2c	 mov	 DWORD PTR [eax+44], ebx
  00097	5e		 pop	 esi
  00098	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [eax+20], 32768 ; 00008000H
  0009f	89 50 28	 mov	 DWORD PTR [eax+40], edx
  000a2	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 69   :     return Z_OK;

  000a5	33 c0		 xor	 eax, eax
  000a7	5b		 pop	 ebx

; 70   : }

  000a8	5d		 pop	 ebp
  000a9	c2 14 00	 ret	 20			; 00000014H
$LN4@inflateBac@2:
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi

; 42   :         return Z_STREAM_ERROR;

  000ae	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000b3	5b		 pop	 ebx

; 70   : }

  000b4	5d		 pop	 ebp
  000b5	c2 14 00	 ret	 20			; 00000014H
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  000b8	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000bd	5b		 pop	 ebx

; 70   : }

  000be	5d		 pop	 ebp
  000bf	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
PUBLIC	_inflateBack@20
; Function compile flags: /Ogtp
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv1911 = -28						; size = 4
tv1420 = -28						; size = 4
_from$ = -28						; size = 4
tv1446 = -24						; size = 4
tv1421 = -24						; size = 4
_len$ = -24						; size = 4
_here$ = -24						; size = 4
_copy$ = -24						; size = 4
_last$ = -20						; size = 4
_left$ = -16						; size = 4
_put$ = -12						; size = 4
_next$ = -8						; size = 4
_have$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	57		 push	 edi
  0000d	3b c6		 cmp	 eax, esi
  0000f	0f 84 95 0c 00
	00		 je	 $LN333@inflateBac@3
  00015	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  00018	3b fe		 cmp	 edi, esi
  0001a	0f 84 8a 0c 00
	00		 je	 $LN333@inflateBac@3

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00020	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 279  :     state->mode = TYPE;

  00023	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH

; 280  :     state->last = 0;

  00029	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 281  :     state->whave = 0;

  0002c	89 77 2c	 mov	 DWORD PTR [edi+44], esi

; 282  :     next = strm->next_in;

  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00034	3b ce		 cmp	 ecx, esi
  00036	74 08		 je	 SHORT $LN337@inflateBac@3
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0003e	eb 03		 jmp	 SHORT $LN338@inflateBac@3
$LN337@inflateBac@3:
  00040	89 75 fc	 mov	 DWORD PTR _have$[ebp], esi
$LN338@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00043	8b 07		 mov	 eax, DWORD PTR [edi]
  00045	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00048	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0004b	53		 push	 ebx
  0004c	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0004f	33 db		 xor	 ebx, ebx
  00051	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx
  00054	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  00057	83 f8 12	 cmp	 eax, 18			; 00000012H
  0005a	76 27		 jbe	 SHORT $LN332@inflateBac@3
$LN1@inflateBac@3:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  0005c	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
$inf_leave$80453:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00061	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]

; 627  :     strm->avail_in = have;

  00067	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  0006a	5b		 pop	 ebx
  0006b	89 08		 mov	 DWORD PTR [eax], ecx
  0006d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00070	5f		 pop	 edi

; 628  :     return ret;

  00071	8b c6		 mov	 eax, esi
  00073	5e		 pop	 esi

; 629  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 14 00	 ret	 20			; 00000014H
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL420@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00080	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN332@inflateBac@3:
  00083	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN414@inflateBac@3[eax]
  0008a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN460@inflateBac@3[eax*4]
$LN328@inflateBac@3:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  00091	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00095	74 14		 je	 SHORT $LN323@inflateBac@3

; 295  :                 BYTEBITS();

  00097	8b ce		 mov	 ecx, esi
  00099	83 e1 07	 and	 ecx, 7
  0009c	d3 eb		 shr	 ebx, cl
  0009e	2b f1		 sub	 esi, ecx

; 296  :                 state->mode = DONE;

  000a0	c7 07 1c 00 00
	00		 mov	 DWORD PTR [edi], 28	; 0000001cH

; 297  :                 break;

  000a6	e9 8f 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN323@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  000ab	83 fe 03	 cmp	 esi, 3
  000ae	73 3a		 jae	 SHORT $LN322@inflateBac@3
$LL320@inflateBac@3:
  000b0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  000b4	75 19		 jne	 SHORT $LN314@inflateBac@3
  000b6	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  000b9	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  000bc	51		 push	 ecx
  000bd	52		 push	 edx
  000be	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  000c1	83 c4 08	 add	 esp, 8
  000c4	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 7e 0b 00
	00		 je	 $LN363@inflateBac@3
$LN314@inflateBac@3:
  000cf	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  000d2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000d5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  000d8	8b ce		 mov	 ecx, esi
  000da	d3 e2		 shl	 edx, cl
  000dc	40		 inc	 eax
  000dd	83 c6 08	 add	 esi, 8
  000e0	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  000e3	03 da		 add	 ebx, edx
  000e5	83 fe 03	 cmp	 esi, 3
  000e8	72 c6		 jb	 SHORT $LL320@inflateBac@3
$LN322@inflateBac@3:

; 300  :             state->last = BITS(1);

  000ea	8b c3		 mov	 eax, ebx
  000ec	83 e0 01	 and	 eax, 1

; 301  :             DROPBITS(1);

  000ef	d1 eb		 shr	 ebx, 1
  000f1	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 302  :             switch (BITS(2)) {

  000f4	8b c3		 mov	 eax, ebx
  000f6	83 e0 03	 and	 eax, 3
  000f9	83 f8 03	 cmp	 eax, 3
  000fc	77 51		 ja	 SHORT $LN301@inflateBac@3
  000fe	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN461@inflateBac@3[eax*4]
$LN305@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  00105	c1 eb 02	 shr	 ebx, 2
  00108	c7 07 0d 00 00
	00		 mov	 DWORD PTR [edi], 13	; 0000000dH
  0010e	83 ee 03	 sub	 esi, 3

; 324  :             break;

  00111	e9 24 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN304@inflateBac@3:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;
; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00116	8b c7		 mov	 eax, edi
  00118	e8 00 00 00 00	 call	 _fixedtables

; 322  :             }
; 323  :             DROPBITS(2);

  0011d	c1 eb 02	 shr	 ebx, 2
  00120	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H
  00126	83 ee 03	 sub	 esi, 3

; 324  :             break;

  00129	e9 0c 0b 00 00	 jmp	 $LN387@inflateBac@3
$LN303@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  0012e	c1 eb 02	 shr	 ebx, 2
  00131	c7 07 10 00 00
	00		 mov	 DWORD PTR [edi], 16	; 00000010H
  00137	83 ee 03	 sub	 esi, 3

; 324  :             break;

  0013a	e9 fb 0a 00 00	 jmp	 $LN387@inflateBac@3
$LN302@inflateBac@3:

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  0013f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00142	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;

  00149	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH
$LN301@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  0014f	c1 eb 02	 shr	 ebx, 2
  00152	83 ee 03	 sub	 esi, 3

; 324  :             break;

  00155	e9 e0 0a 00 00	 jmp	 $LN387@inflateBac@3
$LN297@inflateBac@3:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  0015a	8b ce		 mov	 ecx, esi
  0015c	83 e1 07	 and	 ecx, 7
  0015f	2b f1		 sub	 esi, ecx
  00161	d3 eb		 shr	 ebx, cl

; 329  :             NEEDBITS(32);

  00163	83 fe 20	 cmp	 esi, 32			; 00000020H
  00166	73 3a		 jae	 SHORT $LN293@inflateBac@3
$LL291@inflateBac@3:
  00168	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  0016c	75 19		 jne	 SHORT $LN285@inflateBac@3
  0016e	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00171	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00174	52		 push	 edx
  00175	50		 push	 eax
  00176	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00179	83 c4 08	 add	 esp, 8
  0017c	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0017f	85 c0		 test	 eax, eax
  00181	0f 84 c6 0a 00
	00		 je	 $LN363@inflateBac@3
$LN285@inflateBac@3:
  00187	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0018a	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0018d	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00190	8b ce		 mov	 ecx, esi
  00192	d3 e2		 shl	 edx, cl
  00194	40		 inc	 eax
  00195	83 c6 08	 add	 esi, 8
  00198	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0019b	03 da		 add	 ebx, edx
  0019d	83 fe 20	 cmp	 esi, 32			; 00000020H
  001a0	72 c6		 jb	 SHORT $LL291@inflateBac@3
$LN293@inflateBac@3:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001a2	8b cb		 mov	 ecx, ebx
  001a4	8b c3		 mov	 eax, ebx
  001a6	f7 d1		 not	 ecx
  001a8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001ad	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001b0	3b c1		 cmp	 eax, ecx
  001b2	74 15		 je	 SHORT $LN281@inflateBac@3

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  001b4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001b7	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 332  :                 state->mode = BAD;

  001be	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 333  :                 break;

  001c4	e9 71 0a 00 00	 jmp	 $LN387@inflateBac@3
$LN281@inflateBac@3:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;
; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  001c9	33 db		 xor	 ebx, ebx
  001cb	33 f6		 xor	 esi, esi
  001cd	89 47 40	 mov	 DWORD PTR [edi+64], eax

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  001d0	85 c0		 test	 eax, eax
  001d2	0f 84 9c 00 00
	00		 je	 $LN276@inflateBac@3
  001d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL277@inflateBac@3:

; 342  :                 copy = state->length;

  001e0	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  001e3	89 45 e8	 mov	 DWORD PTR _copy$[ebp], eax

; 343  :                 PULL();

  001e6	39 5d fc	 cmp	 DWORD PTR _have$[ebp], ebx
  001e9	75 19		 jne	 SHORT $LN274@inflateBac@3
  001eb	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  001ee	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  001f1	51		 push	 ecx
  001f2	52		 push	 edx
  001f3	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  001f6	83 c4 08	 add	 esp, 8
  001f9	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 5a 0a 00
	00		 je	 $LN365@inflateBac@3
$LN274@inflateBac@3:

; 344  :                 ROOM();

  00204	39 5d f0	 cmp	 DWORD PTR _left$[ebp], ebx
  00207	75 23		 jne	 SHORT $LN269@inflateBac@3
  00209	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0020c	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0020f	50		 push	 eax
  00210	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  00213	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  00216	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00219	51		 push	 ecx
  0021a	50		 push	 eax
  0021b	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  0021e	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	85 c0		 test	 eax, eax
  00226	0f 85 28 0a 00
	00		 jne	 $LN366@inflateBac@3
$LN269@inflateBac@3:

; 345  :                 if (copy > have) copy = have;

  0022c	8b 45 e8	 mov	 eax, DWORD PTR _copy$[ebp]
  0022f	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  00232	3b c1		 cmp	 eax, ecx
  00234	76 05		 jbe	 SHORT $LN265@inflateBac@3
  00236	8b c1		 mov	 eax, ecx
  00238	89 4d e8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN265@inflateBac@3:

; 346  :                 if (copy > left) copy = left;

  0023b	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  0023e	3b c1		 cmp	 eax, ecx
  00240	76 03		 jbe	 SHORT $LN264@inflateBac@3
  00242	89 4d e8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN264@inflateBac@3:

; 347  :                 zmemcpy(put, next, copy);

  00245	8b 4d e8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00248	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0024b	8b 45 f4	 mov	 eax, DWORD PTR _put$[ebp]
  0024e	51		 push	 ecx
  0024f	52		 push	 edx
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 _memcpy

; 348  :                 have -= copy;

  00256	8b 45 e8	 mov	 eax, DWORD PTR _copy$[ebp]

; 349  :                 next += copy;

  00259	01 45 f8	 add	 DWORD PTR _next$[ebp], eax
  0025c	29 45 fc	 sub	 DWORD PTR _have$[ebp], eax

; 350  :                 left -= copy;

  0025f	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax

; 351  :                 put += copy;

  00262	01 45 f4	 add	 DWORD PTR _put$[ebp], eax

; 352  :                 state->length -= copy;

  00265	29 47 40	 sub	 DWORD PTR [edi+64], eax
  00268	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026b	39 5f 40	 cmp	 DWORD PTR [edi+64], ebx
  0026e	0f 85 6c ff ff
	ff		 jne	 $LL277@inflateBac@3
$LN276@inflateBac@3:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  00274	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH

; 356  :             break;

  0027a	e9 bb 09 00 00	 jmp	 $LN387@inflateBac@3
$LN262@inflateBac@3:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  0027f	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00282	73 3a		 jae	 SHORT $LN261@inflateBac@3
$LL259@inflateBac@3:
  00284	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00288	75 19		 jne	 SHORT $LN253@inflateBac@3
  0028a	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0028d	8d 4d f8	 lea	 ecx, DWORD PTR _next$[ebp]
  00290	51		 push	 ecx
  00291	52		 push	 edx
  00292	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00295	83 c4 08	 add	 esp, 8
  00298	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0029b	85 c0		 test	 eax, eax
  0029d	0f 84 aa 09 00
	00		 je	 $LN363@inflateBac@3
$LN253@inflateBac@3:
  002a3	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  002a6	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  002a9	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  002ac	8b ce		 mov	 ecx, esi
  002ae	d3 e2		 shl	 edx, cl
  002b0	40		 inc	 eax
  002b1	83 c6 08	 add	 esi, 8
  002b4	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  002b7	03 da		 add	 ebx, edx
  002b9	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  002bc	72 c6		 jb	 SHORT $LL259@inflateBac@3
$LN261@inflateBac@3:

; 361  :             state->nlen = BITS(5) + 257;

  002be	8b c3		 mov	 eax, ebx

; 362  :             DROPBITS(5);

  002c0	c1 eb 05	 shr	 ebx, 5

; 363  :             state->ndist = BITS(5) + 1;

  002c3	8b cb		 mov	 ecx, ebx

; 364  :             DROPBITS(5);

  002c5	c1 eb 05	 shr	 ebx, 5

; 365  :             state->ncode = BITS(4) + 4;

  002c8	8b d3		 mov	 edx, ebx
  002ca	83 e0 1f	 and	 eax, 31			; 0000001fH
  002cd	83 e1 1f	 and	 ecx, 31			; 0000001fH
  002d0	83 e2 0f	 and	 edx, 15			; 0000000fH
  002d3	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002d8	41		 inc	 ecx
  002d9	83 c2 04	 add	 edx, 4

; 366  :             DROPBITS(4);

  002dc	c1 eb 04	 shr	 ebx, 4
  002df	83 ee 0e	 sub	 esi, 14			; 0000000eH
  002e2	89 47 60	 mov	 DWORD PTR [edi+96], eax
  002e5	89 4f 64	 mov	 DWORD PTR [edi+100], ecx
  002e8	89 57 5c	 mov	 DWORD PTR [edi+92], edx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  002eb	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  002f0	0f 87 90 04 00
	00		 ja	 $LN239@inflateBac@3
  002f6	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  002f9	0f 87 87 04 00
	00		 ja	 $LN239@inflateBac@3

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  002ff	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], 0

; 378  :             while (state->have < state->ncode) {

  00306	85 d2		 test	 edx, edx
  00308	76 6b		 jbe	 SHORT $LN346@inflateBac@3
  0030a	8d 9b 00 00 00
	00		 npad	 6
$LL238@inflateBac@3:

; 379  :                 NEEDBITS(3);

  00310	83 fe 03	 cmp	 esi, 3
  00313	73 3a		 jae	 SHORT $LN235@inflateBac@3
$LL233@inflateBac@3:
  00315	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00319	75 19		 jne	 SHORT $LN227@inflateBac@3
  0031b	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0031e	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  00321	50		 push	 eax
  00322	51		 push	 ecx
  00323	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00326	83 c4 08	 add	 esp, 8
  00329	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0032c	85 c0		 test	 eax, eax
  0032e	0f 84 19 09 00
	00		 je	 $LN363@inflateBac@3
$LN227@inflateBac@3:
  00334	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00337	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0033a	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0033d	8b ce		 mov	 ecx, esi
  0033f	d3 e2		 shl	 edx, cl
  00341	40		 inc	 eax
  00342	83 c6 08	 add	 esi, 8
  00345	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00348	03 da		 add	 ebx, edx
  0034a	83 fe 03	 cmp	 esi, 3
  0034d	72 c6		 jb	 SHORT $LL233@inflateBac@3
$LN235@inflateBac@3:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0034f	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00352	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0035a	8b c3		 mov	 eax, ebx
  0035c	83 e0 07	 and	 eax, 7
  0035f	66 89 44 57 70	 mov	 WORD PTR [edi+edx*2+112], ax
  00364	ff 47 68	 inc	 DWORD PTR [edi+104]
  00367	8b 47 68	 mov	 eax, DWORD PTR [edi+104]

; 381  :                 DROPBITS(3);

  0036a	c1 eb 03	 shr	 ebx, 3
  0036d	83 ee 03	 sub	 esi, 3
  00370	3b 47 5c	 cmp	 eax, DWORD PTR [edi+92]
  00373	72 9b		 jb	 SHORT $LL238@inflateBac@3
$LN346@inflateBac@3:

; 382  :             }
; 383  :             while (state->have < 19)

  00375	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  0037a	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  0037d	73 1b		 jae	 SHORT $LN219@inflateBac@3
  0037f	90		 npad	 1
$LL220@inflateBac@3:

; 384  :                 state->lens[order[state->have++]] = 0;

  00380	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00383	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0038b	33 c9		 xor	 ecx, ecx
  0038d	66 89 4c 57 70	 mov	 WORD PTR [edi+edx*2+112], cx
  00392	ff 47 68	 inc	 DWORD PTR [edi+104]
  00395	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  00398	72 e6		 jb	 SHORT $LL220@inflateBac@3
$LN219@inflateBac@3:

; 385  :             state->next = state->codes;

  0039a	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  003a0	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  003a3	89 01		 mov	 DWORD PTR [ecx], eax

; 386  :             state->lencode = (code const FAR *)(state->next);

  003a5	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 387  :             state->lenbits = 7;
; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  003a8	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  003ae	52		 push	 edx
  003af	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  003b2	50		 push	 eax
  003b3	51		 push	 ecx
  003b4	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
  003ba	6a 13		 push	 19			; 00000013H
  003bc	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  003bf	50		 push	 eax
  003c0	6a 00		 push	 0
  003c2	e8 00 00 00 00	 call	 _inflate_table
  003c7	83 c4 18	 add	 esp, 24			; 00000018H

; 390  :             if (ret) {

  003ca	85 c0		 test	 eax, eax
  003cc	74 15		 je	 SHORT $LN218@inflateBac@3

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  003ce	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  003d1	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 392  :                 state->mode = BAD;

  003d8	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 393  :                 break;

  003de	e9 57 08 00 00	 jmp	 $LN387@inflateBac@3
$LN218@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  003e3	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  003e6	03 47 60	 add	 eax, DWORD PTR [edi+96]
  003e9	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], 0
  003f0	0f 84 37 02 00
	00		 je	 $LN417@inflateBac@3
  003f6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL217@inflateBac@3:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  00400	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00403	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00406	ba 01 00 00 00	 mov	 edx, 1
  0040b	d3 e2		 shl	 edx, cl
  0040d	4a		 dec	 edx
  0040e	23 d3		 and	 edx, ebx
  00410	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00413	8b c8		 mov	 ecx, eax
  00415	c1 e9 08	 shr	 ecx, 8
  00418	0f b6 d1	 movzx	 edx, cl
  0041b	89 45 e8	 mov	 DWORD PTR _here$[ebp], eax
  0041e	3b d6		 cmp	 edx, esi
  00420	76 58		 jbe	 SHORT $LN369@inflateBac@3
$LL215@inflateBac@3:

; 403  :                     PULLBYTE();

  00422	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00426	75 19		 jne	 SHORT $LN208@inflateBac@3
  00428	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0042b	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0042e	50		 push	 eax
  0042f	51		 push	 ecx
  00430	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00433	83 c4 08	 add	 esp, 8
  00436	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00439	85 c0		 test	 eax, eax
  0043b	0f 84 0c 08 00
	00		 je	 $LN363@inflateBac@3
$LN208@inflateBac@3:
  00441	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00444	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00447	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0044a	40		 inc	 eax
  0044b	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0044e	8b ce		 mov	 ecx, esi
  00450	d3 e2		 shl	 edx, cl
  00452	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00455	b8 01 00 00 00	 mov	 eax, 1
  0045a	d3 e0		 shl	 eax, cl
  0045c	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  0045f	03 da		 add	 ebx, edx
  00461	83 c6 08	 add	 esi, 8
  00464	48		 dec	 eax
  00465	23 c3		 and	 eax, ebx
  00467	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0046a	89 45 e8	 mov	 DWORD PTR _here$[ebp], eax
  0046d	c1 e8 08	 shr	 eax, 8
  00470	0f b6 d0	 movzx	 edx, al
  00473	3b d6		 cmp	 edx, esi
  00475	77 ab		 ja	 SHORT $LL215@inflateBac@3

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00477	8b 45 e8	 mov	 eax, DWORD PTR _here$[ebp]
$LN369@inflateBac@3:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  0047a	8b d0		 mov	 edx, eax
  0047c	c1 ea 10	 shr	 edx, 16			; 00000010H
  0047f	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00483	73 1a		 jae	 SHORT $LN458@inflateBac@3

; 406  :                     DROPBITS(here.bits);

  00485	c1 e8 08	 shr	 eax, 8
  00488	0f b6 c8	 movzx	 ecx, al

; 407  :                     state->lens[state->have++] = here.val;

  0048b	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  0048e	d3 eb		 shr	 ebx, cl
  00490	2b f1		 sub	 esi, ecx
  00492	66 89 54 47 70	 mov	 WORD PTR [edi+eax*2+112], dx
  00497	ff 47 68	 inc	 DWORD PTR [edi+104]

; 408  :                 }
; 409  :                 else {

  0049a	e9 7f 01 00 00	 jmp	 $LN430@inflateBac@3
$LN458@inflateBac@3:

; 410  :                     if (here.val == 16) {

  0049f	75 7f		 jne	 SHORT $LN199@inflateBac@3

; 411  :                         NEEDBITS(here.bits + 2);

  004a1	8b c8		 mov	 ecx, eax
  004a3	c1 e9 08	 shr	 ecx, 8
  004a6	0f b6 d1	 movzx	 edx, cl
  004a9	83 c2 02	 add	 edx, 2
  004ac	3b f2		 cmp	 esi, edx
  004ae	73 43		 jae	 SHORT $LN197@inflateBac@3
$LL195@inflateBac@3:
  004b0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  004b4	75 19		 jne	 SHORT $LN189@inflateBac@3
  004b6	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  004b9	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  004bc	50		 push	 eax
  004bd	51		 push	 ecx
  004be	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  004c1	83 c4 08	 add	 esp, 8
  004c4	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  004c7	85 c0		 test	 eax, eax
  004c9	0f 84 7e 07 00
	00		 je	 $LN363@inflateBac@3
$LN189@inflateBac@3:
  004cf	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  004d2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  004d5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  004d8	40		 inc	 eax
  004d9	8b ce		 mov	 ecx, esi
  004db	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  004de	0f b6 45 e9	 movzx	 eax, BYTE PTR _here$[ebp+1]
  004e2	d3 e2		 shl	 edx, cl
  004e4	83 c6 08	 add	 esi, 8
  004e7	83 c0 02	 add	 eax, 2
  004ea	03 da		 add	 ebx, edx
  004ec	3b f0		 cmp	 esi, eax
  004ee	72 c0		 jb	 SHORT $LL195@inflateBac@3
  004f0	8b 45 e8	 mov	 eax, DWORD PTR _here$[ebp]
$LN197@inflateBac@3:

; 412  :                         DROPBITS(here.bits);

  004f3	0f b6 cc	 movzx	 ecx, ah

; 413  :                         if (state->have == 0) {

  004f6	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  004f9	d3 eb		 shr	 ebx, cl
  004fb	2b f1		 sub	 esi, ecx
  004fd	85 c0		 test	 eax, eax
  004ff	0f 84 50 01 00
	00		 je	 $LN374@inflateBac@3

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  00505	0f b7 4c 47 6e	 movzx	 ecx, WORD PTR [edi+eax*2+110]

; 419  :                         copy = 3 + BITS(2);

  0050a	8b c3		 mov	 eax, ebx
  0050c	83 e0 03	 and	 eax, 3
  0050f	83 c0 03	 add	 eax, 3

; 420  :                         DROPBITS(2);

  00512	c1 eb 02	 shr	 ebx, 2
  00515	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx
  00518	83 ee 02	 sub	 esi, 2

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  0051b	e9 d0 00 00 00	 jmp	 $LN138@inflateBac@3
$LN199@inflateBac@3:
  00520	66 83 7d ea 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H

; 423  :                         NEEDBITS(here.bits + 3);

  00525	0f b6 cc	 movzx	 ecx, ah
  00528	89 4d e8	 mov	 DWORD PTR tv1446[ebp], ecx
  0052b	75 5d		 jne	 SHORT $LN156@inflateBac@3
  0052d	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00530	3b f0		 cmp	 esi, eax
  00532	73 42		 jae	 SHORT $LN175@inflateBac@3
$LL173@inflateBac@3:
  00534	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00538	75 19		 jne	 SHORT $LN167@inflateBac@3
  0053a	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  0053d	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00540	52		 push	 edx
  00541	50		 push	 eax
  00542	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00545	83 c4 08	 add	 esp, 8
  00548	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  0054b	85 c0		 test	 eax, eax
  0054d	0f 84 fa 06 00
	00		 je	 $LN363@inflateBac@3
$LN167@inflateBac@3:
  00553	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00556	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00559	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  0055c	40		 inc	 eax
  0055d	8b ce		 mov	 ecx, esi
  0055f	d3 e2		 shl	 edx, cl
  00561	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00564	8b 45 e8	 mov	 eax, DWORD PTR tv1446[ebp]
  00567	83 c6 08	 add	 esi, 8
  0056a	83 c0 03	 add	 eax, 3
  0056d	03 da		 add	 ebx, edx
  0056f	3b f0		 cmp	 esi, eax
  00571	72 c1		 jb	 SHORT $LL173@inflateBac@3
  00573	8b 4d e8	 mov	 ecx, DWORD PTR tv1446[ebp]
$LN175@inflateBac@3:

; 424  :                         DROPBITS(here.bits);

  00576	d3 eb		 shr	 ebx, cl

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  00578	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH
  0057d	8b c3		 mov	 eax, ebx
  0057f	83 e0 07	 and	 eax, 7
  00582	83 c0 03	 add	 eax, 3
  00585	c1 eb 03	 shr	 ebx, 3

; 428  :                     }
; 429  :                     else {

  00588	eb 5b		 jmp	 SHORT $LN459@inflateBac@3
$LN156@inflateBac@3:

; 430  :                         NEEDBITS(here.bits + 7);

  0058a	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  0058d	3b f0		 cmp	 esi, eax
  0058f	73 42		 jae	 SHORT $LN155@inflateBac@3
$LL153@inflateBac@3:
  00591	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00595	75 19		 jne	 SHORT $LN147@inflateBac@3
  00597	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0059a	8d 45 f8	 lea	 eax, DWORD PTR _next$[ebp]
  0059d	50		 push	 eax
  0059e	51		 push	 ecx
  0059f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  005a2	83 c4 08	 add	 esp, 8
  005a5	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  005a8	85 c0		 test	 eax, eax
  005aa	0f 84 9d 06 00
	00		 je	 $LN363@inflateBac@3
$LN147@inflateBac@3:
  005b0	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  005b3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  005b6	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  005b9	40		 inc	 eax
  005ba	8b ce		 mov	 ecx, esi
  005bc	d3 e2		 shl	 edx, cl
  005be	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  005c1	8b 45 e8	 mov	 eax, DWORD PTR tv1446[ebp]
  005c4	83 c6 08	 add	 esi, 8
  005c7	83 c0 07	 add	 eax, 7
  005ca	03 da		 add	 ebx, edx
  005cc	3b f0		 cmp	 esi, eax
  005ce	72 c1		 jb	 SHORT $LL153@inflateBac@3
  005d0	8b 4d e8	 mov	 ecx, DWORD PTR tv1446[ebp]
$LN155@inflateBac@3:

; 431  :                         DROPBITS(here.bits);

  005d3	d3 eb		 shr	 ebx, cl

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  005d5	ba f9 ff ff ff	 mov	 edx, -7			; fffffff9H
  005da	8b c3		 mov	 eax, ebx
  005dc	83 e0 7f	 and	 eax, 127		; 0000007fH
  005df	83 c0 0b	 add	 eax, 11			; 0000000bH
  005e2	c1 eb 07	 shr	 ebx, 7
$LN459@inflateBac@3:
  005e5	2b d1		 sub	 edx, ecx
  005e7	03 f2		 add	 esi, edx
  005e9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN138@inflateBac@3:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  005f0	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  005f3	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  005f6	03 4f 60	 add	 ecx, DWORD PTR [edi+96]
  005f9	03 d0		 add	 edx, eax
  005fb	3b d1		 cmp	 edx, ecx
  005fd	77 6b		 ja	 SHORT $LN375@inflateBac@3

; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  005ff	85 c0		 test	 eax, eax
  00601	74 1b		 je	 SHORT $LN430@inflateBac@3
  00603	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00606	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL136@inflateBac@3:

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00610	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00613	66 89 4c 57 70	 mov	 WORD PTR [edi+edx*2+112], cx
  00618	ff 47 68	 inc	 DWORD PTR [edi+104]
  0061b	48		 dec	 eax
  0061c	75 f2		 jne	 SHORT $LL136@inflateBac@3
$LN430@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0061e	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00621	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00624	39 47 68	 cmp	 DWORD PTR [edi+104], eax
  00627	0f 82 d3 fd ff
	ff		 jb	 $LL217@inflateBac@3
$LN417@inflateBac@3:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  0062d	83 3f 1d	 cmp	 DWORD PTR [edi], 29	; 0000001dH
  00630	0f 84 04 06 00
	00		 je	 $LN387@inflateBac@3

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00636	66 83 bf 70 02
	00 00 00	 cmp	 WORD PTR [edi+624], 0
  0063e	75 3f		 jne	 SHORT $LN133@inflateBac@3

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00640	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00643	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;

  0064a	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 453  :                 break;

  00650	e9 e5 05 00 00	 jmp	 $LN387@inflateBac@3
$LN374@inflateBac@3:

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00655	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00658	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 415  :                             state->mode = BAD;

  0065f	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 416  :                             break;

  00665	e9 d0 05 00 00	 jmp	 $LN387@inflateBac@3
$LN375@inflateBac@3:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  0066a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0066d	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 438  :                         state->mode = BAD;

  00674	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  0067a	e9 bb 05 00 00	 jmp	 $LN387@inflateBac@3
$LN133@inflateBac@3:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  0067f	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  00685	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00688	89 01		 mov	 DWORD PTR [ecx], eax

; 460  :             state->lencode = (code const FAR *)(state->next);

  0068a	89 47 4c	 mov	 DWORD PTR [edi+76], eax

; 461  :             state->lenbits = 9;
; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  0068d	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  00693	52		 push	 edx
  00694	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  00697	50		 push	 eax
  00698	51		 push	 ecx
  00699	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0069c	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
  006a2	51		 push	 ecx
  006a3	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  006a6	50		 push	 eax
  006a7	6a 01		 push	 1
  006a9	e8 00 00 00 00	 call	 _inflate_table
  006ae	83 c4 18	 add	 esp, 24			; 00000018H

; 464  :             if (ret) {

  006b1	85 c0		 test	 eax, eax
  006b3	74 15		 je	 SHORT $LN132@inflateBac@3

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  006b5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  006b8	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;

  006bf	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 467  :                 break;

  006c5	e9 70 05 00 00	 jmp	 $LN387@inflateBac@3
$LN132@inflateBac@3:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  006ca	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  006cd	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  006d0	89 47 50	 mov	 DWORD PTR [edi+80], eax

; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  006d3	8d 97 f0 02 00
	00		 lea	 edx, DWORD PTR [edi+752]
  006d9	52		 push	 edx
  006da	8b 57 60	 mov	 edx, DWORD PTR [edi+96]
  006dd	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  006e0	50		 push	 eax
  006e1	51		 push	 ecx
  006e2	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  006e5	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
  006eb	51		 push	 ecx
  006ec	8d 44 57 70	 lea	 eax, DWORD PTR [edi+edx*2+112]
  006f0	50		 push	 eax
  006f1	6a 02		 push	 2
  006f3	e8 00 00 00 00	 call	 _inflate_table
  006f8	83 c4 18	 add	 esp, 24			; 00000018H

; 473  :             if (ret) {

  006fb	85 c0		 test	 eax, eax
  006fd	74 15		 je	 SHORT $LN131@inflateBac@3

; 474  :                 strm->msg = (char *)"invalid distances set";

  006ff	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00702	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;

  00709	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 476  :                 break;

  0070f	e9 26 05 00 00	 jmp	 $LN387@inflateBac@3
$LN131@inflateBac@3:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00714	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00717	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H
$LN130@inflateBac@3:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  0071d	83 7d fc 06	 cmp	 DWORD PTR _have$[ebp], 6
  00721	72 78		 jb	 SHORT $LN353@inflateBac@3
  00723	8b 4d f0	 mov	 ecx, DWORD PTR _left$[ebp]
  00726	81 f9 02 01 00
	00		 cmp	 ecx, 258		; 00000102H
  0072c	72 6d		 jb	 SHORT $LN353@inflateBac@3

; 484  :                 RESTORE();

  0072e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00731	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00734	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00737	89 10		 mov	 DWORD PTR [eax], edx
  00739	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  0073c	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0073f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 485  :                 if (state->whave < state->wsize)

  00742	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00745	89 5f 38	 mov	 DWORD PTR [edi+56], ebx
  00748	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  0074b	39 47 2c	 cmp	 DWORD PTR [edi+44], eax
  0074e	73 07		 jae	 SHORT $LN125@inflateBac@3

; 486  :                     state->whave = state->wsize - left;

  00750	8b d0		 mov	 edx, eax
  00752	2b d1		 sub	 edx, ecx
  00754	89 57 2c	 mov	 DWORD PTR [edi+44], edx
$LN125@inflateBac@3:

; 487  :                 inflate_fast(strm, state->wsize);

  00757	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0075a	50		 push	 eax
  0075b	56		 push	 esi
  0075c	e8 00 00 00 00	 call	 _inflate_fast

; 488  :                 LOAD();

  00761	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00764	8b 16		 mov	 edx, DWORD PTR [esi]
  00766	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00769	89 45 f4	 mov	 DWORD PTR _put$[ebp], eax
  0076c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0076f	89 55 f8	 mov	 DWORD PTR _next$[ebp], edx
  00772	8b 5f 38	 mov	 ebx, DWORD PTR [edi+56]
  00775	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  00778	83 c4 08	 add	 esp, 8
  0077b	89 4d f0	 mov	 DWORD PTR _left$[ebp], ecx
  0077e	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 489  :                 break;

  00781	e9 b4 04 00 00	 jmp	 $LN387@inflateBac@3
$LN239@inflateBac@3:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  00786	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00789	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;

  00790	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 371  :                 break;

  00796	e9 9f 04 00 00	 jmp	 $LN387@inflateBac@3
$LN353@inflateBac@3:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  0079b	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0079e	b8 01 00 00 00	 mov	 eax, 1
  007a3	d3 e0		 shl	 eax, cl
  007a5	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  007a8	48		 dec	 eax
  007a9	23 c3		 and	 eax, ebx
  007ab	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  007ae	8b c8		 mov	 ecx, eax
  007b0	c1 e9 08	 shr	 ecx, 8
  007b3	0f b6 c9	 movzx	 ecx, cl
  007b6	3b ce		 cmp	 ecx, esi
  007b8	76 5d		 jbe	 SHORT $LN376@inflateBac@3
  007ba	8d 9b 00 00 00
	00		 npad	 6
$LL121@inflateBac@3:

; 496  :                 PULLBYTE();

  007c0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  007c4	75 19		 jne	 SHORT $LN114@inflateBac@3
  007c6	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  007c9	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  007cc	52		 push	 edx
  007cd	50		 push	 eax
  007ce	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  007d1	83 c4 08	 add	 esp, 8
  007d4	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  007d7	85 c0		 test	 eax, eax
  007d9	0f 84 6e 04 00
	00		 je	 $LN363@inflateBac@3
$LN114@inflateBac@3:
  007df	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  007e2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  007e5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  007e8	40		 inc	 eax
  007e9	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  007ec	8b ce		 mov	 ecx, esi
  007ee	d3 e2		 shl	 edx, cl
  007f0	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  007f3	b8 01 00 00 00	 mov	 eax, 1
  007f8	d3 e0		 shl	 eax, cl
  007fa	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  007fd	03 da		 add	 ebx, edx
  007ff	83 c6 08	 add	 esi, 8
  00802	48		 dec	 eax
  00803	23 c3		 and	 eax, ebx
  00805	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00808	8b d0		 mov	 edx, eax
  0080a	c1 ea 08	 shr	 edx, 8
  0080d	0f b6 ca	 movzx	 ecx, dl
  00810	3b ce		 cmp	 ecx, esi
  00812	77 ac		 ja	 SHORT $LL121@inflateBac@3

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00814	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN376@inflateBac@3:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00817	84 c0		 test	 al, al
  00819	0f 84 c8 00 00
	00		 je	 $LN96@inflateBac@3
  0081f	a8 f0		 test	 al, 240			; 000000f0H
  00821	0f 85 c0 00 00
	00		 jne	 $LN96@inflateBac@3

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  00827	8b c8		 mov	 ecx, eax
  00829	c1 e9 08	 shr	 ecx, 8
  0082c	0f b6 d1	 movzx	 edx, cl
  0082f	89 4d e4	 mov	 DWORD PTR tv1420[ebp], ecx
  00832	89 55 e8	 mov	 DWORD PTR tv1421[ebp], edx
  00835	0f b6 c8	 movzx	 ecx, al
  00838	03 ca		 add	 ecx, edx
  0083a	ba 01 00 00 00	 mov	 edx, 1
  0083f	d3 e2		 shl	 edx, cl
  00841	8b 4d e8	 mov	 ecx, DWORD PTR tv1421[ebp]
  00844	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  00847	c1 e8 10	 shr	 eax, 16			; 00000010H
  0084a	4a		 dec	 edx
  0084b	23 d3		 and	 edx, ebx
  0084d	d3 ea		 shr	 edx, cl
  0084f	03 d0		 add	 edx, eax
  00851	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00854	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00857	8b c8		 mov	 ecx, eax
  00859	c1 e9 08	 shr	 ecx, 8
  0085c	0f b6 d1	 movzx	 edx, cl
  0085f	0f b6 4d e4	 movzx	 ecx, BYTE PTR tv1420[ebp]
  00863	03 d1		 add	 edx, ecx
  00865	3b d6		 cmp	 edx, esi
  00867	76 6f		 jbe	 SHORT $LN439@inflateBac@3
  00869	8d a4 24 00 00
	00 00		 npad	 7
$LL109@inflateBac@3:

; 504  :                     PULLBYTE();

  00870	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00874	75 19		 jne	 SHORT $LN102@inflateBac@3
  00876	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00879	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  0087c	52		 push	 edx
  0087d	50		 push	 eax
  0087e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00881	83 c4 08	 add	 esp, 8
  00884	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00887	85 c0		 test	 eax, eax
  00889	0f 84 be 03 00
	00		 je	 $LN363@inflateBac@3
$LN102@inflateBac@3:
  0088f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00892	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00895	40		 inc	 eax
  00896	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00899	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  0089c	8b ce		 mov	 ecx, esi
  0089e	d3 e2		 shl	 edx, cl
  008a0	0f b6 c8	 movzx	 ecx, al
  008a3	03 da		 add	 ebx, edx
  008a5	0f b6 d4	 movzx	 edx, ah
  008a8	03 ca		 add	 ecx, edx
  008aa	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  008ad	b8 01 00 00 00	 mov	 eax, 1
  008b2	d3 e0		 shl	 eax, cl
  008b4	8b ca		 mov	 ecx, edx
  008b6	83 c6 08	 add	 esi, 8
  008b9	48		 dec	 eax
  008ba	23 c3		 and	 eax, ebx
  008bc	d3 e8		 shr	 eax, cl
  008be	0f b7 4d ee	 movzx	 ecx, WORD PTR _last$[ebp+2]
  008c2	03 c1		 add	 eax, ecx
  008c4	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  008c7	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  008ca	8b c8		 mov	 ecx, eax
  008cc	c1 e9 08	 shr	 ecx, 8
  008cf	0f b6 c9	 movzx	 ecx, cl
  008d2	03 ca		 add	 ecx, edx
  008d4	3b ce		 cmp	 ecx, esi
  008d6	77 98		 ja	 SHORT $LL109@inflateBac@3
$LN439@inflateBac@3:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  008d8	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  008dc	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  008df	d3 eb		 shr	 ebx, cl
  008e1	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  008e5	2b f1		 sub	 esi, ecx
$LN96@inflateBac@3:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  008e7	8b c8		 mov	 ecx, eax
  008e9	c1 e9 08	 shr	 ecx, 8
  008ec	0f b6 c9	 movzx	 ecx, cl
  008ef	d3 eb		 shr	 ebx, cl
  008f1	2b f1		 sub	 esi, ecx
  008f3	89 4d e8	 mov	 DWORD PTR tv1421[ebp], ecx

; 509  :             state->length = (unsigned)here.val;

  008f6	8b c8		 mov	 ecx, eax
  008f8	c1 e9 10	 shr	 ecx, 16			; 00000010H
  008fb	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  008fe	84 c0		 test	 al, al
  00900	75 43		 jne	 SHORT $LN92@inflateBac@3

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00902	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  00906	75 26		 jne	 SHORT $LN90@inflateBac@3
  00908	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0090b	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0090e	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00911	50		 push	 eax
  00912	51		 push	 ecx
  00913	52		 push	 edx
  00914	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  00917	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  0091a	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  0091d	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00920	83 c4 0c	 add	 esp, 12			; 0000000cH
  00923	85 c0		 test	 eax, eax
  00925	0f 85 29 03 00
	00		 jne	 $LN366@inflateBac@3
  0092b	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN90@inflateBac@3:

; 517  :                 *put++ = (unsigned char)(state->length);

  0092e	8a 47 40	 mov	 al, BYTE PTR [edi+64]
  00931	88 02		 mov	 BYTE PTR [edx], al
  00933	42		 inc	 edx

; 518  :                 left--;

  00934	ff 4d f0	 dec	 DWORD PTR _left$[ebp]
  00937	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx

; 519  :                 state->mode = LEN;

  0093a	c7 07 14 00 00
	00		 mov	 DWORD PTR [edi], 20	; 00000014H

; 520  :                 break;

  00940	e9 f5 02 00 00	 jmp	 $LN387@inflateBac@3
$LN92@inflateBac@3:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00945	a8 20		 test	 al, 32			; 00000020H
  00947	74 0b		 je	 SHORT $LN86@inflateBac@3

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00949	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH

; 527  :                 break;

  0094f	e9 e6 02 00 00	 jmp	 $LN387@inflateBac@3
$LN86@inflateBac@3:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00954	a8 40		 test	 al, 64			; 00000040H
  00956	74 15		 je	 SHORT $LN85@inflateBac@3

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00958	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0095b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 533  :                 state->mode = BAD;

  00962	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 534  :                 break;

  00968	e9 cd 02 00 00	 jmp	 $LN387@inflateBac@3
$LN85@inflateBac@3:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  0096d	0f b6 c0	 movzx	 eax, al
  00970	83 e0 0f	 and	 eax, 15			; 0000000fH
  00973	89 47 48	 mov	 DWORD PTR [edi+72], eax

; 539  :             if (state->extra != 0) {

  00976	74 59		 je	 SHORT $LN68@inflateBac@3

; 540  :                 NEEDBITS(state->extra);

  00978	3b f0		 cmp	 esi, eax
  0097a	73 41		 jae	 SHORT $LN82@inflateBac@3
  0097c	8d 64 24 00	 npad	 4
$LL80@inflateBac@3:
  00980	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00984	75 19		 jne	 SHORT $LN74@inflateBac@3
  00986	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00989	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  0098c	52		 push	 edx
  0098d	50		 push	 eax
  0098e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00991	83 c4 08	 add	 esp, 8
  00994	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00997	85 c0		 test	 eax, eax
  00999	0f 84 ae 02 00
	00		 je	 $LN363@inflateBac@3
$LN74@inflateBac@3:
  0099f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  009a2	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  009a5	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  009a8	8b ce		 mov	 ecx, esi
  009aa	d3 e2		 shl	 edx, cl
  009ac	40		 inc	 eax
  009ad	83 c6 08	 add	 esi, 8
  009b0	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  009b3	03 da		 add	 ebx, edx
  009b5	3b 77 48	 cmp	 esi, DWORD PTR [edi+72]
  009b8	72 c6		 jb	 SHORT $LL80@inflateBac@3
  009ba	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN82@inflateBac@3:

; 541  :                 state->length += BITS(state->extra);

  009bd	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  009c0	b8 01 00 00 00	 mov	 eax, 1
  009c5	d3 e0		 shl	 eax, cl
  009c7	48		 dec	 eax
  009c8	23 c3		 and	 eax, ebx
  009ca	01 47 40	 add	 DWORD PTR [edi+64], eax

; 542  :                 DROPBITS(state->extra);

  009cd	d3 eb		 shr	 ebx, cl
  009cf	2b f1		 sub	 esi, ecx
$LN68@inflateBac@3:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  009d1	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  009d4	b8 01 00 00 00	 mov	 eax, 1
  009d9	d3 e0		 shl	 eax, cl
  009db	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  009de	48		 dec	 eax
  009df	23 c3		 and	 eax, ebx
  009e1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  009e4	8b c8		 mov	 ecx, eax
  009e6	c1 e9 08	 shr	 ecx, 8
  009e9	0f b6 c9	 movzx	 ecx, cl
  009ec	3b ce		 cmp	 ecx, esi
  009ee	76 57		 jbe	 SHORT $LN381@inflateBac@3
$LL67@inflateBac@3:

; 550  :                 PULLBYTE();

  009f0	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  009f4	75 19		 jne	 SHORT $LN60@inflateBac@3
  009f6	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  009f9	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  009fc	52		 push	 edx
  009fd	50		 push	 eax
  009fe	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00a01	83 c4 08	 add	 esp, 8
  00a04	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00a07	85 c0		 test	 eax, eax
  00a09	0f 84 3e 02 00
	00		 je	 $LN363@inflateBac@3
$LN60@inflateBac@3:
  00a0f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00a12	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00a15	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00a18	40		 inc	 eax
  00a19	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00a1c	8b ce		 mov	 ecx, esi
  00a1e	d3 e2		 shl	 edx, cl
  00a20	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00a23	b8 01 00 00 00	 mov	 eax, 1
  00a28	d3 e0		 shl	 eax, cl
  00a2a	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00a2d	03 da		 add	 ebx, edx
  00a2f	83 c6 08	 add	 esi, 8
  00a32	48		 dec	 eax
  00a33	23 c3		 and	 eax, ebx
  00a35	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00a38	8b d0		 mov	 edx, eax
  00a3a	c1 ea 08	 shr	 edx, 8
  00a3d	0f b6 ca	 movzx	 ecx, dl
  00a40	3b ce		 cmp	 ecx, esi
  00a42	77 ac		 ja	 SHORT $LL67@inflateBac@3

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00a44	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN381@inflateBac@3:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00a47	a8 f0		 test	 al, 240			; 000000f0H
  00a49	0f 85 b9 00 00
	00		 jne	 $LN42@inflateBac@3

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00a4f	8b c8		 mov	 ecx, eax
  00a51	c1 e9 08	 shr	 ecx, 8
  00a54	0f b6 d1	 movzx	 edx, cl
  00a57	89 4d e4	 mov	 DWORD PTR tv1420[ebp], ecx
  00a5a	89 55 e8	 mov	 DWORD PTR tv1421[ebp], edx
  00a5d	0f b6 c8	 movzx	 ecx, al
  00a60	03 ca		 add	 ecx, edx
  00a62	ba 01 00 00 00	 mov	 edx, 1
  00a67	d3 e2		 shl	 edx, cl
  00a69	8b 4d e8	 mov	 ecx, DWORD PTR tv1421[ebp]
  00a6c	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  00a6f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00a72	4a		 dec	 edx
  00a73	23 d3		 and	 edx, ebx
  00a75	d3 ea		 shr	 edx, cl
  00a77	03 d0		 add	 edx, eax
  00a79	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00a7c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00a7f	8b c8		 mov	 ecx, eax
  00a81	c1 e9 08	 shr	 ecx, 8
  00a84	0f b6 d1	 movzx	 edx, cl
  00a87	0f b6 4d e4	 movzx	 ecx, BYTE PTR tv1420[ebp]
  00a8b	03 d1		 add	 edx, ecx
  00a8d	3b d6		 cmp	 edx, esi
  00a8f	76 68		 jbe	 SHORT $LN441@inflateBac@3
$LL55@inflateBac@3:

; 558  :                     PULLBYTE();

  00a91	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a95	75 19		 jne	 SHORT $LN48@inflateBac@3
  00a97	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00a9a	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00a9d	52		 push	 edx
  00a9e	50		 push	 eax
  00a9f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00aa2	83 c4 08	 add	 esp, 8
  00aa5	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00aa8	85 c0		 test	 eax, eax
  00aaa	0f 84 9d 01 00
	00		 je	 $LN363@inflateBac@3
$LN48@inflateBac@3:
  00ab0	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00ab3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00ab6	40		 inc	 eax
  00ab7	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00aba	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  00abd	8b ce		 mov	 ecx, esi
  00abf	d3 e2		 shl	 edx, cl
  00ac1	0f b6 c8	 movzx	 ecx, al
  00ac4	03 da		 add	 ebx, edx
  00ac6	0f b6 d4	 movzx	 edx, ah
  00ac9	03 ca		 add	 ecx, edx
  00acb	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00ace	b8 01 00 00 00	 mov	 eax, 1
  00ad3	d3 e0		 shl	 eax, cl
  00ad5	8b ca		 mov	 ecx, edx
  00ad7	83 c6 08	 add	 esi, 8
  00ada	48		 dec	 eax
  00adb	23 c3		 and	 eax, ebx
  00add	d3 e8		 shr	 eax, cl
  00adf	0f b7 4d ee	 movzx	 ecx, WORD PTR _last$[ebp+2]
  00ae3	03 c1		 add	 eax, ecx
  00ae5	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  00ae8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00aeb	8b c8		 mov	 ecx, eax
  00aed	c1 e9 08	 shr	 ecx, 8
  00af0	0f b6 c9	 movzx	 ecx, cl
  00af3	03 ca		 add	 ecx, edx
  00af5	3b ce		 cmp	 ecx, esi
  00af7	77 98		 ja	 SHORT $LL55@inflateBac@3
$LN441@inflateBac@3:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00af9	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00afd	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00b00	d3 eb		 shr	 ebx, cl
  00b02	0f b6 4d ed	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00b06	2b f1		 sub	 esi, ecx
$LN42@inflateBac@3:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00b08	8b c8		 mov	 ecx, eax
  00b0a	c1 e9 08	 shr	 ecx, 8
  00b0d	0f b6 c9	 movzx	 ecx, cl
  00b10	d3 eb		 shr	 ebx, cl
  00b12	2b f1		 sub	 esi, ecx
  00b14	89 4d e8	 mov	 DWORD PTR tv1421[ebp], ecx

; 563  :             if (here.op & 64) {

  00b17	a8 40		 test	 al, 64			; 00000040H
  00b19	74 15		 je	 SHORT $LN38@inflateBac@3

; 564  :                 strm->msg = (char *)"invalid distance code";

  00b1b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b1e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 565  :                 state->mode = BAD;

  00b25	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 566  :                 break;

  00b2b	e9 0a 01 00 00	 jmp	 $LN387@inflateBac@3
$LN38@inflateBac@3:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00b30	8b c8		 mov	 ecx, eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00b32	0f b6 c0	 movzx	 eax, al
  00b35	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00b38	83 e0 0f	 and	 eax, 15			; 0000000fH
  00b3b	89 4f 44	 mov	 DWORD PTR [edi+68], ecx
  00b3e	89 47 48	 mov	 DWORD PTR [edi+72], eax

; 572  :             if (state->extra != 0) {

  00b41	74 55		 je	 SHORT $LN21@inflateBac@3

; 573  :                 NEEDBITS(state->extra);

  00b43	3b f0		 cmp	 esi, eax
  00b45	73 3d		 jae	 SHORT $LN35@inflateBac@3
$LL33@inflateBac@3:
  00b47	83 7d fc 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b4b	75 19		 jne	 SHORT $LN27@inflateBac@3
  00b4d	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00b50	8d 55 f8	 lea	 edx, DWORD PTR _next$[ebp]
  00b53	52		 push	 edx
  00b54	50		 push	 eax
  00b55	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00b58	83 c4 08	 add	 esp, 8
  00b5b	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax
  00b5e	85 c0		 test	 eax, eax
  00b60	0f 84 e7 00 00
	00		 je	 $LN363@inflateBac@3
$LN27@inflateBac@3:
  00b66	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00b69	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00b6c	ff 4d fc	 dec	 DWORD PTR _have$[ebp]
  00b6f	8b ce		 mov	 ecx, esi
  00b71	d3 e2		 shl	 edx, cl
  00b73	40		 inc	 eax
  00b74	83 c6 08	 add	 esi, 8
  00b77	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00b7a	03 da		 add	 ebx, edx
  00b7c	3b 77 48	 cmp	 esi, DWORD PTR [edi+72]
  00b7f	72 c6		 jb	 SHORT $LL33@inflateBac@3
  00b81	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN35@inflateBac@3:

; 574  :                 state->offset += BITS(state->extra);

  00b84	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00b87	b8 01 00 00 00	 mov	 eax, 1
  00b8c	d3 e0		 shl	 eax, cl
  00b8e	48		 dec	 eax
  00b8f	23 c3		 and	 eax, ebx
  00b91	01 47 44	 add	 DWORD PTR [edi+68], eax

; 575  :                 DROPBITS(state->extra);

  00b94	d3 eb		 shr	 ebx, cl
  00b96	2b f1		 sub	 esi, ecx
$LN21@inflateBac@3:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  00b98	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00b9b	39 47 2c	 cmp	 DWORD PTR [edi+44], eax
  00b9e	1b c9		 sbb	 ecx, ecx
  00ba0	23 4d f0	 and	 ecx, DWORD PTR _left$[ebp]
  00ba3	2b c1		 sub	 eax, ecx
  00ba5	39 47 44	 cmp	 DWORD PTR [edi+68], eax
  00ba8	76 16		 jbe	 SHORT $LL19@inflateBac@3

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00baa	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bad	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;

  00bb4	c7 07 1d 00 00
	00		 mov	 DWORD PTR [edi], 29	; 0000001dH

; 581  :                 break;

  00bba	eb 7e		 jmp	 SHORT $LN387@inflateBac@3
  00bbc	8d 64 24 00	 npad	 4
$LL19@inflateBac@3:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00bc0	83 7d f0 00	 cmp	 DWORD PTR _left$[ebp], 0
  00bc4	75 22		 jne	 SHORT $LN15@inflateBac@3
  00bc6	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00bc9	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00bcc	50		 push	 eax
  00bcd	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax
  00bd0	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  00bd3	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00bd6	51		 push	 ecx
  00bd7	50		 push	 eax
  00bd8	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  00bdb	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00bde	83 c4 0c	 add	 esp, 12			; 0000000cH
  00be1	85 c0		 test	 eax, eax
  00be3	75 6f		 jne	 SHORT $LN366@inflateBac@3
  00be5	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
$LN15@inflateBac@3:

; 588  :                 copy = state->wsize - state->offset;

  00be8	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00beb	2b 4f 44	 sub	 ecx, DWORD PTR [edi+68]

; 589  :                 if (copy < left) {

  00bee	3b 4d f0	 cmp	 ecx, DWORD PTR _left$[ebp]
  00bf1	73 0d		 jae	 SHORT $LN11@inflateBac@3

; 590  :                     from = put + copy;

  00bf3	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00bf6	89 45 e4	 mov	 DWORD PTR _from$[ebp], eax

; 591  :                     copy = left - copy;

  00bf9	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
  00bfc	2b c1		 sub	 eax, ecx

; 592  :                 }
; 593  :                 else {

  00bfe	eb 0b		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 594  :                     from = put - state->offset;

  00c00	8b c2		 mov	 eax, edx
  00c02	2b 47 44	 sub	 eax, DWORD PTR [edi+68]
  00c05	89 45 e4	 mov	 DWORD PTR _from$[ebp], eax

; 595  :                     copy = left;

  00c08	8b 45 f0	 mov	 eax, DWORD PTR _left$[ebp]
$LN10@inflateBac@3:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00c0b	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00c0e	3b c1		 cmp	 eax, ecx
  00c10	76 02		 jbe	 SHORT $LN9@inflateBac@3
  00c12	8b c1		 mov	 eax, ecx
$LN9@inflateBac@3:

; 598  :                 state->length -= copy;
; 599  :                 left -= copy;

  00c14	29 45 f0	 sub	 DWORD PTR _left$[ebp], eax
  00c17	2b c8		 sub	 ecx, eax
  00c19	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 602  :                 } while (--copy);

  00c1c	8b 4d e4	 mov	 ecx, DWORD PTR _from$[ebp]
  00c1f	2b ca		 sub	 ecx, edx
  00c21	89 4d e4	 mov	 DWORD PTR tv1911[ebp], ecx
  00c24	eb 03		 jmp	 SHORT $LN8@inflateBac@3
$LL443@inflateBac@3:
  00c26	8b 4d e4	 mov	 ecx, DWORD PTR tv1911[ebp]
$LN8@inflateBac@3:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00c29	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00c2c	88 0a		 mov	 BYTE PTR [edx], cl
  00c2e	42		 inc	 edx

; 602  :                 } while (--copy);

  00c2f	48		 dec	 eax
  00c30	75 f4		 jne	 SHORT $LL443@inflateBac@3

; 603  :             } while (state->length != 0);

  00c32	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx
  00c35	39 47 40	 cmp	 DWORD PTR [edi+64], eax
  00c38	75 86		 jne	 SHORT $LL19@inflateBac@3
$LN387@inflateBac@3:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00c3a	8b 07		 mov	 eax, DWORD PTR [edi]
  00c3c	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00c3f	83 f8 12	 cmp	 eax, 18			; 00000012H
  00c42	0f 86 38 f4 ff
	ff		 jbe	 $LL420@inflateBac@3

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00c48	e9 0f f4 ff ff	 jmp	 $LN1@inflateBac@3
$LN363@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  00c4d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN366@inflateBac@3:
  00c54	be fb ff ff ff	 mov	 esi, -5			; fffffffbH
  00c59	e9 03 f4 ff ff	 jmp	 $inf_leave$80453
$LN365@inflateBac@3:

; 343  :                 PULL();

  00c5e	89 5d f8	 mov	 DWORD PTR _next$[ebp], ebx
  00c61	be fb ff ff ff	 mov	 esi, -5			; fffffffbH
  00c66	e9 f6 f3 ff ff	 jmp	 $inf_leave$80453
$LN5@inflateBac@3:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00c6b	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00c6e	be 01 00 00 00	 mov	 esi, 1
  00c73	39 45 f0	 cmp	 DWORD PTR _left$[ebp], eax
  00c76	0f 83 e5 f3 ff
	ff		 jae	 $inf_leave$80453

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00c7c	2b 45 f0	 sub	 eax, DWORD PTR _left$[ebp]
  00c7f	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00c82	50		 push	 eax
  00c83	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00c86	52		 push	 edx
  00c87	50		 push	 eax
  00c88	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00c8b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c8e	85 c0		 test	 eax, eax
  00c90	0f 84 cb f3 ff
	ff		 je	 $inf_leave$80453

; 611  :                     ret = Z_BUF_ERROR;

  00c96	be fb ff ff ff	 mov	 esi, -5			; fffffffbH

; 612  :             }
; 613  :             goto inf_leave;

  00c9b	e9 c1 f3 ff ff	 jmp	 $inf_leave$80453
$LN2@inflateBac@3:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00ca0	be fd ff ff ff	 mov	 esi, -3			; fffffffdH

; 617  :             goto inf_leave;

  00ca5	e9 b7 f3 ff ff	 jmp	 $inf_leave$80453
$LN333@inflateBac@3:
  00caa	5f		 pop	 edi

; 274  :         return Z_STREAM_ERROR;

  00cab	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00cb0	5e		 pop	 esi

; 629  : }

  00cb1	8b e5		 mov	 esp, ebp
  00cb3	5d		 pop	 ebp
  00cb4	c2 14 00	 ret	 20			; 00000014H
  00cb7	90		 npad	 1
$LN460@inflateBac@3:
  00cb8	00 00 00 00	 DD	 $LN328@inflateBac@3
  00cbc	00 00 00 00	 DD	 $LN297@inflateBac@3
  00cc0	00 00 00 00	 DD	 $LN262@inflateBac@3
  00cc4	00 00 00 00	 DD	 $LN130@inflateBac@3
  00cc8	00 00 00 00	 DD	 $LN5@inflateBac@3
  00ccc	00 00 00 00	 DD	 $LN2@inflateBac@3
  00cd0	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN414@inflateBac@3:
  00cd4	00		 DB	 0
  00cd5	06		 DB	 6
  00cd6	01		 DB	 1
  00cd7	06		 DB	 6
  00cd8	06		 DB	 6
  00cd9	02		 DB	 2
  00cda	06		 DB	 6
  00cdb	06		 DB	 6
  00cdc	06		 DB	 6
  00cdd	03		 DB	 3
  00cde	06		 DB	 6
  00cdf	06		 DB	 6
  00ce0	06		 DB	 6
  00ce1	06		 DB	 6
  00ce2	06		 DB	 6
  00ce3	06		 DB	 6
  00ce4	06		 DB	 6
  00ce5	04		 DB	 4
  00ce6	05		 DB	 5
  00ce7	90		 npad	 1
$LN461@inflateBac@3:
  00ce8	00 00 00 00	 DD	 $LN305@inflateBac@3
  00cec	00 00 00 00	 DD	 $LN304@inflateBac@3
  00cf0	00 00 00 00	 DD	 $LN303@inflateBac@3
  00cf4	00 00 00 00	 DD	 $LN302@inflateBac@3
_inflateBack@20 ENDP
END
