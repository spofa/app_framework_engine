; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\yyh\Downloads\zlib-1.2.8\zlib-1.2.8\deflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_deflate_copyright
EXTRN	_match_init:PROC
EXTRN	_longest_match:PROC
	ORG $+2
_deflate_copyright DB ' deflate 1.2.8 Copyright 1995-2013 Jean-loup Gaill'
	DB	'y and Mark Adler ', 00H
	ORG $+4
_configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DD	FLAT:_deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DD	FLAT:_deflate_slow
?my_version@?1??deflateInit2_@@9@9 DB '1.2.8', 00H	; `deflateInit2_'::`2'::my_version
; Function compile flags: /Ogtp
; File c:\users\yyh\downloads\zlib-1.2.8\zlib-1.2.8\deflate.c
;	COMDAT _lm_init
_TEXT	SEGMENT
_lm_init PROC						; COMDAT
; _s$ = esi

; 1109 :     s->window_size = (ulg)2L*s->w_size;

  00000	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]

; 1110 : 
; 1111 :     CLEAR_HASH(s);

  00003	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00006	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00009	03 c0		 add	 eax, eax
  0000b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0000e	33 c0		 xor	 eax, eax
  00010	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  00015	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00018	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0001b	57		 push	 edi
  0001c	8d 54 09 fe	 lea	 edx, DWORD PTR [ecx+ecx-2]
  00020	52		 push	 edx
  00021	33 ff		 xor	 edi, edi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset

; 1112 : 
; 1113 :     /* Set the default configuration parameters:
; 1114 :      */
; 1115 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  0002a	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00030	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00033	03 c0		 add	 eax, eax
  00035	0f b7 8c 00 02
	00 00 00	 movzx	 ecx, WORD PTR _configuration_table[eax+eax+2]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	03 c0		 add	 eax, eax
  00042	89 8e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ecx

; 1116 :     s->good_match       = configuration_table[s->level].good_length;

  00048	0f b7 90 00 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[eax]
  0004f	89 96 8c 00 00
	00		 mov	 DWORD PTR [esi+140], edx

; 1117 :     s->nice_match       = configuration_table[s->level].nice_length;

  00055	0f b7 88 04 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[eax+4]
  0005c	89 8e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ecx

; 1118 :     s->max_chain_length = configuration_table[s->level].max_chain;

  00062	0f b7 90 06 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[eax+6]

; 1119 : 
; 1120 :     s->strstart = 0;
; 1121 :     s->block_start = 0L;
; 1122 :     s->lookahead = 0;
; 1123 :     s->insert = 0;
; 1124 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00069	b8 02 00 00 00	 mov	 eax, 2
  0006e	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  00071	89 7e 5c	 mov	 DWORD PTR [esi+92], edi
  00074	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  00077	89 be b4 16 00
	00		 mov	 DWORD PTR [esi+5812], edi

; 1125 :     s->match_available = 0;

  0007d	89 7e 68	 mov	 DWORD PTR [esi+104], edi

; 1126 :     s->ins_h = 0;

  00080	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  00083	89 56 7c	 mov	 DWORD PTR [esi+124], edx
  00086	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00089	89 46 60	 mov	 DWORD PTR [esi+96], eax
  0008c	5f		 pop	 edi

; 1127 : #ifndef FASTEST
; 1128 : #ifdef ASMV
; 1129 :     match_init(); /* initialize the asm code */

  0008d	e9 00 00 00 00	 jmp	 _match_init
_lm_init ENDP
_TEXT	ENDS
PUBLIC	_deflateEnd@4
; Function compile flags: /Ogtp
;	COMDAT _deflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateEnd@4 PROC					; COMDAT

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 982  :     int status;
; 983  : 
; 984  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 c2 00 00
	00		 je	 $LN6@deflateEnd
  0000f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00012	85 c0		 test	 eax, eax
  00014	0f 84 b7 00 00
	00		 je	 $LN6@deflateEnd

; 985  : 
; 986  :     status = strm->state->status;

  0001a	57		 push	 edi
  0001b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 987  :     if (status != INIT_STATE &&
; 988  :         status != EXTRA_STATE &&
; 989  :         status != NAME_STATE &&
; 990  :         status != COMMENT_STATE &&
; 991  :         status != HCRC_STATE &&
; 992  :         status != BUSY_STATE &&
; 993  :         status != FINISH_STATE) {

  0001e	83 ff 2a	 cmp	 edi, 42			; 0000002aH
  00021	74 2c		 je	 SHORT $LN5@deflateEnd
  00023	83 ff 45	 cmp	 edi, 69			; 00000045H
  00026	74 27		 je	 SHORT $LN5@deflateEnd
  00028	83 ff 49	 cmp	 edi, 73			; 00000049H
  0002b	74 22		 je	 SHORT $LN5@deflateEnd
  0002d	83 ff 5b	 cmp	 edi, 91			; 0000005bH
  00030	74 1d		 je	 SHORT $LN5@deflateEnd
  00032	83 ff 67	 cmp	 edi, 103		; 00000067H
  00035	74 18		 je	 SHORT $LN5@deflateEnd
  00037	83 ff 71	 cmp	 edi, 113		; 00000071H
  0003a	74 13		 je	 SHORT $LN5@deflateEnd
  0003c	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  00042	74 0b		 je	 SHORT $LN5@deflateEnd

; 994  :       return Z_STREAM_ERROR;

  00044	5f		 pop	 edi
  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	5e		 pop	 esi

; 1007 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN5@deflateEnd:

; 995  :     }
; 996  : 
; 997  :     /* Deallocate in reverse order of allocations: */
; 998  :     TRY_FREE(strm, strm->state->pending_buf);

  0004f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00052	85 c0		 test	 eax, eax
  00054	74 0d		 je	 SHORT $LN4@deflateEnd
  00056	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00059	50		 push	 eax
  0005a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0005d	50		 push	 eax
  0005e	ff d1		 call	 ecx
  00060	83 c4 08	 add	 esp, 8
$LN4@deflateEnd:

; 999  :     TRY_FREE(strm, strm->state->head);

  00063	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00066	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00069	85 c0		 test	 eax, eax
  0006b	74 0d		 je	 SHORT $LN3@deflateEnd
  0006d	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00070	50		 push	 eax
  00071	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00074	50		 push	 eax
  00075	ff d1		 call	 ecx
  00077	83 c4 08	 add	 esp, 8
$LN3@deflateEnd:

; 1000 :     TRY_FREE(strm, strm->state->prev);

  0007a	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0007d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00080	85 c0		 test	 eax, eax
  00082	74 0d		 je	 SHORT $LN2@deflateEnd
  00084	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00087	50		 push	 eax
  00088	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0008b	50		 push	 eax
  0008c	ff d1		 call	 ecx
  0008e	83 c4 08	 add	 esp, 8
$LN2@deflateEnd:

; 1001 :     TRY_FREE(strm, strm->state->window);

  00091	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00094	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00097	85 c0		 test	 eax, eax
  00099	74 0d		 je	 SHORT $LN1@deflateEnd
  0009b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0009e	50		 push	 eax
  0009f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000a2	50		 push	 eax
  000a3	ff d1		 call	 ecx
  000a5	83 c4 08	 add	 esp, 8
$LN1@deflateEnd:

; 1002 : 
; 1003 :     ZFREE(strm, strm->state);

  000a8	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  000ab	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000ae	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000b1	52		 push	 edx
  000b2	50		 push	 eax
  000b3	ff d1		 call	 ecx
  000b5	83 c4 08	 add	 esp, 8

; 1004 :     strm->state = Z_NULL;
; 1005 : 
; 1006 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000b8	33 c0		 xor	 eax, eax
  000ba	83 ff 71	 cmp	 edi, 113		; 00000071H
  000bd	0f 95 c0	 setne	 al
  000c0	5f		 pop	 edi
  000c1	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  000c8	5e		 pop	 esi
  000c9	48		 dec	 eax
  000ca	83 e0 fd	 and	 eax, -3			; fffffffdH

; 1007 : }

  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
$LN6@deflateEnd:

; 982  :     int status;
; 983  : 
; 984  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000d1	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000d6	5e		 pop	 esi

; 1007 : }

  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
_deflateEnd@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _flush_pending
_TEXT	SEGMENT
_flush_pending PROC					; COMDAT
; _strm$ = edi

; 644  : {

  00000	53		 push	 ebx

; 645  :     unsigned len;
; 646  :     deflate_state *s = strm->state;

  00001	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00004	56		 push	 esi

; 647  : 
; 648  :     _tr_flush_bits(s);

  00005	8b c3		 mov	 eax, ebx
  00007	e8 00 00 00 00	 call	 __tr_flush_bits

; 649  :     len = s->pending;

  0000c	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 650  :     if (len > strm->avail_out) len = strm->avail_out;

  0000f	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00012	3b f0		 cmp	 esi, eax
  00014	76 02		 jbe	 SHORT $LN3@flush_pend
  00016	8b f0		 mov	 esi, eax
$LN3@flush_pend:

; 651  :     if (len == 0) return;

  00018	85 f6		 test	 esi, esi
  0001a	74 28		 je	 SHORT $LN1@flush_pend

; 652  : 
; 653  :     zmemcpy(strm->next_out, s->pending_out, len);

  0001c	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0001f	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _memcpy

; 654  :     strm->next_out  += len;

  0002a	01 77 0c	 add	 DWORD PTR [edi+12], esi

; 655  :     s->pending_out  += len;

  0002d	01 73 10	 add	 DWORD PTR [ebx+16], esi

; 656  :     strm->total_out += len;

  00030	01 77 14	 add	 DWORD PTR [edi+20], esi

; 657  :     strm->avail_out  -= len;

  00033	29 77 10	 sub	 DWORD PTR [edi+16], esi
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 658  :     s->pending -= len;

  00039	29 73 14	 sub	 DWORD PTR [ebx+20], esi

; 659  :     if (s->pending == 0) {

  0003c	75 06		 jne	 SHORT $LN1@flush_pend

; 660  :         s->pending_out = s->pending_buf;

  0003e	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00041	89 53 10	 mov	 DWORD PTR [ebx+16], edx
$LN1@flush_pend:

; 661  :     }
; 662  : }

  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	c3		 ret	 0
_flush_pending ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _putShortMSB
_TEXT	SEGMENT
_putShortMSB PROC					; COMDAT
; _s$ = eax
; _b$ = ecx

; 631  : {

  00000	56		 push	 esi

; 632  :     put_byte(s, (Byte)(b >> 8));

  00001	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00004	57		 push	 edi
  00005	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  00008	8b d1		 mov	 edx, ecx
  0000a	c1 ea 08	 shr	 edx, 8
  0000d	88 14 3e	 mov	 BYTE PTR [esi+edi], dl

; 633  :     put_byte(s, (Byte)(b & 0xff));

  00010	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00013	be 01 00 00 00	 mov	 esi, 1
  00018	01 70 14	 add	 DWORD PTR [eax+20], esi
  0001b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0001e	88 0c 3a	 mov	 BYTE PTR [edx+edi], cl
  00021	01 70 14	 add	 DWORD PTR [eax+20], esi
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 634  : }

  00026	c3		 ret	 0
_putShortMSB ENDP
_TEXT	ENDS
PUBLIC	_deflateBound@8
; Function compile flags: /Ogtp
;	COMDAT _deflateBound@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_complen$ = 12						; size = 4
_sourceLen$ = 12					; size = 4
_deflateBound@8 PROC					; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 570  :     deflate_state *s;
; 571  :     uLong complen, wraplen;
; 572  :     Bytef *str;
; 573  : 
; 574  :     /* conservative upper bound for compressed data */
; 575  :     complen = sourceLen +
; 576  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _sourceLen$[ebp]
  00006	8d 42 3f	 lea	 eax, DWORD PTR [edx+63]
  00009	c1 e8 06	 shr	 eax, 6
  0000c	8d 4a 07	 lea	 ecx, DWORD PTR [edx+7]
  0000f	03 c2		 add	 eax, edx
  00011	c1 e9 03	 shr	 ecx, 3
  00014	8d 4c 01 05	 lea	 ecx, DWORD PTR [ecx+eax+5]

; 577  : 
; 578  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 579  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00018	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0001b	57		 push	 edi
  0001c	89 4d 0c	 mov	 DWORD PTR _complen$[ebp], ecx
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 ac 00 00
	00		 je	 $LN20@deflateBou
  00027	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0002a	85 ff		 test	 edi, edi
  0002c	0f 84 a1 00 00
	00		 je	 $LN20@deflateBou

; 581  : 
; 582  :     /* compute wrapper length */
; 583  :     s = strm->state;
; 584  :     switch (s->wrap) {

  00032	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00035	83 e8 00	 sub	 eax, 0
  00038	56		 push	 esi
  00039	74 5f		 je	 SHORT $LN17@deflateBou
  0003b	48		 dec	 eax
  0003c	74 4d		 je	 SHORT $LN16@deflateBou
  0003e	48		 dec	 eax
  0003f	74 07		 je	 SHORT $LN15@deflateBou

; 610  :     default:                                /* for compiler happiness */
; 611  :         wraplen = 6;

  00041	b8 06 00 00 00	 mov	 eax, 6
  00046	eb 54		 jmp	 SHORT $LN28@deflateBou
$LN15@deflateBou:

; 591  :     case 2:                                 /* gzip wrapper */
; 592  :         wraplen = 18;
; 593  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  00048	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  0004b	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  00050	85 f6		 test	 esi, esi
  00052	74 48		 je	 SHORT $LN28@deflateBou

; 594  :             if (s->gzhead->extra != Z_NULL)

  00054	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00058	74 06		 je	 SHORT $LN13@deflateBou

; 595  :                 wraplen += 2 + s->gzhead->extra_len;

  0005a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005d	83 c0 14	 add	 eax, 20			; 00000014H
$LN13@deflateBou:

; 596  :             str = s->gzhead->name;

  00060	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00063	53		 push	 ebx

; 597  :             if (str != Z_NULL)

  00064	85 c9		 test	 ecx, ecx
  00066	74 08		 je	 SHORT $LN9@deflateBou
$LL11@deflateBou:

; 598  :                 do {
; 599  :                     wraplen++;
; 600  :                 } while (*str++);

  00068	8a 19		 mov	 bl, BYTE PTR [ecx]
  0006a	40		 inc	 eax
  0006b	41		 inc	 ecx
  0006c	84 db		 test	 bl, bl
  0006e	75 f8		 jne	 SHORT $LL11@deflateBou
$LN9@deflateBou:

; 601  :             str = s->gzhead->comment;

  00070	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]

; 602  :             if (str != Z_NULL)

  00073	85 c9		 test	 ecx, ecx
  00075	74 08		 je	 SHORT $LN5@deflateBou
$LL7@deflateBou:

; 603  :                 do {
; 604  :                     wraplen++;
; 605  :                 } while (*str++);

  00077	8a 19		 mov	 bl, BYTE PTR [ecx]
  00079	40		 inc	 eax
  0007a	41		 inc	 ecx
  0007b	84 db		 test	 bl, bl
  0007d	75 f8		 jne	 SHORT $LL7@deflateBou
$LN5@deflateBou:

; 606  :             if (s->gzhead->hcrc)

  0007f	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00083	5b		 pop	 ebx
  00084	74 16		 je	 SHORT $LN28@deflateBou

; 607  :                 wraplen += 2;

  00086	83 c0 02	 add	 eax, 2

; 608  :         }
; 609  :         break;

  00089	eb 11		 jmp	 SHORT $LN28@deflateBou
$LN16@deflateBou:

; 587  :         break;
; 588  :     case 1:                                 /* zlib wrapper */
; 589  :         wraplen = 6 + (s->strstart ? 4 : 0);

  0008b	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  0008e	f7 d8		 neg	 eax
  00090	1b c0		 sbb	 eax, eax
  00092	83 e0 04	 and	 eax, 4
  00095	83 c0 06	 add	 eax, 6

; 590  :         break;

  00098	eb 02		 jmp	 SHORT $LN28@deflateBou
$LN17@deflateBou:

; 585  :     case 0:                                 /* raw deflate */
; 586  :         wraplen = 0;

  0009a	33 c0		 xor	 eax, eax
$LN28@deflateBou:

; 612  :     }
; 613  : 
; 614  :     /* if not default parameters, return conservative bound */
; 615  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  0009c	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000a1	39 4f 30	 cmp	 DWORD PTR [edi+48], ecx
  000a4	75 24		 jne	 SHORT $LN1@deflateBou
  000a6	39 4f 50	 cmp	 DWORD PTR [edi+80], ecx
  000a9	75 1f		 jne	 SHORT $LN1@deflateBou

; 617  : 
; 618  :     /* default settings: return tight bound for that case */
; 619  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 620  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  000ab	8b f2		 mov	 esi, edx
  000ad	c1 ee 0e	 shr	 esi, 14			; 0000000eH
  000b0	03 f0		 add	 esi, eax
  000b2	8b ca		 mov	 ecx, edx
  000b4	c1 e9 19	 shr	 ecx, 25			; 00000019H
  000b7	8b c2		 mov	 eax, edx
  000b9	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000bc	03 f1		 add	 esi, ecx
  000be	03 c6		 add	 eax, esi
  000c0	5e		 pop	 esi
  000c1	8d 44 10 07	 lea	 eax, DWORD PTR [eax+edx+7]
  000c5	5f		 pop	 edi

; 621  : }

  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8
$LN1@deflateBou:

; 616  :         return complen + wraplen;

  000ca	03 45 0c	 add	 eax, DWORD PTR _complen$[ebp]
  000cd	5e		 pop	 esi
  000ce	5f		 pop	 edi

; 621  : }

  000cf	5d		 pop	 ebp
  000d0	c2 08 00	 ret	 8
$LN20@deflateBou:

; 580  :         return complen + 6;

  000d3	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  000d6	5f		 pop	 edi

; 621  : }

  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_deflateBound@8 ENDP
_TEXT	ENDS
PUBLIC	_deflateTune@20
; Function compile flags: /Ogtp
;	COMDAT _deflateTune@20
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_good_length$ = 12					; size = 4
_max_lazy$ = 16						; size = 4
_nice_length$ = 20					; size = 4
_max_chain$ = 24					; size = 4
_deflateTune@20 PROC					; COMDAT

; 537  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 538  :     deflate_state *s;
; 539  : 
; 540  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2e		 je	 SHORT $LN1@deflateTun
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 27		 je	 SHORT $LN1@deflateTun

; 541  :     s = strm->state;
; 542  :     s->good_match = good_length;

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _good_length$[ebp]

; 543  :     s->max_lazy_match = max_lazy;

  00014	8b 55 10	 mov	 edx, DWORD PTR _max_lazy$[ebp]
  00017	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 544  :     s->nice_match = nice_length;

  0001d	8b 4d 14	 mov	 ecx, DWORD PTR _nice_length$[ebp]
  00020	89 90 80 00 00
	00		 mov	 DWORD PTR [eax+128], edx

; 545  :     s->max_chain_length = max_chain;

  00026	8b 55 18	 mov	 edx, DWORD PTR _max_chain$[ebp]
  00029	89 88 90 00 00
	00		 mov	 DWORD PTR [eax+144], ecx
  0002f	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 546  :     return Z_OK;

  00032	33 c0		 xor	 eax, eax

; 547  : }

  00034	5d		 pop	 ebp
  00035	c2 14 00	 ret	 20			; 00000014H
$LN1@deflateTun:

; 538  :     deflate_state *s;
; 539  : 
; 540  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 547  : }

  0003d	5d		 pop	 ebp
  0003e	c2 14 00	 ret	 20			; 00000014H
_deflateTune@20 ENDP
_TEXT	ENDS
PUBLIC	_deflatePrime@12
; Function compile flags: /Ogtp
;	COMDAT _deflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_deflatePrime@12 PROC					; COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 469  :     deflate_state *s;
; 470  :     int put;
; 471  : 
; 472  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 74		 je	 SHORT $LN6@deflatePri
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 6d		 je	 SHORT $LN6@deflatePri

; 473  :     s = strm->state;
; 474  :     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))

  00011	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00014	83 c1 02	 add	 ecx, 2
  00017	39 88 a4 16 00
	00		 cmp	 DWORD PTR [eax+5796], ecx
  0001d	73 09		 jae	 SHORT $LN10@deflatePri

; 475  :         return Z_BUF_ERROR;

  0001f	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH

; 487  : }

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
$LN10@deflatePri:
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi

; 475  :         return Z_BUF_ERROR;

  0002b	8b 7d 0c	 mov	 edi, DWORD PTR _bits$[ebp]
  0002e	8b ff		 npad	 2
$LL4@deflatePri:

; 476  :     do {
; 477  :         put = Buf_size - s->bi_valid;

  00030	8b 90 bc 16 00
	00		 mov	 edx, DWORD PTR [eax+5820]
  00036	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  0003b	2b f2		 sub	 esi, edx

; 478  :         if (put > bits)

  0003d	3b f7		 cmp	 esi, edi
  0003f	7e 02		 jle	 SHORT $LN1@deflatePri

; 479  :             put = bits;

  00041	8b f7		 mov	 esi, edi
$LN1@deflatePri:

; 480  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  00043	8b ce		 mov	 ecx, esi
  00045	bb 01 00 00 00	 mov	 ebx, 1
  0004a	66 d3 e3	 shl	 bx, cl
  0004d	8b ca		 mov	 ecx, edx

; 481  :         s->bi_valid += put;

  0004f	03 d6		 add	 edx, esi
  00051	89 90 bc 16 00
	00		 mov	 DWORD PTR [eax+5820], edx
  00057	66 4b		 dec	 bx
  00059	66 23 5d 10	 and	 bx, WORD PTR _value$[ebp]
  0005d	66 d3 e3	 shl	 bx, cl
  00060	66 09 98 b8 16
	00 00		 or	 WORD PTR [eax+5816], bx

; 482  :         _tr_flush_bits(s);

  00067	e8 00 00 00 00	 call	 __tr_flush_bits

; 483  :         value >>= put;

  0006c	8b ce		 mov	 ecx, esi
  0006e	d3 7d 10	 sar	 DWORD PTR _value$[ebp], cl

; 484  :         bits -= put;

  00071	2b fe		 sub	 edi, esi

; 485  :     } while (bits);

  00073	75 bb		 jne	 SHORT $LL4@deflatePri

; 486  :     return Z_OK;

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 487  : }

  0007a	5d		 pop	 ebp
  0007b	c2 0c 00	 ret	 12			; 0000000cH
$LN6@deflatePri:

; 469  :     deflate_state *s;
; 470  :     int put;
; 471  : 
; 472  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 487  : }

  00083	5d		 pop	 ebp
  00084	c2 0c 00	 ret	 12			; 0000000cH
_deflatePrime@12 ENDP
_TEXT	ENDS
PUBLIC	_deflatePending@12
; Function compile flags: /Ogtp
;	COMDAT _deflatePending@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_pending$ = 12						; size = 4
_bits$ = 16						; size = 4
_deflatePending@12 PROC					; COMDAT

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 455  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 2b		 je	 SHORT $LN3@deflatePen
  0000a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 24		 je	 SHORT $LN3@deflatePen

; 456  :     if (pending != Z_NULL)

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _pending$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN2@deflatePen

; 457  :         *pending = strm->state->pending;

  00018	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@deflatePen:

; 458  :     if (bits != Z_NULL)

  0001d	8b 45 10	 mov	 eax, DWORD PTR _bits$[ebp]
  00020	85 c0		 test	 eax, eax
  00022	74 0b		 je	 SHORT $LN1@deflatePen

; 459  :         *bits = strm->state->bi_valid;

  00024	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00027	8b 91 bc 16 00
	00		 mov	 edx, DWORD PTR [ecx+5820]
  0002d	89 10		 mov	 DWORD PTR [eax], edx
$LN1@deflatePen:

; 460  :     return Z_OK;

  0002f	33 c0		 xor	 eax, eax

; 461  : }

  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
$LN3@deflatePen:

; 455  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 461  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
_deflatePending@12 ENDP
_TEXT	ENDS
PUBLIC	_deflateSetHeader@8
; Function compile flags: /Ogtp
;	COMDAT _deflateSetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_deflateSetHeader@8 PROC				; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 19		 je	 SHORT $LN2@deflateSet
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 12		 je	 SHORT $LN2@deflateSet

; 444  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  00011	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  00015	75 0c		 jne	 SHORT $LN2@deflateSet

; 445  :     strm->state->gzhead = head;

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  0001a	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 446  :     return Z_OK;

  0001d	33 c0		 xor	 eax, eax

; 447  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
$LN2@deflateSet:

; 443  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00023	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 447  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
_deflateSetHeader@8 ENDP
; Function compile flags: /Ogtp
;	COMDAT _read_buf
_TEXT	SEGMENT
_read_buf PROC						; COMDAT
; _strm$ = esi
; _buf$ = ebx
; _size$ = ecx

; 1081 :     unsigned len = strm->avail_in;

  00000	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00003	57		 push	 edi
  00004	8b f8		 mov	 edi, eax

; 1082 : 
; 1083 :     if (len > size) len = size;

  00006	3b f9		 cmp	 edi, ecx
  00008	76 02		 jbe	 SHORT $LN5@read_buf
  0000a	8b f9		 mov	 edi, ecx
$LN5@read_buf:

; 1084 :     if (len == 0) return 0;

  0000c	85 ff		 test	 edi, edi
  0000e	75 04		 jne	 SHORT $LN4@read_buf
  00010	33 c0		 xor	 eax, eax
  00012	5f		 pop	 edi

; 1101 : }

  00013	c3		 ret	 0
$LN4@read_buf:

; 1085 : 
; 1086 :     strm->avail_in  -= len;

  00014	2b c7		 sub	 eax, edi
  00016	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1087 : 
; 1088 :     zmemcpy(buf, strm->next_in, len);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	57		 push	 edi
  0001c	50		 push	 eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 _memcpy

; 1089 :     if (strm->state->wrap == 1) {

  00023	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00026	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	75 17		 jne	 SHORT $LN3@read_buf

; 1090 :         strm->adler = adler32(strm->adler, buf, len);

  00031	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00034	57		 push	 edi
  00035	53		 push	 ebx
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _adler32@12

; 1095 :     }
; 1096 : #endif
; 1097 :     strm->next_in  += len;

  0003c	01 3e		 add	 DWORD PTR [esi], edi

; 1098 :     strm->total_in += len;

  0003e	01 7e 08	 add	 DWORD PTR [esi+8], edi
  00041	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 1099 : 
; 1100 :     return (int)len;

  00044	8b c7		 mov	 eax, edi
  00046	5f		 pop	 edi

; 1101 : }

  00047	c3		 ret	 0
$LN3@read_buf:

; 1091 :     }
; 1092 : #ifdef GZIP
; 1093 :     else if (strm->state->wrap == 2) {

  00048	83 f8 02	 cmp	 eax, 2
  0004b	75 0e		 jne	 SHORT $LN1@read_buf

; 1094 :         strm->adler = crc32(strm->adler, buf, len);

  0004d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00050	57		 push	 edi
  00051	53		 push	 ebx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _crc32@12
  00058	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN1@read_buf:

; 1095 :     }
; 1096 : #endif
; 1097 :     strm->next_in  += len;

  0005b	01 3e		 add	 DWORD PTR [esi], edi

; 1098 :     strm->total_in += len;

  0005d	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1099 : 
; 1100 :     return (int)len;

  00060	8b c7		 mov	 eax, edi
  00062	5f		 pop	 edi

; 1101 : }

  00063	c3		 ret	 0
_read_buf ENDP
_TEXT	ENDS
PUBLIC	_deflateCopy@8
; Function compile flags: /Ogtp
;	COMDAT _deflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
tv260 = 12						; size = 4
_overlay$ = 12						; size = 4
_source$ = 12						; size = 4
_deflateCopy@8 PROC					; COMDAT

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1018 : #ifdef MAXSEG_64K
; 1019 :     return Z_STREAM_ERROR;
; 1020 : #else
; 1021 :     deflate_state *ds;
; 1022 :     deflate_state *ss;
; 1023 :     ushf *overlay;
; 1024 : 
; 1025 : 
; 1026 :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  00005	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 84 01 00
	00		 je	 $LN4@deflateCop
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  00013	85 db		 test	 ebx, ebx
  00015	0f 84 79 01 00
	00		 je	 $LN4@deflateCop
  0001b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001e	89 45 0c	 mov	 DWORD PTR tv260[ebp], eax
  00021	85 c0		 test	 eax, eax
  00023	0f 84 6b 01 00
	00		 je	 $LN4@deflateCop

; 1028 :     }
; 1029 : 
; 1030 :     ss = source->state;
; 1031 : 
; 1032 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00029	57		 push	 edi
  0002a	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0002f	8b fb		 mov	 edi, ebx
  00031	f3 a5		 rep movsd

; 1033 : 
; 1034 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00033	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00036	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  00039	68 c4 16 00 00	 push	 5828			; 000016c4H
  0003e	6a 01		 push	 1
  00040	50		 push	 eax
  00041	ff d1		 call	 ecx
  00043	8b f0		 mov	 esi, eax
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1035 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00048	85 f6		 test	 esi, esi
  0004a	0f 84 38 01 00
	00		 je	 $LN9@deflateCop

; 1036 :     dest->state = (struct internal_state FAR *) ds;
; 1037 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  00050	8b 7d 0c	 mov	 edi, DWORD PTR tv260[ebp]
  00053	68 c4 16 00 00	 push	 5828			; 000016c4H
  00058	57		 push	 edi
  00059	56		 push	 esi
  0005a	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
  0005d	e8 00 00 00 00	 call	 _memcpy

; 1038 :     ds->strm = dest;
; 1039 : 
; 1040 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  00062	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00065	89 1e		 mov	 DWORD PTR [esi], ebx
  00067	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  0006a	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  0006d	6a 02		 push	 2
  0006f	52		 push	 edx
  00070	50		 push	 eax
  00071	ff d1		 call	 ecx

; 1041 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00073	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00076	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00079	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  0007c	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  0007f	6a 02		 push	 2
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	ff d1		 call	 ecx

; 1042 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00085	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00088	89 46 40	 mov	 DWORD PTR [esi+64], eax
  0008b	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  0008e	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  00091	6a 02		 push	 2
  00093	52		 push	 edx
  00094	50		 push	 eax
  00095	ff d1		 call	 ecx

; 1043 :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  00097	8b 96 9c 16 00
	00		 mov	 edx, DWORD PTR [esi+5788]
  0009d	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000a0	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  000a3	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  000a6	6a 04		 push	 4
  000a8	52		 push	 edx
  000a9	50		 push	 eax
  000aa	ff d1		 call	 ecx

; 1044 :     ds->pending_buf = (uchf *) overlay;
; 1045 : 
; 1046 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 1047 :         ds->pending_buf == Z_NULL) {

  000ac	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000af	83 c4 3c	 add	 esp, 60			; 0000003cH
  000b2	89 45 0c	 mov	 DWORD PTR _overlay$[ebp], eax
  000b5	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000b8	85 c9		 test	 ecx, ecx
  000ba	0f 84 c2 00 00
	00		 je	 $LN1@deflateCop
  000c0	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  000c4	0f 84 b8 00 00
	00		 je	 $LN1@deflateCop
  000ca	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  000ce	0f 84 ae 00 00
	00		 je	 $LN1@deflateCop
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 a6 00 00
	00		 je	 $LN1@deflateCop

; 1050 :     }
; 1051 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1052 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  000dc	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000df	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000e2	03 d2		 add	 edx, edx
  000e4	52		 push	 edx
  000e5	50		 push	 eax
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 _memcpy

; 1053 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  000ec	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000ef	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  000f2	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000f5	03 c9		 add	 ecx, ecx
  000f7	51		 push	 ecx
  000f8	52		 push	 edx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _memcpy

; 1054 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  000ff	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00102	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00105	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00108	03 c9		 add	 ecx, ecx
  0010a	51		 push	 ecx
  0010b	52		 push	 edx
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _memcpy

; 1055 :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  00112	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00115	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00118	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0011b	51		 push	 ecx
  0011c	52		 push	 edx
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _memcpy

; 1056 : 
; 1057 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  00123	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00126	2b 57 08	 sub	 edx, DWORD PTR [edi+8]
  00129	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1058 :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  0012c	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00132	8b 7d 0c	 mov	 edi, DWORD PTR _overlay$[ebp]
  00135	03 d1		 add	 edx, ecx
  00137	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0013a	8b d0		 mov	 edx, eax

; 1059 :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  0013c	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0013f	d1 ea		 shr	 edx, 1
  00141	03 c8		 add	 ecx, eax
  00143	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  00146	83 c4 30	 add	 esp, 48			; 00000030H
  00149	89 96 a4 16 00
	00		 mov	 DWORD PTR [esi+5796], edx
  0014f	89 8e 98 16 00
	00		 mov	 DWORD PTR [esi+5784], ecx

; 1060 : 
; 1061 :     ds->l_desc.dyn_tree = ds->dyn_ltree;
; 1062 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  00155	8d 86 88 09 00
	00		 lea	 eax, DWORD PTR [esi+2440]
  0015b	8d 96 94 00 00
	00		 lea	 edx, DWORD PTR [esi+148]

; 1063 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  00161	8d 8e 7c 0a 00
	00		 lea	 ecx, DWORD PTR [esi+2684]
  00167	5f		 pop	 edi
  00168	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax
  0016e	89 96 18 0b 00
	00		 mov	 DWORD PTR [esi+2840], edx
  00174	89 8e 30 0b 00
	00		 mov	 DWORD PTR [esi+2864], ecx
  0017a	5e		 pop	 esi

; 1064 : 
; 1065 :     return Z_OK;

  0017b	33 c0		 xor	 eax, eax
  0017d	5b		 pop	 ebx

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  0017e	5d		 pop	 ebp
  0017f	c2 08 00	 ret	 8
$LN1@deflateCop:

; 1048 :         deflateEnd (dest);

  00182	53		 push	 ebx
  00183	e8 00 00 00 00	 call	 _deflateEnd@4
$LN9@deflateCop:

; 1049 :         return Z_MEM_ERROR;

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0018f	5b		 pop	 ebx

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  00190	5d		 pop	 ebp
  00191	c2 08 00	 ret	 8
$LN4@deflateCop:
  00194	5e		 pop	 esi

; 1027 :         return Z_STREAM_ERROR;

  00195	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0019a	5b		 pop	 ebx

; 1066 : #endif /* MAXSEG_64K */
; 1067 : }

  0019b	5d		 pop	 ebp
  0019c	c2 08 00	 ret	 8
_deflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_deflateResetKeep@4
; Function compile flags: /Ogtp
;	COMDAT _deflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateResetKeep@4 PROC				; COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 395  :     deflate_state *s;
; 396  : 
; 397  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 398  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00006	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00009	33 db		 xor	 ebx, ebx
  0000b	3b fb		 cmp	 edi, ebx
  0000d	0f 84 86 00 00
	00		 je	 $LN2@deflateRes
  00013	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00016	3b f3		 cmp	 esi, ebx
  00018	74 7f		 je	 SHORT $LN2@deflateRes
  0001a	39 5f 20	 cmp	 DWORD PTR [edi+32], ebx
  0001d	74 7a		 je	 SHORT $LN2@deflateRes
  0001f	39 5f 24	 cmp	 DWORD PTR [edi+36], ebx
  00022	74 75		 je	 SHORT $LN2@deflateRes

; 400  :     }
; 401  : 
; 402  :     strm->total_in = strm->total_out = 0;

  00024	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  00027	89 5f 08	 mov	 DWORD PTR [edi+8], ebx

; 403  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  0002a	89 5f 18	 mov	 DWORD PTR [edi+24], ebx

; 404  :     strm->data_type = Z_UNKNOWN;

  0002d	c7 47 2c 02 00
	00 00		 mov	 DWORD PTR [edi+44], 2

; 405  : 
; 406  :     s = (deflate_state *)strm->state;
; 407  :     s->pending = 0;
; 408  :     s->pending_out = s->pending_buf;

  00034	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00037	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 409  : 
; 410  :     if (s->wrap < 0) {

  0003a	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0003d	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00040	3b c3		 cmp	 eax, ebx
  00042	7d 05		 jge	 SHORT $LN1@deflateRes

; 411  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  00044	f7 d8		 neg	 eax
  00046	89 46 18	 mov	 DWORD PTR [esi+24], eax
$LN1@deflateRes:

; 412  :     }
; 413  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  00049	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0004c	8b c8		 mov	 ecx, eax
  0004e	f7 d9		 neg	 ecx
  00050	1b c9		 sbb	 ecx, ecx
  00052	83 e1 b9	 and	 ecx, -71		; ffffffb9H

; 414  :     strm->adler =
; 415  : #ifdef GZIP
; 416  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 417  : #endif
; 418  :         adler32(0L, Z_NULL, 0);

  00055	53		 push	 ebx
  00056	83 c1 71	 add	 ecx, 113		; 00000071H
  00059	53		 push	 ebx
  0005a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0005d	53		 push	 ebx
  0005e	83 f8 02	 cmp	 eax, 2
  00061	75 1b		 jne	 SHORT $LN6@deflateRes
  00063	e8 00 00 00 00	 call	 _crc32@12
  00068	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 419  :     s->last_flush = Z_NO_FLUSH;
; 420  : 
; 421  :     _tr_init(s);

  0006b	8b d6		 mov	 edx, esi
  0006d	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  00070	e8 00 00 00 00	 call	 __tr_init
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 422  : 
; 423  :     return Z_OK;

  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 424  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN6@deflateRes:

; 414  :     strm->adler =
; 415  : #ifdef GZIP
; 416  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 417  : #endif
; 418  :         adler32(0L, Z_NULL, 0);

  0007e	e8 00 00 00 00	 call	 _adler32@12
  00083	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 419  :     s->last_flush = Z_NO_FLUSH;
; 420  : 
; 421  :     _tr_init(s);

  00086	8b d6		 mov	 edx, esi
  00088	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  0008b	e8 00 00 00 00	 call	 __tr_init
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 422  : 
; 423  :     return Z_OK;

  00092	33 c0		 xor	 eax, eax
  00094	5b		 pop	 ebx

; 424  : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
$LN2@deflateRes:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi

; 399  :         return Z_STREAM_ERROR;

  0009b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000a0	5b		 pop	 ebx

; 424  : }

  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
_deflateResetKeep@4 ENDP
; Function compile flags: /Ogtp
;	COMDAT _fill_window
_TEXT	SEGMENT
_wsize$ = -4						; size = 4
_fill_window PROC					; COMDAT
; _s$ = edi

; 1392 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1393 :     register unsigned n, m;
; 1394 :     register Posf *p;
; 1395 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1396 :     uInt wsize = s->w_size;

  00005	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  00008	56		 push	 esi
  00009	89 5d fc	 mov	 DWORD PTR _wsize$[ebp], ebx
  0000c	eb 05		 jmp	 SHORT $LN26@fill_windo
  0000e	8b ff		 npad	 2
$LL39@fill_windo:
  00010	8b 5d fc	 mov	 ebx, DWORD PTR _wsize$[ebp]
$LN26@fill_windo:

; 1397 : 
; 1398 :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 1399 : 
; 1400 :     do {
; 1401 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00013	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  00016	2b 77 74	 sub	 esi, DWORD PTR [edi+116]
  00019	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 1402 : 
; 1403 :         /* Deal with !@#$% 64K limit: */
; 1404 :         if (sizeof(int) <= 2) {
; 1405 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1406 :                 more = wsize;
; 1407 : 
; 1408 :             } else if (more == (unsigned)(-1)) {
; 1409 :                 /* Very unlikely, but possible on 16 bit machine if
; 1410 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1411 :                  */
; 1412 :                 more--;
; 1413 :             }
; 1414 :         }
; 1415 : 
; 1416 :         /* If the window is almost full and there is insufficient lookahead,
; 1417 :          * move the upper half to the lower one to make room in the upper half.
; 1418 :          */
; 1419 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0001c	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001f	8d 94 0b fa fe
	ff ff		 lea	 edx, DWORD PTR [ebx+ecx-262]
  00026	2b f0		 sub	 esi, eax
  00028	3b c2		 cmp	 eax, edx
  0002a	72 5d		 jb	 SHORT $LN19@fill_windo

; 1420 : 
; 1421 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  0002c	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  0002f	53		 push	 ebx
  00030	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  00033	51		 push	 ecx
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _memcpy

; 1422 :             s->match_start -= wsize;
; 1423 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1424 :             s->block_start -= (long) wsize;
; 1425 : 
; 1426 :             /* Slide the hash table (could be avoided with 32 bit values
; 1427 :                at the expense of memory usage). We slide even when level == 0
; 1428 :                to keep the hash table consistent if we switch back to level > 0
; 1429 :                later. (Using level 0 permanently is not an optimal usage of
; 1430 :                zlib, so we don't care about this pathological case.)
; 1431 :              */
; 1432 :             n = s->hash_size;

  0003a	8b 57 4c	 mov	 edx, DWORD PTR [edi+76]

; 1433 :             p = &s->head[n];

  0003d	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00040	29 5f 70	 sub	 DWORD PTR [edi+112], ebx
  00043	29 5f 6c	 sub	 DWORD PTR [edi+108], ebx
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	29 5f 5c	 sub	 DWORD PTR [edi+92], ebx
  0004c	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0004f	90		 npad	 1
$LL18@fill_windo:

; 1434 :             do {
; 1435 :                 m = *--p;

  00050	0f b7 41 fe	 movzx	 eax, WORD PTR [ecx-2]
  00054	83 e9 02	 sub	 ecx, 2

; 1436 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00057	3b c3		 cmp	 eax, ebx
  00059	72 04		 jb	 SHORT $LN29@fill_windo
  0005b	2b c3		 sub	 eax, ebx
  0005d	eb 02		 jmp	 SHORT $LN30@fill_windo
$LN29@fill_windo:
  0005f	33 c0		 xor	 eax, eax
$LN30@fill_windo:

; 1437 :             } while (--n);

  00061	4a		 dec	 edx
  00062	66 89 01	 mov	 WORD PTR [ecx], ax
  00065	75 e9		 jne	 SHORT $LL18@fill_windo

; 1438 : 
; 1439 :             n = wsize;
; 1440 : #ifndef FASTEST
; 1441 :             p = &s->prev[n];

  00067	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  0006a	8b d3		 mov	 edx, ebx
  0006c	8d 0c 59	 lea	 ecx, DWORD PTR [ecx+ebx*2]
  0006f	90		 npad	 1
$LL15@fill_windo:

; 1442 :             do {
; 1443 :                 m = *--p;

  00070	0f b7 41 fe	 movzx	 eax, WORD PTR [ecx-2]
  00074	83 e9 02	 sub	 ecx, 2

; 1444 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00077	3b c3		 cmp	 eax, ebx
  00079	72 04		 jb	 SHORT $LN31@fill_windo
  0007b	2b c3		 sub	 eax, ebx
  0007d	eb 02		 jmp	 SHORT $LN32@fill_windo
$LN31@fill_windo:
  0007f	33 c0		 xor	 eax, eax
$LN32@fill_windo:

; 1445 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1446 :                  * its value will never be used.
; 1447 :                  */
; 1448 :             } while (--n);

  00081	4a		 dec	 edx
  00082	66 89 01	 mov	 WORD PTR [ecx], ax
  00085	75 e9		 jne	 SHORT $LL15@fill_windo

; 1449 : #endif
; 1450 :             more += wsize;

  00087	03 f3		 add	 esi, ebx
$LN19@fill_windo:

; 1451 :         }
; 1452 :         if (s->strm->avail_in == 0) break;

  00089	8b 07		 mov	 eax, DWORD PTR [edi]
  0008b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008f	0f 84 b0 00 00
	00		 je	 $LN24@fill_windo

; 1453 : 
; 1454 :         /* If there was no sliding:
; 1455 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1456 :          *    more == window_size - lookahead - strstart
; 1457 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1458 :          * => more >= window_size - 2*WSIZE + 2
; 1459 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1460 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1461 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1462 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1463 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1464 :          */
; 1465 :         Assert(more >= 2, "more < 2");
; 1466 : 
; 1467 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  00095	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]
  00098	03 5f 6c	 add	 ebx, DWORD PTR [edi+108]
  0009b	8b ce		 mov	 ecx, esi
  0009d	03 5f 38	 add	 ebx, DWORD PTR [edi+56]
  000a0	8b f0		 mov	 esi, eax
  000a2	e8 00 00 00 00	 call	 _read_buf

; 1468 :         s->lookahead += n;

  000a7	01 47 74	 add	 DWORD PTR [edi+116], eax
  000aa	8b 47 74	 mov	 eax, DWORD PTR [edi+116]

; 1469 : 
; 1470 :         /* Initialize the hash value now that we have some input: */
; 1471 :         if (s->lookahead + s->insert >= MIN_MATCH) {

  000ad	8b b7 b4 16 00
	00		 mov	 esi, DWORD PTR [edi+5812]
  000b3	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  000b6	83 fa 03	 cmp	 edx, 3
  000b9	72 75		 jb	 SHORT $LN25@fill_windo

; 1472 :             uInt str = s->strstart - s->insert;

  000bb	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]

; 1473 :             s->ins_h = s->window[str];

  000be	8b 5f 38	 mov	 ebx, DWORD PTR [edi+56]

; 1474 :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  000c1	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  000c4	2b d6		 sub	 edx, esi
  000c6	0f b6 04 13	 movzx	 eax, BYTE PTR [ebx+edx]
  000ca	89 47 48	 mov	 DWORD PTR [edi+72], eax
  000cd	d3 e0		 shl	 eax, cl
  000cf	0f b6 4c 13 01	 movzx	 ecx, BYTE PTR [ebx+edx+1]
  000d4	33 c1		 xor	 eax, ecx
  000d6	23 47 54	 and	 eax, DWORD PTR [edi+84]
  000d9	89 47 48	 mov	 DWORD PTR [edi+72], eax

; 1475 : #if MIN_MATCH != 3
; 1476 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1477 : #endif
; 1478 :             while (s->insert) {

  000dc	85 f6		 test	 esi, esi
  000de	74 50		 je	 SHORT $LN25@fill_windo
$LL10@fill_windo:

; 1479 :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  000e0	8b 77 48	 mov	 esi, DWORD PTR [edi+72]
  000e3	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  000e6	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000e9	0f b6 44 10 02	 movzx	 eax, BYTE PTR [eax+edx+2]

; 1480 : #ifndef FASTEST
; 1481 :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  000ee	8b 5f 40	 mov	 ebx, DWORD PTR [edi+64]
  000f1	d3 e6		 shl	 esi, cl
  000f3	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  000f6	33 c6		 xor	 eax, esi
  000f8	23 47 54	 and	 eax, DWORD PTR [edi+84]
  000fb	8b 77 34	 mov	 esi, DWORD PTR [edi+52]
  000fe	89 47 48	 mov	 DWORD PTR [edi+72], eax
  00101	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00105	23 f2		 and	 esi, edx
  00107	66 89 04 73	 mov	 WORD PTR [ebx+esi*2], ax

; 1482 : #endif
; 1483 :                 s->head[s->ins_h] = (Pos)str;

  0010b	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0010e	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00111	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1484 :                 str++;
; 1485 :                 s->insert--;

  00115	ff 8f b4 16 00
	00		 dec	 DWORD PTR [edi+5812]
  0011b	8b 87 b4 16 00
	00		 mov	 eax, DWORD PTR [edi+5812]

; 1486 :                 if (s->lookahead + s->insert < MIN_MATCH)

  00121	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  00124	03 c8		 add	 ecx, eax
  00126	42		 inc	 edx
  00127	83 f9 03	 cmp	 ecx, 3
  0012a	72 04		 jb	 SHORT $LN25@fill_windo

; 1475 : #if MIN_MATCH != 3
; 1476 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1477 : #endif
; 1478 :             while (s->insert) {

  0012c	85 c0		 test	 eax, eax
  0012e	75 b0		 jne	 SHORT $LL10@fill_windo
$LN25@fill_windo:

; 1487 :                     break;
; 1488 :             }
; 1489 :         }
; 1490 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1491 :          * but this is not important since only literal bytes will be emitted.
; 1492 :          */
; 1493 : 
; 1494 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  00130	81 7f 74 06 01
	00 00		 cmp	 DWORD PTR [edi+116], 262 ; 00000106H
  00137	73 0c		 jae	 SHORT $LN24@fill_windo
  00139	8b 17		 mov	 edx, DWORD PTR [edi]
  0013b	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0013f	0f 85 cb fe ff
	ff		 jne	 $LL39@fill_windo
$LN24@fill_windo:

; 1495 : 
; 1496 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1497 :      * written, then zero those bytes in order to avoid memory check reports of
; 1498 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1499 :      * the longest match routines.  Update the high water mark for the next
; 1500 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1501 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1502 :      */
; 1503 :     if (s->high_water < s->window_size) {

  00145	8b 87 c0 16 00
	00		 mov	 eax, DWORD PTR [edi+5824]
  0014b	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  0014e	3b c1		 cmp	 eax, ecx
  00150	73 6b		 jae	 SHORT $LN2@fill_windo

; 1504 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  00152	8b 77 74	 mov	 esi, DWORD PTR [edi+116]
  00155	03 77 6c	 add	 esi, DWORD PTR [edi+108]

; 1505 :         ulg init;
; 1506 : 
; 1507 :         if (s->high_water < curr) {

  00158	3b c6		 cmp	 eax, esi
  0015a	73 30		 jae	 SHORT $LN5@fill_windo

; 1508 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1509 :              * bytes or up to end of window, whichever is less.
; 1510 :              */
; 1511 :             init = s->window_size - curr;

  0015c	2b ce		 sub	 ecx, esi
  0015e	8b d9		 mov	 ebx, ecx

; 1512 :             if (init > WIN_INIT)

  00160	81 fb 02 01 00
	00		 cmp	 ebx, 258		; 00000102H
  00166	76 05		 jbe	 SHORT $LN4@fill_windo

; 1513 :                 init = WIN_INIT;

  00168	bb 02 01 00 00	 mov	 ebx, 258		; 00000102H
$LN4@fill_windo:

; 1514 :             zmemzero(s->window + curr, (unsigned)init);

  0016d	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00170	53		 push	 ebx
  00171	03 c6		 add	 eax, esi
  00173	6a 00		 push	 0
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _memset
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1515 :             s->high_water = curr + init;

  0017e	03 de		 add	 ebx, esi
  00180	5e		 pop	 esi
  00181	89 9f c0 16 00
	00		 mov	 DWORD PTR [edi+5824], ebx
  00187	5b		 pop	 ebx

; 1527 :         }
; 1528 :     }
; 1529 : 
; 1530 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1531 :            "not enough room for search");
; 1532 : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN5@fill_windo:

; 1516 :         }
; 1517 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  0018c	8d 96 02 01 00
	00		 lea	 edx, DWORD PTR [esi+258]
  00192	3b c2		 cmp	 eax, edx
  00194	73 27		 jae	 SHORT $LN2@fill_windo

; 1518 :             /* High water mark at or above current data, but below current data
; 1519 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1520 :              * to end of window, whichever is less.
; 1521 :              */
; 1522 :             init = (ulg)curr + WIN_INIT - s->high_water;

  00196	2b f0		 sub	 esi, eax
  00198	81 c6 02 01 00
	00		 add	 esi, 258		; 00000102H

; 1523 :             if (init > s->window_size - s->high_water)

  0019e	2b c8		 sub	 ecx, eax
  001a0	3b f1		 cmp	 esi, ecx
  001a2	76 02		 jbe	 SHORT $LN1@fill_windo

; 1524 :                 init = s->window_size - s->high_water;

  001a4	8b f1		 mov	 esi, ecx
$LN1@fill_windo:

; 1525 :             zmemzero(s->window + s->high_water, (unsigned)init);

  001a6	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  001a9	56		 push	 esi
  001aa	03 c8		 add	 ecx, eax
  001ac	6a 00		 push	 0
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _memset
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1526 :             s->high_water += init;

  001b7	01 b7 c0 16 00
	00		 add	 DWORD PTR [edi+5824], esi
$LN2@fill_windo:
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx

; 1527 :         }
; 1528 :     }
; 1529 : 
; 1530 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1531 :            "not enough room for search");
; 1532 : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_fill_window ENDP
_TEXT	ENDS
PUBLIC	_deflateReset@4
; Function compile flags: /Ogtp
;	COMDAT _deflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateReset@4 PROC					; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 430  :     int ret;
; 431  : 
; 432  :     ret = deflateResetKeep(strm);

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 _deflateResetKeep@4
  0000e	8b f8		 mov	 edi, eax

; 433  :     if (ret == Z_OK)

  00010	85 ff		 test	 edi, edi
  00012	75 0a		 jne	 SHORT $LN1@deflateRes@2

; 434  :         lm_init(strm->state);

  00014	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  00017	e8 00 00 00 00	 call	 _lm_init

; 435  :     return ret;

  0001c	8b c7		 mov	 eax, edi
$LN1@deflateRes@2:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 436  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
_deflateReset@4 ENDP
_TEXT	ENDS
PUBLIC	_deflateSetDictionary@12
; Function compile flags: /Ogtp
;	COMDAT _deflateSetDictionary@12
_TEXT	SEGMENT
_avail$ = -8						; size = 4
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_n$ = 12						; size = 4
_dictionary$ = 12					; size = 4
_next$ = 16						; size = 4
_dictLength$ = 16					; size = 4
_deflateSetDictionary@12 PROC				; COMDAT

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 328  :     deflate_state *s;
; 329  :     uInt str, n;
; 330  :     int wrap;
; 331  :     unsigned avail;
; 332  :     z_const unsigned char *next;
; 333  : 
; 334  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)

  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	57		 push	 edi
  0000b	85 f6		 test	 esi, esi
  0000d	0f 84 61 01 00
	00		 je	 $LN12@deflateSet@2
  00013	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00016	85 ff		 test	 edi, edi
  00018	0f 84 56 01 00
	00		 je	 $LN12@deflateSet@2
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	0f 84 4b 01 00
	00		 je	 $LN12@deflateSet@2

; 336  :     s = strm->state;
; 337  :     wrap = s->wrap;

  00029	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0002c	89 45 fc	 mov	 DWORD PTR _wrap$[ebp], eax

; 338  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  0002f	83 f8 02	 cmp	 eax, 2
  00032	0f 84 3c 01 00
	00		 je	 $LN12@deflateSet@2
  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 0a		 jne	 SHORT $LN9@deflateSet@2
  0003d	83 7f 04 2a	 cmp	 DWORD PTR [edi+4], 42	; 0000002aH
  00041	0f 85 2d 01 00
	00		 jne	 $LN12@deflateSet@2
$LN9@deflateSet@2:
  00047	83 7f 74 00	 cmp	 DWORD PTR [edi+116], 0
  0004b	0f 85 23 01 00
	00		 jne	 $LN12@deflateSet@2

; 339  :         return Z_STREAM_ERROR;
; 340  : 
; 341  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 342  :     if (wrap == 1)

  00051	53		 push	 ebx
  00052	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  00055	83 f8 01	 cmp	 eax, 1
  00058	75 14		 jne	 SHORT $LN8@deflateSet@2

; 343  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0005a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005d	53		 push	 ebx
  0005e	51		 push	 ecx
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _adler32@12
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00068	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _wrap$[ebp]
$LN8@deflateSet@2:

; 344  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

  0006e	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0

; 345  : 
; 346  :     /* if dictionary would fill window, just replace the history */
; 347  :     if (dictLength >= s->w_size) {

  00075	3b 5f 2c	 cmp	 ebx, DWORD PTR [edi+44]
  00078	72 3e		 jb	 SHORT $LN7@deflateSet@2

; 348  :         if (wrap == 0) {            /* already empty otherwise */

  0007a	85 c0		 test	 eax, eax
  0007c	75 31		 jne	 SHORT $LN6@deflateSet@2

; 349  :             CLEAR_HASH(s);

  0007e	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00081	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00084	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  00089	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  0008c	8d 54 09 fe	 lea	 edx, DWORD PTR [ecx+ecx-2]
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _memset

; 350  :             s->strstart = 0;
; 351  :             s->block_start = 0L;
; 352  :             s->insert = 0;

  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	33 c0		 xor	 eax, eax
  000a3	89 47 6c	 mov	 DWORD PTR [edi+108], eax
  000a6	89 47 5c	 mov	 DWORD PTR [edi+92], eax
  000a9	89 87 b4 16 00
	00		 mov	 DWORD PTR [edi+5812], eax
$LN6@deflateSet@2:

; 353  :         }
; 354  :         dictionary += dictLength - s->w_size;  /* use the tail */

  000af	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000b2	2b d8		 sub	 ebx, eax
  000b4	03 cb		 add	 ecx, ebx

; 355  :         dictLength = s->w_size;

  000b6	8b d8		 mov	 ebx, eax
$LN7@deflateSet@2:

; 356  :     }
; 357  : 
; 358  :     /* insert dictionary into window and hash */
; 359  :     avail = strm->avail_in;

  000b8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 360  :     next = strm->next_in;

  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	89 55 f8	 mov	 DWORD PTR _avail$[ebp], edx
  000c0	89 45 10	 mov	 DWORD PTR _next$[ebp], eax

; 361  :     strm->avail_in = dictLength;

  000c3	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 362  :     strm->next_in = (z_const Bytef *)dictionary;

  000c6	89 0e		 mov	 DWORD PTR [esi], ecx

; 363  :     fill_window(s);

  000c8	e8 00 00 00 00	 call	 _fill_window

; 364  :     while (s->lookahead >= MIN_MATCH) {

  000cd	83 7f 74 03	 cmp	 DWORD PTR [edi+116], 3
  000d1	72 60		 jb	 SHORT $LN4@deflateSet@2
$LL5@deflateSet@2:

; 365  :         str = s->strstart;
; 366  :         n = s->lookahead - (MIN_MATCH-1);

  000d3	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000d6	8b 57 6c	 mov	 edx, DWORD PTR [edi+108]
  000d9	83 e8 02	 sub	 eax, 2
  000dc	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
  000df	90		 npad	 1
$LL3@deflateSet@2:

; 367  :         do {
; 368  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  000e0	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  000e3	0f b6 44 11 02	 movzx	 eax, BYTE PTR [ecx+edx+2]
  000e8	8b 77 48	 mov	 esi, DWORD PTR [edi+72]
  000eb	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]

; 369  : #ifndef FASTEST
; 370  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  000ee	8b 5f 40	 mov	 ebx, DWORD PTR [edi+64]
  000f1	d3 e6		 shl	 esi, cl
  000f3	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  000f6	33 c6		 xor	 eax, esi
  000f8	23 47 54	 and	 eax, DWORD PTR [edi+84]
  000fb	8b 77 34	 mov	 esi, DWORD PTR [edi+52]
  000fe	89 47 48	 mov	 DWORD PTR [edi+72], eax
  00101	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00105	23 f2		 and	 esi, edx
  00107	66 89 04 73	 mov	 WORD PTR [ebx+esi*2], ax

; 371  : #endif
; 372  :             s->head[s->ins_h] = (Pos)str;

  0010b	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  0010e	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00111	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 373  :             str++;

  00115	42		 inc	 edx

; 374  :         } while (--n);

  00116	ff 4d 0c	 dec	 DWORD PTR _n$[ebp]
  00119	75 c5		 jne	 SHORT $LL3@deflateSet@2

; 375  :         s->strstart = str;

  0011b	89 57 6c	 mov	 DWORD PTR [edi+108], edx

; 376  :         s->lookahead = MIN_MATCH-1;

  0011e	c7 47 74 02 00
	00 00		 mov	 DWORD PTR [edi+116], 2

; 377  :         fill_window(s);

  00125	e8 00 00 00 00	 call	 _fill_window
  0012a	83 7f 74 03	 cmp	 DWORD PTR [edi+116], 3
  0012e	73 a3		 jae	 SHORT $LL5@deflateSet@2

; 364  :     while (s->lookahead >= MIN_MATCH) {

  00130	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
$LN4@deflateSet@2:

; 378  :     }
; 379  :     s->strstart += s->lookahead;

  00133	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00136	01 47 6c	 add	 DWORD PTR [edi+108], eax
  00139	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]

; 380  :     s->block_start = (long)s->strstart;
; 381  :     s->insert = s->lookahead;
; 382  :     s->lookahead = 0;
; 383  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 384  :     s->match_available = 0;
; 385  :     strm->next_in = next;
; 386  :     strm->avail_in = avail;

  0013c	8b 55 f8	 mov	 edx, DWORD PTR _avail$[ebp]
  0013f	89 4f 5c	 mov	 DWORD PTR [edi+92], ecx
  00142	89 87 b4 16 00
	00		 mov	 DWORD PTR [edi+5812], eax
  00148	33 c0		 xor	 eax, eax
  0014a	b9 02 00 00 00	 mov	 ecx, 2
  0014f	89 47 74	 mov	 DWORD PTR [edi+116], eax
  00152	89 4f 78	 mov	 DWORD PTR [edi+120], ecx
  00155	89 4f 60	 mov	 DWORD PTR [edi+96], ecx
  00158	8b 4d 10	 mov	 ecx, DWORD PTR _next$[ebp]
  0015b	89 47 68	 mov	 DWORD PTR [edi+104], eax

; 387  :     s->wrap = wrap;

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _wrap$[ebp]
  00161	89 0e		 mov	 DWORD PTR [esi], ecx
  00163	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00166	5b		 pop	 ebx
  00167	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0016a	5f		 pop	 edi

; 388  :     return Z_OK;

  0016b	33 c0		 xor	 eax, eax
  0016d	5e		 pop	 esi

; 389  : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 0c 00	 ret	 12			; 0000000cH
$LN12@deflateSet@2:
  00174	5f		 pop	 edi

; 335  :         return Z_STREAM_ERROR;

  00175	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0017a	5e		 pop	 esi

; 389  : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 0c 00	 ret	 12			; 0000000cH
_deflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_deflateInit2_@32
; Function compile flags: /Ogtp
;	COMDAT _deflateInit2_@32
_TEXT	SEGMENT
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_method$ = 16						; size = 4
_windowBits$ = 20					; size = 4
_memLevel$ = 24						; size = 4
_strategy$ = 28						; size = 4
_version$ = 32						; size = 4
_stream_size$ = 36					; size = 4
_deflateInit2_@32 PROC					; COMDAT

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 224  :     deflate_state *s;
; 225  :     int wrap = 1;
; 226  :     static const char my_version[] = ZLIB_VERSION;
; 227  : 
; 228  :     ushf *overlay;
; 229  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 230  :      * output size for (length,distance) codes is <= 24 bits.
; 231  :      */
; 232  : 
; 233  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 234  :         stream_size != sizeof(z_stream)) {

  00004	8b 45 20	 mov	 eax, DWORD PTR _version$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 1
  00010	3b c1		 cmp	 eax, ecx
  00012	0f 84 16 02 00
	00		 je	 $LN14@deflateIni
  00018	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  0001b	0f 85 0d 02 00
	00		 jne	 $LN14@deflateIni
  00021	83 7d 24 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00025	0f 85 03 02 00
	00		 jne	 $LN14@deflateIni

; 236  :     }
; 237  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002b	57		 push	 edi
  0002c	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0002f	3b f9		 cmp	 edi, ecx
  00031	75 0a		 jne	 SHORT $LN13@deflateIni
  00033	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  00036	5f		 pop	 edi

; 320  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 20 00	 ret	 32			; 00000020H
$LN13@deflateIni:

; 238  : 
; 239  :     strm->msg = Z_NULL;

  0003d	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 240  :     if (strm->zalloc == (alloc_func)0) {

  00040	39 4f 20	 cmp	 DWORD PTR [edi+32], ecx
  00043	75 0a		 jne	 SHORT $LN12@deflateIni

; 241  : #ifdef Z_SOLO
; 242  :         return Z_STREAM_ERROR;
; 243  : #else
; 244  :         strm->zalloc = zcalloc;

  00045	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET _zcalloc

; 245  :         strm->opaque = (voidpf)0;

  0004c	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
$LN12@deflateIni:

; 246  : #endif
; 247  :     }
; 248  :     if (strm->zfree == (free_func)0)

  0004f	39 4f 24	 cmp	 DWORD PTR [edi+36], ecx
  00052	75 07		 jne	 SHORT $LN11@deflateIni

; 249  : #ifdef Z_SOLO
; 250  :         return Z_STREAM_ERROR;
; 251  : #else
; 252  :         strm->zfree = zcfree;

  00054	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], OFFSET _zcfree
$LN11@deflateIni:

; 253  : #endif
; 254  : 
; 255  : #ifdef FASTEST
; 256  :     if (level != 0) level = 1;
; 257  : #else
; 258  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0005b	83 7d 0c ff	 cmp	 DWORD PTR _level$[ebp], -1
  0005f	75 07		 jne	 SHORT $LN10@deflateIni
  00061	c7 45 0c 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6
$LN10@deflateIni:
  00068	53		 push	 ebx

; 259  : #endif
; 260  : 
; 261  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00069	8b 5d 14	 mov	 ebx, DWORD PTR _windowBits$[ebp]
  0006c	3b d9		 cmp	 ebx, ecx
  0006e	7d 07		 jge	 SHORT $LN9@deflateIni

; 262  :         wrap = 0;

  00070	89 4d fc	 mov	 DWORD PTR _wrap$[ebp], ecx

; 263  :         windowBits = -windowBits;

  00073	f7 db		 neg	 ebx
  00075	eb 0f		 jmp	 SHORT $LN21@deflateIni
$LN9@deflateIni:

; 264  :     }
; 265  : #ifdef GZIP
; 266  :     else if (windowBits > 15) {

  00077	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0007a	7e 0d		 jle	 SHORT $LN7@deflateIni

; 267  :         wrap = 2;       /* write gzip wrapper instead */

  0007c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 2

; 268  :         windowBits -= 16;

  00083	83 eb 10	 sub	 ebx, 16			; 00000010H
$LN21@deflateIni:
  00086	89 5d 14	 mov	 DWORD PTR _windowBits$[ebp], ebx
$LN7@deflateIni:

; 269  :     }
; 270  : #endif
; 271  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 272  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 273  :         strategy < 0 || strategy > Z_FIXED) {

  00089	8b 45 18	 mov	 eax, DWORD PTR _memLevel$[ebp]
  0008c	48		 dec	 eax
  0008d	83 f8 08	 cmp	 eax, 8
  00090	0f 87 8b 01 00
	00		 ja	 $LN5@deflateIni
  00096	83 7d 10 08	 cmp	 DWORD PTR _method$[ebp], 8
  0009a	0f 85 81 01 00
	00		 jne	 $LN5@deflateIni
  000a0	8d 4b f8	 lea	 ecx, DWORD PTR [ebx-8]
  000a3	83 f9 07	 cmp	 ecx, 7
  000a6	0f 87 75 01 00
	00		 ja	 $LN5@deflateIni
  000ac	b8 09 00 00 00	 mov	 eax, 9
  000b1	39 45 0c	 cmp	 DWORD PTR _level$[ebp], eax
  000b4	0f 87 67 01 00
	00		 ja	 $LN5@deflateIni
  000ba	83 7d 1c 04	 cmp	 DWORD PTR _strategy$[ebp], 4
  000be	0f 87 5d 01 00
	00		 ja	 $LN5@deflateIni

; 275  :     }
; 276  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  000c4	83 fb 08	 cmp	 ebx, 8
  000c7	75 05		 jne	 SHORT $LN4@deflateIni
  000c9	89 45 14	 mov	 DWORD PTR _windowBits$[ebp], eax
  000cc	8b d8		 mov	 ebx, eax
$LN4@deflateIni:

; 277  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000ce	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  000d1	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000d4	56		 push	 esi
  000d5	68 c4 16 00 00	 push	 5828			; 000016c4H
  000da	6a 01		 push	 1
  000dc	52		 push	 edx
  000dd	ff d0		 call	 eax
  000df	8b f0		 mov	 esi, eax
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 278  :     if (s == Z_NULL) return Z_MEM_ERROR;

  000e4	85 f6		 test	 esi, esi
  000e6	0f 84 27 01 00
	00		 je	 $LN22@deflateIni

; 279  :     strm->state = (struct internal_state FAR *)s;
; 280  :     s->strm = strm;
; 281  : 
; 282  :     s->wrap = wrap;

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _wrap$[ebp]
  000ef	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  000f2	89 4e 18	 mov	 DWORD PTR [esi+24], ecx

; 283  :     s->gzhead = Z_NULL;
; 284  :     s->w_bits = windowBits;
; 285  :     s->w_size = 1 << s->w_bits;

  000f5	8b 4d 14	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000f8	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  000fb	bb 01 00 00 00	 mov	 ebx, 1
  00100	d3 e3		 shl	 ebx, cl

; 286  :     s->w_mask = s->w_size - 1;
; 287  : 
; 288  :     s->hash_bits = memLevel + 7;

  00102	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  00105	83 c1 07	 add	 ecx, 7

; 289  :     s->hash_size = 1 << s->hash_bits;

  00108	b8 01 00 00 00	 mov	 eax, 1
  0010d	d3 e0		 shl	 eax, cl
  0010f	89 4e 50	 mov	 DWORD PTR [esi+80], ecx
  00112	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00115	89 56 34	 mov	 DWORD PTR [esi+52], edx
  00118	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 290  :     s->hash_mask = s->hash_size - 1;

  0011b	48		 dec	 eax
  0011c	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 291  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  0011f	83 c1 02	 add	 ecx, 2
  00122	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00127	f7 e1		 mul	 ecx
  00129	d1 ea		 shr	 edx, 1
  0012b	89 3e		 mov	 DWORD PTR [esi], edi
  0012d	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00134	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  00137	89 56 58	 mov	 DWORD PTR [esi+88], edx

; 292  : 
; 293  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  0013a	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0013d	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00140	6a 02		 push	 2
  00142	53		 push	 ebx
  00143	50		 push	 eax
  00144	ff d1		 call	 ecx

; 294  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  00146	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00149	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0014c	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0014f	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00152	6a 02		 push	 2
  00154	52		 push	 edx
  00155	50		 push	 eax
  00156	ff d1		 call	 ecx

; 295  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  00158	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  0015b	89 46 40	 mov	 DWORD PTR [esi+64], eax
  0015e	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00161	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00164	6a 02		 push	 2
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	ff d1		 call	 ecx

; 296  : 
; 297  :     s->high_water = 0;      /* nothing written to s->window yet */
; 298  : 
; 299  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  0016a	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  0016d	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00170	83 c1 06	 add	 ecx, 6
  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	d3 e0		 shl	 eax, cl
  0017a	c7 86 c0 16 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5824], 0

; 300  : 
; 301  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  00184	6a 04		 push	 4
  00186	89 86 9c 16 00
	00		 mov	 DWORD PTR [esi+5788], eax
  0018c	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0018f	50		 push	 eax
  00190	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00193	52		 push	 edx
  00194	ff d0		 call	 eax

; 302  :     s->pending_buf = (uchf *) overlay;
; 303  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00196	8b 8e 9c 16 00
	00		 mov	 ecx, DWORD PTR [esi+5788]
  0019c	83 c4 30	 add	 esp, 48			; 00000030H

; 304  : 
; 305  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 306  :         s->pending_buf == Z_NULL) {

  0019f	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  001a3	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  001aa	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001ad	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  001b0	74 4d		 je	 SHORT $LN1@deflateIni
  001b2	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  001b6	74 47		 je	 SHORT $LN1@deflateIni
  001b8	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  001bc	74 41		 je	 SHORT $LN1@deflateIni
  001be	85 c0		 test	 eax, eax
  001c0	74 3d		 je	 SHORT $LN1@deflateIni

; 311  :     }
; 312  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001c2	8b d1		 mov	 edx, ecx
  001c4	d1 ea		 shr	 edx, 1
  001c6	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]

; 313  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  001c9	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  001cc	03 c1		 add	 eax, ecx

; 314  : 
; 315  :     s->level = level;

  001ce	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  001d1	89 96 a4 16 00
	00		 mov	 DWORD PTR [esi+5796], edx

; 316  :     s->strategy = strategy;

  001d7	8b 55 1c	 mov	 edx, DWORD PTR _strategy$[ebp]

; 317  :     s->method = (Byte)method;
; 318  : 
; 319  :     return deflateReset(strm);

  001da	57		 push	 edi
  001db	89 86 98 16 00
	00		 mov	 DWORD PTR [esi+5784], eax
  001e1	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  001e7	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  001ed	c6 46 24 08	 mov	 BYTE PTR [esi+36], 8
  001f1	e8 00 00 00 00	 call	 _deflateReset@4
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	5f		 pop	 edi

; 320  : }

  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c2 20 00	 ret	 32			; 00000020H
$LN1@deflateIni:

; 307  :         s->status = FINISH_STATE;

  001ff	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH

; 308  :         strm->msg = ERR_MSG(Z_MEM_ERROR);
; 309  :         deflateEnd (strm);

  00206	57		 push	 edi
  00207	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
  0020e	e8 00 00 00 00	 call	 _deflateEnd@4
$LN22@deflateIni:

; 310  :         return Z_MEM_ERROR;

  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0021a	5f		 pop	 edi

; 320  : }

  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 20 00	 ret	 32			; 00000020H
$LN5@deflateIni:
  00221	5b		 pop	 ebx

; 274  :         return Z_STREAM_ERROR;

  00222	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00227	5f		 pop	 edi

; 320  : }

  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c2 20 00	 ret	 32			; 00000020H
$LN14@deflateIni:

; 235  :         return Z_VERSION_ERROR;

  0022e	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 320  : }

  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c2 20 00	 ret	 32			; 00000020H
_deflateInit2_@32 ENDP
_TEXT	ENDS
PUBLIC	_deflateInit_@16
; Function compile flags: /Ogtp
;	COMDAT _deflateInit_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_deflateInit_@16 PROC					; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 208  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00003	8b 45 14	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR _version$[ebp]
  00009	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  0000c	50		 push	 eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	6a 08		 push	 8
  00015	6a 0f		 push	 15			; 0000000fH
  00017	6a 08		 push	 8
  00019	52		 push	 edx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _deflateInit2_@32

; 209  :     /* To do: ignore strm->next_in if we use it as window */
; 210  : }

  00020	5d		 pop	 ebp
  00021	c2 10 00	 ret	 16			; 00000010H
_deflateInit_@16 ENDP
; Function compile flags: /Ogtp
;	COMDAT _deflate_huff
_TEXT	SEGMENT
_flush$ = 8						; size = 4
_deflate_huff PROC					; COMDAT
; _s$ = esi

; 1937 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
$LL11@deflate_hu:

; 1938 :     int bflush;             /* set if current block must be flushed */
; 1939 : 
; 1940 :     for (;;) {
; 1941 :         /* Make sure that we have a literal to write. */
; 1942 :         if (s->lookahead == 0) {

  00004	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00008	75 11		 jne	 SHORT $LN8@deflate_hu

; 1943 :             fill_window(s);

  0000a	8b fe		 mov	 edi, esi
  0000c	e8 00 00 00 00	 call	 _fill_window

; 1944 :             if (s->lookahead == 0) {

  00011	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00015	0f 84 a4 00 00
	00		 je	 $LN22@deflate_hu
$LN8@deflate_hu:

; 1947 :                 break;      /* flush the current block */
; 1948 :             }
; 1949 :         }
; 1950 : 
; 1951 :         /* Output a literal byte */
; 1952 :         s->match_length = 0;
; 1953 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1954 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  0001b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0001e	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00021	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  00027	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  0002e	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00031	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  00037	33 ff		 xor	 edi, edi
  00039	66 89 3c 51	 mov	 WORD PTR [ecx+edx*2], di
  0003d	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00043	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  00049	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0004c	0f b6 d0	 movzx	 edx, al
  0004f	b9 01 00 00 00	 mov	 ecx, 1
  00054	01 8e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ecx
  0005a	66 01 8c 96 94
	00 00 00	 add	 WORD PTR [esi+edx*4+148], cx

; 1955 :         s->lookahead--;
; 1956 :         s->strstart++;

  00062	01 4e 6c	 add	 DWORD PTR [esi+108], ecx
  00065	ff 4e 74	 dec	 DWORD PTR [esi+116]
  00068	8d 84 96 94 00
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+148]
  0006f	8b 96 9c 16 00
	00		 mov	 edx, DWORD PTR [esi+5788]
  00075	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00078	2b d1		 sub	 edx, ecx
  0007a	39 96 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], edx

; 1957 :         if (bflush) FLUSH_BLOCK(s, 0);

  00080	75 82		 jne	 SHORT $LL11@deflate_hu
  00082	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00085	85 d2		 test	 edx, edx
  00087	78 07		 js	 SHORT $LN14@deflate_hu
  00089	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0008c	03 ca		 add	 ecx, edx
  0008e	eb 02		 jmp	 SHORT $LN15@deflate_hu
$LN14@deflate_hu:
  00090	33 c9		 xor	 ecx, ecx
$LN15@deflate_hu:
  00092	6a 00		 push	 0
  00094	51		 push	 ecx
  00095	2b c2		 sub	 eax, edx
  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 __tr_flush_block
  0009e	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000a1	8b 3e		 mov	 edi, DWORD PTR [esi]
  000a3	83 c4 08	 add	 esp, 8
  000a6	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000a9	e8 00 00 00 00	 call	 _flush_pending
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000b4	0f 85 4a ff ff
	ff		 jne	 $LL11@deflate_hu
$LN23@deflate_hu:
  000ba	33 c0		 xor	 eax, eax
  000bc	5f		 pop	 edi

; 1967 : }

  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN22@deflate_hu:

; 1945 :                 if (flush == Z_NO_FLUSH)

  000bf	8b 45 08	 mov	 eax, DWORD PTR _flush$[ebp]
  000c2	85 c0		 test	 eax, eax

; 1946 :                     return need_more;

  000c4	74 f4		 je	 SHORT $LN23@deflate_hu

; 1958 :     }
; 1959 :     s->insert = 0;

  000c6	c7 86 b4 16 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5812], 0

; 1960 :     if (flush == Z_FINISH) {

  000d0	83 f8 04	 cmp	 eax, 4
  000d3	75 3f		 jne	 SHORT $LN4@deflate_hu

; 1961 :         FLUSH_BLOCK(s, 1);

  000d5	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  000d8	85 d2		 test	 edx, edx
  000da	78 07		 js	 SHORT $LN16@deflate_hu
  000dc	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000df	03 ca		 add	 ecx, edx
  000e1	eb 02		 jmp	 SHORT $LN17@deflate_hu
$LN16@deflate_hu:
  000e3	33 c9		 xor	 ecx, ecx
$LN17@deflate_hu:
  000e5	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000e8	6a 01		 push	 1
  000ea	51		 push	 ecx
  000eb	2b c2		 sub	 eax, edx
  000ed	8b ce		 mov	 ecx, esi
  000ef	e8 00 00 00 00	 call	 __tr_flush_block
  000f4	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  000f7	8b 3e		 mov	 edi, DWORD PTR [esi]
  000f9	83 c4 08	 add	 esp, 8
  000fc	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  000ff	e8 00 00 00 00	 call	 _flush_pending
  00104	8b 06		 mov	 eax, DWORD PTR [esi]
  00106	33 c9		 xor	 ecx, ecx
  00108	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  0010b	5f		 pop	 edi
  0010c	0f 95 c1	 setne	 cl
  0010f	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]

; 1967 : }

  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN4@deflate_hu:

; 1962 :         return finish_done;
; 1963 :     }
; 1964 :     if (s->last_lit)

  00114	83 be a0 16 00
	00 00		 cmp	 DWORD PTR [esi+5792], 0
  0011b	74 3b		 je	 SHORT $LN1@deflate_hu

; 1965 :         FLUSH_BLOCK(s, 0);

  0011d	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00120	85 d2		 test	 edx, edx
  00122	78 07		 js	 SHORT $LN18@deflate_hu
  00124	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00127	03 ca		 add	 ecx, edx
  00129	eb 02		 jmp	 SHORT $LN19@deflate_hu
$LN18@deflate_hu:
  0012b	33 c9		 xor	 ecx, ecx
$LN19@deflate_hu:
  0012d	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00130	6a 00		 push	 0
  00132	51		 push	 ecx
  00133	2b c2		 sub	 eax, edx
  00135	8b ce		 mov	 ecx, esi
  00137	e8 00 00 00 00	 call	 __tr_flush_block
  0013c	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  0013f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00141	83 c4 08	 add	 esp, 8
  00144	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00147	e8 00 00 00 00	 call	 _flush_pending
  0014c	8b 06		 mov	 eax, DWORD PTR [esi]
  0014e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00152	0f 84 62 ff ff
	ff		 je	 $LN23@deflate_hu
$LN1@deflate_hu:

; 1966 :     return block_done;

  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	5f		 pop	 edi

; 1967 : }

  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
_deflate_huff ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _deflate_rle
_TEXT	SEGMENT
_flush$ = 8						; size = 4
_deflate_rle PROC					; COMDAT
; _s$ = esi

; 1864 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	bb 01 00 00 00	 mov	 ebx, 1
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL20@deflate_rl:

; 1865 :     int bflush;             /* set if current block must be flushed */
; 1866 :     uInt prev;              /* byte at distance one to match */
; 1867 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1868 : 
; 1869 :     for (;;) {
; 1870 :         /* Make sure that we always have enough lookahead, except
; 1871 :          * at the end of the input file. We need MAX_MATCH bytes
; 1872 :          * for the longest run, plus one for the unrolled loop.
; 1873 :          */
; 1874 :         if (s->lookahead <= MAX_MATCH) {

  00010	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00013	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  00019	77 24		 ja	 SHORT $LN41@deflate_rl

; 1875 :             fill_window(s);

  0001b	8b fe		 mov	 edi, esi
  0001d	e8 00 00 00 00	 call	 _fill_window

; 1876 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  00022	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00025	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  0002b	77 0a		 ja	 SHORT $LN40@deflate_rl
  0002d	83 7d 08 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00031	0f 84 cb 01 00
	00		 je	 $LN36@deflate_rl
$LN40@deflate_rl:

; 1877 :                 return need_more;
; 1878 :             }
; 1879 :             if (s->lookahead == 0) break; /* flush the current block */

  00037	85 ff		 test	 edi, edi
  00039	0f 84 c9 01 00
	00		 je	 $LN35@deflate_rl
$LN41@deflate_rl:

; 1880 :         }
; 1881 : 
; 1882 :         /* See how many times the previous byte repeats */
; 1883 :         s->match_length = 0;

  0003f	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 1884 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  00046	83 ff 03	 cmp	 edi, 3
  00049	0f 82 a2 00 00
	00		 jb	 $LN9@deflate_rl
  0004f	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00052	85 c0		 test	 eax, eax
  00054	0f 84 97 00 00
	00		 je	 $LN9@deflate_rl

; 1885 :             scan = s->window + s->strstart - 1;

  0005a	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  0005d	03 d0		 add	 edx, eax

; 1886 :             prev = *scan;

  0005f	0f b6 4a ff	 movzx	 ecx, BYTE PTR [edx-1]
  00063	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 1887 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00066	03 c3		 add	 eax, ebx
  00068	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  0006b	3b cb		 cmp	 ecx, ebx
  0006d	75 7d		 jne	 SHORT $LN38@deflate_rl
  0006f	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  00073	3b cb		 cmp	 ecx, ebx
  00075	75 75		 jne	 SHORT $LN38@deflate_rl
  00077	0f b6 58 02	 movzx	 ebx, BYTE PTR [eax+2]
  0007b	83 c0 02	 add	 eax, 2
  0007e	3b cb		 cmp	 ecx, ebx
  00080	75 6a		 jne	 SHORT $LN38@deflate_rl

; 1888 :                 strend = s->window + s->strstart + MAX_MATCH;

  00082	81 c2 02 01 00
	00		 add	 edx, 258		; 00000102H
$LL13@deflate_rl:

; 1889 :                 do {
; 1890 :                 } while (prev == *++scan && prev == *++scan &&
; 1891 :                          prev == *++scan && prev == *++scan &&
; 1892 :                          prev == *++scan && prev == *++scan &&
; 1893 :                          prev == *++scan && prev == *++scan &&
; 1894 :                          scan < strend);

  00088	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  0008c	40		 inc	 eax
  0008d	3b cb		 cmp	 ecx, ebx
  0008f	75 43		 jne	 SHORT $LN10@deflate_rl
  00091	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  00095	40		 inc	 eax
  00096	3b cb		 cmp	 ecx, ebx
  00098	75 3a		 jne	 SHORT $LN10@deflate_rl
  0009a	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  0009e	40		 inc	 eax
  0009f	3b cb		 cmp	 ecx, ebx
  000a1	75 31		 jne	 SHORT $LN10@deflate_rl
  000a3	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  000a7	40		 inc	 eax
  000a8	3b cb		 cmp	 ecx, ebx
  000aa	75 28		 jne	 SHORT $LN10@deflate_rl
  000ac	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  000b0	40		 inc	 eax
  000b1	3b cb		 cmp	 ecx, ebx
  000b3	75 1f		 jne	 SHORT $LN10@deflate_rl
  000b5	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  000b9	40		 inc	 eax
  000ba	3b cb		 cmp	 ecx, ebx
  000bc	75 16		 jne	 SHORT $LN10@deflate_rl
  000be	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  000c2	40		 inc	 eax
  000c3	3b cb		 cmp	 ecx, ebx
  000c5	75 0d		 jne	 SHORT $LN10@deflate_rl
  000c7	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  000cb	40		 inc	 eax
  000cc	3b cb		 cmp	 ecx, ebx
  000ce	75 04		 jne	 SHORT $LN10@deflate_rl
  000d0	3b c2		 cmp	 eax, edx
  000d2	72 b4		 jb	 SHORT $LL13@deflate_rl
$LN10@deflate_rl:

; 1895 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  000d4	2b c2		 sub	 eax, edx
  000d6	05 02 01 00 00	 add	 eax, 258		; 00000102H
  000db	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1896 :                 if (s->match_length > s->lookahead)
; 1897 :                     s->match_length = s->lookahead;

  000de	bb 01 00 00 00	 mov	 ebx, 1
  000e3	3b c7		 cmp	 eax, edi
  000e5	76 0a		 jbe	 SHORT $LN9@deflate_rl
  000e7	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  000ea	eb 05		 jmp	 SHORT $LN9@deflate_rl
$LN38@deflate_rl:
  000ec	bb 01 00 00 00	 mov	 ebx, 1
$LN9@deflate_rl:

; 1898 :             }
; 1899 :             Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
; 1900 :         }
; 1901 : 
; 1902 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1903 :         if (s->match_length >= MIN_MATCH) {

  000f1	83 7e 60 03	 cmp	 DWORD PTR [esi+96], 3

; 1904 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1905 : 
; 1906 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  000f5	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  000fb	72 6d		 jb	 SHORT $LN8@deflate_rl
  000fd	8a 46 60	 mov	 al, BYTE PTR [esi+96]
  00100	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  00106	2c 03		 sub	 al, 3
  00108	8b fb		 mov	 edi, ebx
  0010a	66 89 3c 51	 mov	 WORD PTR [ecx+edx*2], di
  0010e	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00114	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  0011a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0011d	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  00123	0f b6 d0	 movzx	 edx, al
  00126	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[edx]
  0012d	66 01 9c 86 98
	04 00 00	 add	 WORD PTR [esi+eax*4+1176], bx
  00135	66 01 9e 88 09
	00 00		 add	 WORD PTR [esi+2440], bx
  0013c	8b 8e 9c 16 00
	00		 mov	 ecx, DWORD PTR [esi+5788]
  00142	8d 84 86 98 04
	00 00		 lea	 eax, DWORD PTR [esi+eax*4+1176]

; 1907 : 
; 1908 :             s->lookahead -= s->match_length;

  00149	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  0014c	2b cb		 sub	 ecx, ebx
  0014e	33 d2		 xor	 edx, edx
  00150	39 8e a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], ecx

; 1909 :             s->strstart += s->match_length;
; 1910 :             s->match_length = 0;

  00156	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  0015d	0f 94 c2	 sete	 dl
  00160	29 46 74	 sub	 DWORD PTR [esi+116], eax
  00163	01 46 6c	 add	 DWORD PTR [esi+108], eax
  00166	8b ca		 mov	 ecx, edx

; 1911 :         } else {

  00168	eb 55		 jmp	 SHORT $LN7@deflate_rl
$LN8@deflate_rl:

; 1912 :             /* No match, output a literal byte */
; 1913 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1914 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  0016a	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0016d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00170	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00173	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  00179	33 ff		 xor	 edi, edi
  0017b	66 89 3c 51	 mov	 WORD PTR [ecx+edx*2], di
  0017f	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00185	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  0018b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0018e	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  00194	0f b6 d0	 movzx	 edx, al
  00197	66 01 9c 96 94
	00 00 00	 add	 WORD PTR [esi+edx*4+148], bx
  0019f	8d 84 96 94 00
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+148]
  001a6	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  001ac	2b c3		 sub	 eax, ebx
  001ae	33 c9		 xor	 ecx, ecx
  001b0	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  001b6	0f 94 c1	 sete	 cl

; 1915 :             s->lookahead--;

  001b9	ff 4e 74	 dec	 DWORD PTR [esi+116]

; 1916 :             s->strstart++;

  001bc	01 5e 6c	 add	 DWORD PTR [esi+108], ebx
$LN7@deflate_rl:

; 1917 :         }
; 1918 :         if (bflush) FLUSH_BLOCK(s, 0);

  001bf	85 c9		 test	 ecx, ecx
  001c1	0f 84 49 fe ff
	ff		 je	 $LL20@deflate_rl
  001c7	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  001ca	85 d2		 test	 edx, edx
  001cc	78 07		 js	 SHORT $LN25@deflate_rl
  001ce	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  001d1	03 ca		 add	 ecx, edx
  001d3	eb 02		 jmp	 SHORT $LN26@deflate_rl
$LN25@deflate_rl:
  001d5	33 c9		 xor	 ecx, ecx
$LN26@deflate_rl:
  001d7	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  001da	6a 00		 push	 0
  001dc	51		 push	 ecx
  001dd	2b c2		 sub	 eax, edx
  001df	8b ce		 mov	 ecx, esi
  001e1	e8 00 00 00 00	 call	 __tr_flush_block
  001e6	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  001e9	8b 3e		 mov	 edi, DWORD PTR [esi]
  001eb	83 c4 08	 add	 esp, 8
  001ee	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  001f1	e8 00 00 00 00	 call	 _flush_pending
  001f6	8b 16		 mov	 edx, DWORD PTR [esi]
  001f8	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  001fc	0f 85 0e fe ff
	ff		 jne	 $LL20@deflate_rl
$LN36@deflate_rl:
  00202	5f		 pop	 edi
  00203	33 c0		 xor	 eax, eax
  00205	5b		 pop	 ebx

; 1928 : }

  00206	5d		 pop	 ebp
  00207	c3		 ret	 0
$LN35@deflate_rl:

; 1919 :     }
; 1920 :     s->insert = 0;
; 1921 :     if (flush == Z_FINISH) {

  00208	83 7d 08 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0020c	c7 86 b4 16 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5812], 0
  00216	75 3f		 jne	 SHORT $LN4@deflate_rl

; 1922 :         FLUSH_BLOCK(s, 1);

  00218	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  0021b	85 d2		 test	 edx, edx
  0021d	78 07		 js	 SHORT $LN27@deflate_rl
  0021f	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00222	03 ca		 add	 ecx, edx
  00224	eb 02		 jmp	 SHORT $LN28@deflate_rl
$LN27@deflate_rl:
  00226	33 c9		 xor	 ecx, ecx
$LN28@deflate_rl:
  00228	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0022b	53		 push	 ebx
  0022c	51		 push	 ecx
  0022d	2b c2		 sub	 eax, edx
  0022f	8b ce		 mov	 ecx, esi
  00231	e8 00 00 00 00	 call	 __tr_flush_block
  00236	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00239	8b 3e		 mov	 edi, DWORD PTR [esi]
  0023b	83 c4 08	 add	 esp, 8
  0023e	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00241	e8 00 00 00 00	 call	 _flush_pending
  00246	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00248	33 c0		 xor	 eax, eax
  0024a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0024d	5f		 pop	 edi
  0024e	0f 95 c0	 setne	 al
  00251	5b		 pop	 ebx
  00252	83 c0 02	 add	 eax, 2

; 1928 : }

  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
$LN4@deflate_rl:

; 1923 :         return finish_done;
; 1924 :     }
; 1925 :     if (s->last_lit)

  00257	83 be a0 16 00
	00 00		 cmp	 DWORD PTR [esi+5792], 0
  0025e	74 3b		 je	 SHORT $LN1@deflate_rl

; 1926 :         FLUSH_BLOCK(s, 0);

  00260	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00263	85 d2		 test	 edx, edx
  00265	78 07		 js	 SHORT $LN29@deflate_rl
  00267	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0026a	03 ca		 add	 ecx, edx
  0026c	eb 02		 jmp	 SHORT $LN30@deflate_rl
$LN29@deflate_rl:
  0026e	33 c9		 xor	 ecx, ecx
$LN30@deflate_rl:
  00270	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00273	6a 00		 push	 0
  00275	51		 push	 ecx
  00276	2b c2		 sub	 eax, edx
  00278	8b ce		 mov	 ecx, esi
  0027a	e8 00 00 00 00	 call	 __tr_flush_block
  0027f	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00282	8b 3e		 mov	 edi, DWORD PTR [esi]
  00284	83 c4 08	 add	 esp, 8
  00287	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0028a	e8 00 00 00 00	 call	 _flush_pending
  0028f	8b 06		 mov	 eax, DWORD PTR [esi]
  00291	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00295	0f 84 67 ff ff
	ff		 je	 $LN36@deflate_rl
$LN1@deflate_rl:
  0029b	5f		 pop	 edi

; 1927 :     return block_done;

  0029c	8b c3		 mov	 eax, ebx
  0029e	5b		 pop	 ebx

; 1928 : }

  0029f	5d		 pop	 ebp
  002a0	c3		 ret	 0
_deflate_rle ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _deflate_slow
_TEXT	SEGMENT
_bflush$ = 8						; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_slow PROC					; COMDAT

; 1733 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00008	57		 push	 edi
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	8b ff		 npad	 2
$LL26@deflate_sl:

; 1734 :     IPos hash_head;          /* head of hash chain */
; 1735 :     int bflush;              /* set if current block must be flushed */
; 1736 : 
; 1737 :     /* Process the input block. */
; 1738 :     for (;;) {
; 1739 :         /* Make sure that we always have enough lookahead, except
; 1740 :          * at the end of the input file. We need MAX_MATCH bytes
; 1741 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1742 :          * string following the next match.
; 1743 :          */
; 1744 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00013	81 f9 06 01 00
	00		 cmp	 ecx, 262		; 00000106H
  00019	73 24		 jae	 SHORT $LN50@deflate_sl

; 1745 :             fill_window(s);

  0001b	8b fe		 mov	 edi, esi
  0001d	e8 00 00 00 00	 call	 _fill_window

; 1746 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00022	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00025	81 f9 06 01 00
	00		 cmp	 ecx, 262		; 00000106H
  0002b	73 0a		 jae	 SHORT $LN49@deflate_sl
  0002d	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00031	0f 84 2c 02 00
	00		 je	 $LN47@deflate_sl
$LN49@deflate_sl:

; 1747 :                 return need_more;
; 1748 :             }
; 1749 :             if (s->lookahead == 0) break; /* flush the current block */

  00037	85 c9		 test	 ecx, ecx
  00039	0f 84 d0 02 00
	00		 je	 $LN45@deflate_sl
$LN50@deflate_sl:

; 1750 :         }
; 1751 : 
; 1752 :         /* Insert the string window[strstart .. strstart+2] in the
; 1753 :          * dictionary, and set hash_head to the head of the hash chain:
; 1754 :          */
; 1755 :         hash_head = NIL;

  0003f	33 c0		 xor	 eax, eax

; 1756 :         if (s->lookahead >= MIN_MATCH) {

  00041	83 f9 03	 cmp	 ecx, 3
  00044	72 49		 jb	 SHORT $LN21@deflate_sl

; 1757 :             INSERT_STRING(s, s->strstart, hash_head);

  00046	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00049	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0004c	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  0004f	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00052	d3 e0		 shl	 eax, cl
  00054	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00057	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  0005c	33 c1		 xor	 eax, ecx
  0005e	23 46 54	 and	 eax, DWORD PTR [esi+84]
  00061	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00064	23 fa		 and	 edi, edx
  00066	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00069	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0006c	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00070	66 89 04 7a	 mov	 WORD PTR [edx+edi*2], ax
  00074	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00077	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  0007a	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  0007d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00081	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00084	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00087	66 8b 7e 6c	 mov	 di, WORD PTR [esi+108]
  0008b	66 89 3c 4a	 mov	 WORD PTR [edx+ecx*2], di
$LN21@deflate_sl:

; 1758 :         }
; 1759 : 
; 1760 :         /* Find the longest match, discarding those <= prev_length.
; 1761 :          */
; 1762 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  0008f	8b 4e 60	 mov	 ecx, DWORD PTR [esi+96]
  00092	8b 56 70	 mov	 edx, DWORD PTR [esi+112]

; 1763 :         s->match_length = MIN_MATCH-1;

  00095	bf 02 00 00 00	 mov	 edi, 2
  0009a	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  0009d	89 56 64	 mov	 DWORD PTR [esi+100], edx
  000a0	89 7e 60	 mov	 DWORD PTR [esi+96], edi

; 1764 : 
; 1765 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1766 :             s->strstart - hash_head <= MAX_DIST(s)) {

  000a3	85 c0		 test	 eax, eax
  000a5	74 4a		 je	 SHORT $LN52@deflate_sl
  000a7	3b 8e 80 00 00
	00		 cmp	 ecx, DWORD PTR [esi+128]
  000ad	73 42		 jae	 SHORT $LN52@deflate_sl
  000af	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  000b2	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000b5	2b d0		 sub	 edx, eax
  000b7	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  000bd	3b d1		 cmp	 edx, ecx
  000bf	77 30		 ja	 SHORT $LN52@deflate_sl

; 1767 :             /* To simplify the code, we prevent matches with the string
; 1768 :              * of window index 0 (in particular we have to avoid a match
; 1769 :              * of the string with itself at the start of the input file).
; 1770 :              */
; 1771 :             s->match_length = longest_match (s, hash_head);

  000c1	50		 push	 eax
  000c2	56		 push	 esi
  000c3	e8 00 00 00 00	 call	 _longest_match
  000c8	83 c4 08	 add	 esp, 8
  000cb	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1772 :             /* longest_match() sets match_start */
; 1773 : 
; 1774 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1775 : #if TOO_FAR <= 32767
; 1776 :                 || (s->match_length == MIN_MATCH &&
; 1777 :                     s->strstart - s->match_start > TOO_FAR)
; 1778 : #endif
; 1779 :                 )) {

  000ce	83 f8 05	 cmp	 eax, 5
  000d1	77 1e		 ja	 SHORT $LN52@deflate_sl
  000d3	39 9e 88 00 00
	00		 cmp	 DWORD PTR [esi+136], ebx
  000d9	74 13		 je	 SHORT $LN18@deflate_sl
  000db	83 f8 03	 cmp	 eax, 3
  000de	75 11		 jne	 SHORT $LN52@deflate_sl
  000e0	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  000e3	2b 56 70	 sub	 edx, DWORD PTR [esi+112]
  000e6	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000ec	76 03		 jbe	 SHORT $LN52@deflate_sl
$LN18@deflate_sl:

; 1780 : 
; 1781 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1782 :                  * but we will ignore the current match anyway.
; 1783 :                  */
; 1784 :                 s->match_length = MIN_MATCH-1;

  000ee	89 7e 60	 mov	 DWORD PTR [esi+96], edi
$LN52@deflate_sl:

; 1785 :             }
; 1786 :         }
; 1787 :         /* If there was a match at the previous step and the current
; 1788 :          * match is not better, output the previous match:
; 1789 :          */
; 1790 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  000f1	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  000f4	83 f8 03	 cmp	 eax, 3
  000f7	0f 82 6d 01 00
	00		 jb	 $LN17@deflate_sl
  000fd	39 46 60	 cmp	 DWORD PTR [esi+96], eax
  00100	0f 87 64 01 00
	00		 ja	 $LN17@deflate_sl

; 1791 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
; 1792 :             /* Do not insert strings in hash table beyond this. */
; 1793 : 
; 1794 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1795 : 
; 1796 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1797 :                            s->prev_length - MIN_MATCH, bflush);

  00106	66 8b 56 6c	 mov	 dx, WORD PTR [esi+108]
  0010a	66 2b 56 64	 sub	 dx, WORD PTR [esi+100]
  0010e	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00111	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00114	66 2b d3	 sub	 dx, bx
  00117	8b 9e a4 16 00
	00		 mov	 ebx, DWORD PTR [esi+5796]
  0011d	8d 7c 08 fd	 lea	 edi, DWORD PTR [eax+ecx-3]
  00121	8a 46 78	 mov	 al, BYTE PTR [esi+120]
  00124	0f b7 ca	 movzx	 ecx, dx
  00127	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  0012d	66 89 0c 53	 mov	 WORD PTR [ebx+edx*2], cx
  00131	8b 9e a0 16 00
	00		 mov	 ebx, DWORD PTR [esi+5792]
  00137	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  0013d	2c 03		 sub	 al, 3
  0013f	88 04 1a	 mov	 BYTE PTR [edx+ebx], al
  00142	0f b6 c0	 movzx	 eax, al
  00145	bb 01 00 00 00	 mov	 ebx, 1
  0014a	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  00150	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR __length_code[eax]
  00157	66 01 9c 96 98
	04 00 00	 add	 WORD PTR [esi+edx*4+1176], bx
  0015f	8d 84 96 98 04
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+1176]
  00166	81 c1 ff ff 00
	00		 add	 ecx, 65535		; 0000ffffH
  0016c	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00171	66 3b c8	 cmp	 cx, ax
  00174	73 0c		 jae	 SHORT $LN29@deflate_sl
  00176	0f b7 c9	 movzx	 ecx, cx
  00179	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[ecx]
  00180	eb 0d		 jmp	 SHORT $LN30@deflate_sl
$LN29@deflate_sl:
  00182	0f b7 d1	 movzx	 edx, cx
  00185	c1 ea 07	 shr	 edx, 7
  00188	0f b6 82 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[edx+256]
$LN30@deflate_sl:
  0018f	66 01 9c 86 88
	09 00 00	 add	 WORD PTR [esi+eax*4+2440], bx
  00197	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  0019d	2b c3		 sub	 eax, ebx
  0019f	33 c9		 xor	 ecx, ecx
  001a1	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1798 : 
; 1799 :             /* Insert in hash table all strings up to the end of the match.
; 1800 :              * strstart-1 and strstart are already inserted. If there is not
; 1801 :              * enough lookahead, the last two strings are not inserted in
; 1802 :              * the hash table.
; 1803 :              */
; 1804 :             s->lookahead -= s->prev_length-1;

  001a7	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  001aa	0f 94 c1	 sete	 cl
  001ad	8b d3		 mov	 edx, ebx
  001af	2b d0		 sub	 edx, eax
  001b1	01 56 74	 add	 DWORD PTR [esi+116], edx

; 1805 :             s->prev_length -= 2;

  001b4	83 c0 fe	 add	 eax, -2			; fffffffeH
  001b7	89 46 78	 mov	 DWORD PTR [esi+120], eax
  001ba	89 4d 08	 mov	 DWORD PTR _bflush$[ebp], ecx
  001bd	8d 49 00	 npad	 3
$LL16@deflate_sl:

; 1806 :             do {
; 1807 :                 if (++s->strstart <= max_insert) {

  001c0	01 5e 6c	 add	 DWORD PTR [esi+108], ebx
  001c3	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  001c6	3b d7		 cmp	 edx, edi
  001c8	77 3e		 ja	 SHORT $LN15@deflate_sl

; 1808 :                     INSERT_STRING(s, s->strstart, hash_head);

  001ca	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  001cd	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001d0	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  001d3	d3 e0		 shl	 eax, cl
  001d5	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  001d8	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  001dd	33 c1		 xor	 eax, ecx
  001df	23 46 54	 and	 eax, DWORD PTR [esi+84]
  001e2	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001e5	89 46 48	 mov	 DWORD PTR [esi+72], eax
  001e8	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  001ec	23 da		 and	 ebx, edx
  001ee	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  001f1	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax
  001f5	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  001f9	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  001fc	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  001ff	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00203	bb 01 00 00 00	 mov	 ebx, 1
$LN15@deflate_sl:

; 1809 :                 }
; 1810 :             } while (--s->prev_length != 0);

  00208	ff 4e 78	 dec	 DWORD PTR [esi+120]
  0020b	75 b3		 jne	 SHORT $LL16@deflate_sl

; 1811 :             s->match_available = 0;
; 1812 :             s->match_length = MIN_MATCH-1;
; 1813 :             s->strstart++;

  0020d	01 5e 6c	 add	 DWORD PTR [esi+108], ebx

; 1814 : 
; 1815 :             if (bflush) FLUSH_BLOCK(s, 0);

  00210	83 7d 08 00	 cmp	 DWORD PTR _bflush$[ebp], 0
  00214	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00217	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  0021e	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2
  00225	0f 84 e5 fd ff
	ff		 je	 $LL26@deflate_sl
  0022b	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  0022e	85 d2		 test	 edx, edx
  00230	78 07		 js	 SHORT $LN31@deflate_sl
  00232	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00235	03 ca		 add	 ecx, edx
  00237	eb 02		 jmp	 SHORT $LN32@deflate_sl
$LN31@deflate_sl:
  00239	33 c9		 xor	 ecx, ecx
$LN32@deflate_sl:
  0023b	6a 00		 push	 0
  0023d	51		 push	 ecx
  0023e	2b c2		 sub	 eax, edx
  00240	8b ce		 mov	 ecx, esi
  00242	e8 00 00 00 00	 call	 __tr_flush_block
  00247	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0024a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0024c	83 c4 08	 add	 esp, 8
  0024f	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  00252	e8 00 00 00 00	 call	 _flush_pending
$LN53@deflate_sl:
  00257	8b 16		 mov	 edx, DWORD PTR [esi]
  00259	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0025d	0f 85 ad fd ff
	ff		 jne	 $LL26@deflate_sl
$LN47@deflate_sl:
  00263	5f		 pop	 edi
  00264	5e		 pop	 esi

; 1829 :             if (s->strm->avail_out == 0) return need_more;

  00265	33 c0		 xor	 eax, eax
  00267	5b		 pop	 ebx

; 1853 : }

  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
$LN17@deflate_sl:

; 1816 : 
; 1817 :         } else if (s->match_available) {

  0026a	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  0026e	0f 84 8d 00 00
	00		 je	 $LN9@deflate_sl

; 1818 :             /* If there was no match at the previous position, output a
; 1819 :              * single literal. If there was a match but the current match
; 1820 :              * is longer, truncate the previous match to a single literal.
; 1821 :              */
; 1822 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1823 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00274	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00277	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0027a	8a 44 08 ff	 mov	 al, BYTE PTR [eax+ecx-1]
  0027e	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  00284	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  0028a	33 ff		 xor	 edi, edi
  0028c	66 89 3c 51	 mov	 WORD PTR [ecx+edx*2], di
  00290	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  00296	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  0029c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0029f	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  002a5	0f b6 d0	 movzx	 edx, al
  002a8	66 01 9c 96 94
	00 00 00	 add	 WORD PTR [esi+edx*4+148], bx
  002b0	8d 84 96 94 00
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+148]
  002b7	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  002bd	2b c3		 sub	 eax, ebx
  002bf	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1824 :             if (bflush) {

  002c5	75 2f		 jne	 SHORT $LN8@deflate_sl

; 1825 :                 FLUSH_BLOCK_ONLY(s, 0);

  002c7	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  002ca	85 d2		 test	 edx, edx
  002cc	78 07		 js	 SHORT $LN33@deflate_sl
  002ce	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  002d1	03 ca		 add	 ecx, edx
  002d3	eb 02		 jmp	 SHORT $LN34@deflate_sl
$LN33@deflate_sl:
  002d5	33 c9		 xor	 ecx, ecx
$LN34@deflate_sl:
  002d7	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  002da	6a 00		 push	 0
  002dc	51		 push	 ecx
  002dd	2b c2		 sub	 eax, edx
  002df	8b ce		 mov	 ecx, esi
  002e1	e8 00 00 00 00	 call	 __tr_flush_block
  002e6	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  002e9	8b 3e		 mov	 edi, DWORD PTR [esi]
  002eb	83 c4 08	 add	 esp, 8
  002ee	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  002f1	e8 00 00 00 00	 call	 _flush_pending
$LN8@deflate_sl:

; 1826 :             }
; 1827 :             s->strstart++;

  002f6	01 5e 6c	 add	 DWORD PTR [esi+108], ebx

; 1828 :             s->lookahead--;

  002f9	ff 4e 74	 dec	 DWORD PTR [esi+116]

; 1830 :         } else {

  002fc	e9 56 ff ff ff	 jmp	 $LN53@deflate_sl
$LN9@deflate_sl:

; 1831 :             /* There is no previous match to compare with, wait for
; 1832 :              * the next step to decide.
; 1833 :              */
; 1834 :             s->match_available = 1;
; 1835 :             s->strstart++;

  00301	01 5e 6c	 add	 DWORD PTR [esi+108], ebx

; 1836 :             s->lookahead--;

  00304	ff 4e 74	 dec	 DWORD PTR [esi+116]
  00307	89 5e 68	 mov	 DWORD PTR [esi+104], ebx

; 1837 :         }
; 1838 :     }

  0030a	e9 01 fd ff ff	 jmp	 $LL26@deflate_sl
$LN45@deflate_sl:

; 1839 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1840 :     if (s->match_available) {

  0030f	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00313	74 46		 je	 SHORT $LN5@deflate_sl

; 1841 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1842 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00315	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00318	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0031b	8a 44 08 ff	 mov	 al, BYTE PTR [eax+ecx-1]
  0031f	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  00325	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  0032b	33 ff		 xor	 edi, edi
  0032d	66 89 3c 51	 mov	 WORD PTR [ecx+edx*2], di
  00331	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  00337	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  0033d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00340	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  00346	0f b6 d0	 movzx	 edx, al
  00349	66 01 9c 96 94
	00 00 00	 add	 WORD PTR [esi+edx*4+148], bx
  00351	8d 84 96 94 00
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+148]

; 1843 :         s->match_available = 0;

  00358	89 7e 68	 mov	 DWORD PTR [esi+104], edi
$LN5@deflate_sl:

; 1844 :     }
; 1845 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  0035b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0035e	8b c8		 mov	 ecx, eax
  00360	83 f8 02	 cmp	 eax, 2
  00363	72 05		 jb	 SHORT $LN36@deflate_sl
  00365	b9 02 00 00 00	 mov	 ecx, 2
$LN36@deflate_sl:

; 1846 :     if (flush == Z_FINISH) {

  0036a	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0036e	89 8e b4 16 00
	00		 mov	 DWORD PTR [esi+5812], ecx
  00374	75 3d		 jne	 SHORT $LN4@deflate_sl

; 1847 :         FLUSH_BLOCK(s, 1);

  00376	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00379	85 d2		 test	 edx, edx
  0037b	78 07		 js	 SHORT $LN37@deflate_sl
  0037d	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00380	03 ca		 add	 ecx, edx
  00382	eb 02		 jmp	 SHORT $LN38@deflate_sl
$LN37@deflate_sl:
  00384	33 c9		 xor	 ecx, ecx
$LN38@deflate_sl:
  00386	53		 push	 ebx
  00387	51		 push	 ecx
  00388	2b c2		 sub	 eax, edx
  0038a	8b ce		 mov	 ecx, esi
  0038c	e8 00 00 00 00	 call	 __tr_flush_block
  00391	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00394	8b 3e		 mov	 edi, DWORD PTR [esi]
  00396	83 c4 08	 add	 esp, 8
  00399	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0039c	e8 00 00 00 00	 call	 _flush_pending
  003a1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003a3	33 c0		 xor	 eax, eax
  003a5	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  003a8	5f		 pop	 edi
  003a9	0f 95 c0	 setne	 al
  003ac	5e		 pop	 esi
  003ad	5b		 pop	 ebx
  003ae	83 c0 02	 add	 eax, 2

; 1853 : }

  003b1	5d		 pop	 ebp
  003b2	c3		 ret	 0
$LN4@deflate_sl:

; 1848 :         return finish_done;
; 1849 :     }
; 1850 :     if (s->last_lit)

  003b3	83 be a0 16 00
	00 00		 cmp	 DWORD PTR [esi+5792], 0
  003ba	74 38		 je	 SHORT $LN1@deflate_sl

; 1851 :         FLUSH_BLOCK(s, 0);

  003bc	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  003bf	85 d2		 test	 edx, edx
  003c1	78 07		 js	 SHORT $LN39@deflate_sl
  003c3	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  003c6	03 ca		 add	 ecx, edx
  003c8	eb 02		 jmp	 SHORT $LN40@deflate_sl
$LN39@deflate_sl:
  003ca	33 c9		 xor	 ecx, ecx
$LN40@deflate_sl:
  003cc	6a 00		 push	 0
  003ce	51		 push	 ecx
  003cf	2b c2		 sub	 eax, edx
  003d1	8b ce		 mov	 ecx, esi
  003d3	e8 00 00 00 00	 call	 __tr_flush_block
  003d8	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  003db	8b 3e		 mov	 edi, DWORD PTR [esi]
  003dd	83 c4 08	 add	 esp, 8
  003e0	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  003e3	e8 00 00 00 00	 call	 _flush_pending
  003e8	8b 06		 mov	 eax, DWORD PTR [esi]
  003ea	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  003ee	0f 84 6f fe ff
	ff		 je	 $LN47@deflate_sl
$LN1@deflate_sl:
  003f4	5f		 pop	 edi
  003f5	5e		 pop	 esi

; 1852 :     return block_done;

  003f6	8b c3		 mov	 eax, ebx
  003f8	5b		 pop	 ebx

; 1853 : }

  003f9	5d		 pop	 ebp
  003fa	c3		 ret	 0
_deflate_slow ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _deflate_fast
_TEXT	SEGMENT
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_fast PROC					; COMDAT

; 1631 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00008	57		 push	 edi
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	8b ff		 npad	 2
$LL20@deflate_fa:

; 1632 :     IPos hash_head;       /* head of the hash chain */
; 1633 :     int bflush;           /* set if current block must be flushed */
; 1634 : 
; 1635 :     for (;;) {
; 1636 :         /* Make sure that we always have enough lookahead, except
; 1637 :          * at the end of the input file. We need MAX_MATCH bytes
; 1638 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1639 :          * string following the next match.
; 1640 :          */
; 1641 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00013	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00018	73 23		 jae	 SHORT $LN16@deflate_fa

; 1642 :             fill_window(s);

  0001a	8b fe		 mov	 edi, esi
  0001c	e8 00 00 00 00	 call	 _fill_window

; 1643 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00021	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00024	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00029	73 0a		 jae	 SHORT $LN40@deflate_fa
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  0002f	0f 84 48 02 00
	00		 je	 $LN38@deflate_fa
$LN40@deflate_fa:

; 1644 :                 return need_more;
; 1645 :             }
; 1646 :             if (s->lookahead == 0) break; /* flush the current block */

  00035	85 c0		 test	 eax, eax
  00037	0f 84 47 02 00
	00		 je	 $LN37@deflate_fa
$LN16@deflate_fa:

; 1647 :         }
; 1648 : 
; 1649 :         /* Insert the string window[strstart .. strstart+2] in the
; 1650 :          * dictionary, and set hash_head to the head of the hash chain:
; 1651 :          */
; 1652 :         hash_head = NIL;
; 1653 :         if (s->lookahead >= MIN_MATCH) {

  0003d	83 f8 03	 cmp	 eax, 3
  00040	72 6c		 jb	 SHORT $LN41@deflate_fa

; 1654 :             INSERT_STRING(s, s->strstart, hash_head);

  00042	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00045	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00048	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  0004b	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  0004e	d3 e0		 shl	 eax, cl
  00050	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00053	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  00058	33 c1		 xor	 eax, ecx
  0005a	23 46 54	 and	 eax, DWORD PTR [esi+84]
  0005d	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00060	23 fa		 and	 edi, edx
  00062	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00065	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00068	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  0006c	66 89 04 7a	 mov	 WORD PTR [edx+edi*2], ax
  00070	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00073	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  00076	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00079	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0007d	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00080	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00083	66 8b 7e 6c	 mov	 di, WORD PTR [esi+108]
  00087	66 89 3c 4a	 mov	 WORD PTR [edx+ecx*2], di

; 1655 :         }
; 1656 : 
; 1657 :         /* Find the longest match, discarding those <= prev_length.
; 1658 :          * At this point we have always match_length < MIN_MATCH
; 1659 :          */
; 1660 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  0008b	85 c0		 test	 eax, eax
  0008d	74 1f		 je	 SHORT $LN41@deflate_fa
  0008f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00092	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00095	2b c8		 sub	 ecx, eax
  00097	81 ea 06 01 00
	00		 sub	 edx, 262		; 00000106H
  0009d	3b ca		 cmp	 ecx, edx
  0009f	77 0d		 ja	 SHORT $LN41@deflate_fa

; 1661 :             /* To simplify the code, we prevent matches with the string
; 1662 :              * of window index 0 (in particular we have to avoid a match
; 1663 :              * of the string with itself at the start of the input file).
; 1664 :              */
; 1665 :             s->match_length = longest_match (s, hash_head);

  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	e8 00 00 00 00	 call	 _longest_match
  000a8	83 c4 08	 add	 esp, 8
  000ab	89 46 60	 mov	 DWORD PTR [esi+96], eax
$LN41@deflate_fa:

; 1666 :             /* longest_match() sets match_start */
; 1667 :         }
; 1668 :         if (s->match_length >= MIN_MATCH) {

  000ae	83 7e 60 03	 cmp	 DWORD PTR [esi+96], 3
  000b2	0f 82 25 01 00
	00		 jb	 $LN13@deflate_fa

; 1669 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1670 : 
; 1671 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1672 :                            s->match_length - MIN_MATCH, bflush);

  000b8	66 8b 4e 6c	 mov	 cx, WORD PTR [esi+108]
  000bc	66 2b 4e 70	 sub	 cx, WORD PTR [esi+112]
  000c0	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  000c6	8a 46 60	 mov	 al, BYTE PTR [esi+96]
  000c9	8b be a4 16 00
	00		 mov	 edi, DWORD PTR [esi+5796]
  000cf	0f b7 c9	 movzx	 ecx, cx
  000d2	66 89 0c 57	 mov	 WORD PTR [edi+edx*2], cx
  000d6	8b 96 98 16 00
	00		 mov	 edx, DWORD PTR [esi+5784]
  000dc	8b be a0 16 00
	00		 mov	 edi, DWORD PTR [esi+5792]
  000e2	2c 03		 sub	 al, 3
  000e4	88 04 3a	 mov	 BYTE PTR [edx+edi], al
  000e7	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR __length_code[eax]
  000f7	66 01 9c 96 98
	04 00 00	 add	 WORD PTR [esi+edx*4+1176], bx
  000ff	8d 84 96 98 04
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+1176]
  00106	81 c1 ff ff 00
	00		 add	 ecx, 65535		; 0000ffffH
  0010c	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00111	66 3b c8	 cmp	 cx, ax
  00114	73 0c		 jae	 SHORT $LN23@deflate_fa
  00116	0f b7 c9	 movzx	 ecx, cx
  00119	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[ecx]
  00120	eb 0d		 jmp	 SHORT $LN24@deflate_fa
$LN23@deflate_fa:
  00122	0f b7 d1	 movzx	 edx, cx
  00125	c1 ea 07	 shr	 edx, 7
  00128	0f b6 82 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[edx+256]
$LN24@deflate_fa:
  0012f	66 01 9c 86 88
	09 00 00	 add	 WORD PTR [esi+eax*4+2440], bx
  00137	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  0013d	33 c9		 xor	 ecx, ecx
  0013f	2b c3		 sub	 eax, ebx
  00141	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1673 : 
; 1674 :             s->lookahead -= s->match_length;

  00147	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  0014a	0f 94 c1	 sete	 cl
  0014d	29 46 74	 sub	 DWORD PTR [esi+116], eax
  00150	8b f9		 mov	 edi, ecx
  00152	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]

; 1675 : 
; 1676 :             /* Insert new strings in the hash table only if the match length
; 1677 :              * is not too large. This saves time but degrades compression.
; 1678 :              */
; 1679 : #ifndef FASTEST
; 1680 :             if (s->match_length <= s->max_insert_length &&
; 1681 :                 s->lookahead >= MIN_MATCH) {

  00155	3b 86 80 00 00
	00		 cmp	 eax, DWORD PTR [esi+128]
  0015b	77 57		 ja	 SHORT $LN12@deflate_fa
  0015d	83 f9 03	 cmp	 ecx, 3
  00160	72 52		 jb	 SHORT $LN12@deflate_fa

; 1682 :                 s->match_length--; /* string at strstart already in table */

  00162	48		 dec	 eax
  00163	89 46 60	 mov	 DWORD PTR [esi+96], eax
$LL39@deflate_fa:

; 1683 :                 do {
; 1684 :                     s->strstart++;

  00166	01 5e 6c	 add	 DWORD PTR [esi+108], ebx
  00169	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]

; 1685 :                     INSERT_STRING(s, s->strstart, hash_head);

  0016c	8b 5e 48	 mov	 ebx, DWORD PTR [esi+72]
  0016f	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00172	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00175	0f b6 44 02 02	 movzx	 eax, BYTE PTR [edx+eax+2]
  0017a	d3 e3		 shl	 ebx, cl
  0017c	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0017f	33 c3		 xor	 eax, ebx
  00181	23 46 54	 and	 eax, DWORD PTR [esi+84]
  00184	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  00187	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0018a	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0018e	23 da		 and	 ebx, edx
  00190	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00193	66 89 04 5a	 mov	 WORD PTR [edx+ebx*2], ax
  00197	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  0019b	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0019e	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  001a1	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 1686 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1687 :                      * always MIN_MATCH bytes ahead.
; 1688 :                      */
; 1689 :                 } while (--s->match_length != 0);

  001a5	ff 4e 60	 dec	 DWORD PTR [esi+96]

; 1690 :                 s->strstart++;

  001a8	bb 01 00 00 00	 mov	 ebx, 1
  001ad	75 b7		 jne	 SHORT $LL39@deflate_fa

; 1691 :             } else

  001af	e9 83 00 00 00	 jmp	 $LN42@deflate_fa
$LN12@deflate_fa:

; 1692 : #endif
; 1693 :             {
; 1694 :                 s->strstart += s->match_length;

  001b4	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1695 :                 s->match_length = 0;
; 1696 :                 s->ins_h = s->window[s->strstart];

  001b7	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  001ba	03 56 6c	 add	 edx, DWORD PTR [esi+108]

; 1697 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  001bd	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001c0	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  001c7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001ca	89 46 48	 mov	 DWORD PTR [esi+72], eax
  001cd	d3 e0		 shl	 eax, cl
  001cf	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  001d3	33 c1		 xor	 eax, ecx
  001d5	23 46 54	 and	 eax, DWORD PTR [esi+84]
  001d8	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 1698 : #if MIN_MATCH != 3
; 1699 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1700 : #endif
; 1701 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1702 :                  * matter since it will be recomputed at next deflate call.
; 1703 :                  */
; 1704 :             }
; 1705 :         } else {

  001db	eb 5d		 jmp	 SHORT $LN7@deflate_fa
$LN13@deflate_fa:

; 1706 :             /* No match, output a literal byte */
; 1707 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1708 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001dd	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  001e0	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001e3	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001e6	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  001ec	8b 96 a4 16 00
	00		 mov	 edx, DWORD PTR [esi+5796]
  001f2	33 ff		 xor	 edi, edi
  001f4	66 89 3c 4a	 mov	 WORD PTR [edx+ecx*2], di
  001f8	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]
  001fe	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00204	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00207	01 9e a0 16 00
	00		 add	 DWORD PTR [esi+5792], ebx
  0020d	0f b6 c0	 movzx	 eax, al
  00210	66 01 9c 86 94
	00 00 00	 add	 WORD PTR [esi+eax*4+148], bx
  00218	8b 8e 9c 16 00
	00		 mov	 ecx, DWORD PTR [esi+5788]
  0021e	8d 84 86 94 00
	00 00		 lea	 eax, DWORD PTR [esi+eax*4+148]
  00225	33 d2		 xor	 edx, edx
  00227	2b cb		 sub	 ecx, ebx
  00229	39 8e a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], ecx
  0022f	0f 94 c2	 sete	 dl

; 1709 :             s->lookahead--;

  00232	ff 4e 74	 dec	 DWORD PTR [esi+116]
  00235	8b fa		 mov	 edi, edx
$LN42@deflate_fa:

; 1710 :             s->strstart++;

  00237	01 5e 6c	 add	 DWORD PTR [esi+108], ebx
$LN7@deflate_fa:

; 1711 :         }
; 1712 :         if (bflush) FLUSH_BLOCK(s, 0);

  0023a	85 ff		 test	 edi, edi
  0023c	0f 84 ce fd ff
	ff		 je	 $LL20@deflate_fa
  00242	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00245	85 d2		 test	 edx, edx
  00247	78 07		 js	 SHORT $LN25@deflate_fa
  00249	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0024c	03 ca		 add	 ecx, edx
  0024e	eb 02		 jmp	 SHORT $LN26@deflate_fa
$LN25@deflate_fa:
  00250	33 c9		 xor	 ecx, ecx
$LN26@deflate_fa:
  00252	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00255	6a 00		 push	 0
  00257	51		 push	 ecx
  00258	2b c2		 sub	 eax, edx
  0025a	8b ce		 mov	 ecx, esi
  0025c	e8 00 00 00 00	 call	 __tr_flush_block
  00261	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00264	8b 3e		 mov	 edi, DWORD PTR [esi]
  00266	83 c4 08	 add	 esp, 8
  00269	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0026c	e8 00 00 00 00	 call	 _flush_pending
  00271	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00273	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00277	0f 85 93 fd ff
	ff		 jne	 $LL20@deflate_fa
$LN38@deflate_fa:
  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	33 c0		 xor	 eax, eax
  00281	5b		 pop	 ebx

; 1722 : }

  00282	5d		 pop	 ebp
  00283	c3		 ret	 0
$LN37@deflate_fa:

; 1713 :     }
; 1714 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00284	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00287	8b c8		 mov	 ecx, eax
  00289	83 f8 02	 cmp	 eax, 2
  0028c	72 05		 jb	 SHORT $LN28@deflate_fa
  0028e	b9 02 00 00 00	 mov	 ecx, 2
$LN28@deflate_fa:

; 1715 :     if (flush == Z_FINISH) {

  00293	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00297	89 8e b4 16 00
	00		 mov	 DWORD PTR [esi+5812], ecx
  0029d	75 3d		 jne	 SHORT $LN4@deflate_fa

; 1716 :         FLUSH_BLOCK(s, 1);

  0029f	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  002a2	85 d2		 test	 edx, edx
  002a4	78 07		 js	 SHORT $LN29@deflate_fa
  002a6	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  002a9	03 ca		 add	 ecx, edx
  002ab	eb 02		 jmp	 SHORT $LN30@deflate_fa
$LN29@deflate_fa:
  002ad	33 c9		 xor	 ecx, ecx
$LN30@deflate_fa:
  002af	53		 push	 ebx
  002b0	51		 push	 ecx
  002b1	2b c2		 sub	 eax, edx
  002b3	8b ce		 mov	 ecx, esi
  002b5	e8 00 00 00 00	 call	 __tr_flush_block
  002ba	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  002bd	8b 3e		 mov	 edi, DWORD PTR [esi]
  002bf	83 c4 08	 add	 esp, 8
  002c2	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  002c5	e8 00 00 00 00	 call	 _flush_pending
  002ca	8b 06		 mov	 eax, DWORD PTR [esi]
  002cc	33 c9		 xor	 ecx, ecx
  002ce	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  002d1	5f		 pop	 edi
  002d2	0f 95 c1	 setne	 cl
  002d5	5e		 pop	 esi
  002d6	5b		 pop	 ebx
  002d7	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]

; 1722 : }

  002da	5d		 pop	 ebp
  002db	c3		 ret	 0
$LN4@deflate_fa:

; 1717 :         return finish_done;
; 1718 :     }
; 1719 :     if (s->last_lit)

  002dc	83 be a0 16 00
	00 00		 cmp	 DWORD PTR [esi+5792], 0
  002e3	74 38		 je	 SHORT $LN1@deflate_fa

; 1720 :         FLUSH_BLOCK(s, 0);

  002e5	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  002e8	85 d2		 test	 edx, edx
  002ea	78 07		 js	 SHORT $LN31@deflate_fa
  002ec	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  002ef	03 ca		 add	 ecx, edx
  002f1	eb 02		 jmp	 SHORT $LN32@deflate_fa
$LN31@deflate_fa:
  002f3	33 c9		 xor	 ecx, ecx
$LN32@deflate_fa:
  002f5	6a 00		 push	 0
  002f7	51		 push	 ecx
  002f8	2b c2		 sub	 eax, edx
  002fa	8b ce		 mov	 ecx, esi
  002fc	e8 00 00 00 00	 call	 __tr_flush_block
  00301	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00304	8b 3e		 mov	 edi, DWORD PTR [esi]
  00306	83 c4 08	 add	 esp, 8
  00309	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0030c	e8 00 00 00 00	 call	 _flush_pending
  00311	8b 06		 mov	 eax, DWORD PTR [esi]
  00313	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00317	0f 84 60 ff ff
	ff		 je	 $LN38@deflate_fa
$LN1@deflate_fa:
  0031d	5f		 pop	 edi
  0031e	5e		 pop	 esi

; 1721 :     return block_done;

  0031f	8b c3		 mov	 eax, ebx
  00321	5b		 pop	 ebx

; 1722 : }

  00322	5d		 pop	 ebp
  00323	c3		 ret	 0
_deflate_fast ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _deflate_stored
_TEXT	SEGMENT
_max_block_size$ = -4					; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_stored PROC					; COMDAT

; 1567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1568 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1569 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1570 :      */
; 1571 :     ulg max_block_size = 0xffff;
; 1572 :     ulg max_start;
; 1573 : 
; 1574 :     if (max_block_size > s->pending_buf_size - 5) {

  00005	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00008	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000b	83 c0 fb	 add	 eax, -5			; fffffffbH
  0000e	57		 push	 edi
  0000f	c7 45 fc ff ff
	00 00		 mov	 DWORD PTR _max_block_size$[ebp], 65535 ; 0000ffffH
  00016	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0001b	73 03		 jae	 SHORT $LL14@deflate_st

; 1575 :         max_block_size = s->pending_buf_size - 5;

  0001d	89 45 fc	 mov	 DWORD PTR _max_block_size$[ebp], eax
$LL14@deflate_st:

; 1576 :     }
; 1577 : 
; 1578 :     /* Copy as much as possible from input to output: */
; 1579 :     for (;;) {
; 1580 :         /* Fill the window as much as possible: */
; 1581 :         if (s->lookahead <= 1) {

  00020	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00023	83 f8 01	 cmp	 eax, 1
  00026	77 12		 ja	 SHORT $LN10@deflate_st

; 1582 : 
; 1583 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1584 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1585 : 
; 1586 :             fill_window(s);

  00028	8b fe		 mov	 edi, esi
  0002a	e8 00 00 00 00	 call	 _fill_window

; 1587 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  0002f	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00032	85 c0		 test	 eax, eax
  00034	0f 84 a9 00 00
	00		 je	 $LN32@deflate_st
$LN10@deflate_st:

; 1588 : 
; 1589 :             if (s->lookahead == 0) break; /* flush the current block */
; 1590 :         }
; 1591 :         Assert(s->block_start >= 0L, "block gone");
; 1592 : 
; 1593 :         s->strstart += s->lookahead;

  0003a	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1594 :         s->lookahead = 0;
; 1595 : 
; 1596 :         /* Emit a stored block if pending_buf will be full: */
; 1597 :         max_start = s->block_start + max_block_size;

  0003d	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  00040	8b 45 fc	 mov	 eax, DWORD PTR _max_block_size$[ebp]

; 1598 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  00043	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00046	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  0004d	8d 04 01	 lea	 eax, DWORD PTR [ecx+eax]
  00050	74 04		 je	 SHORT $LN8@deflate_st
  00052	3b d0		 cmp	 edx, eax
  00054	72 39		 jb	 SHORT $LN7@deflate_st
$LN8@deflate_st:

; 1599 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1600 :             s->lookahead = (uInt)(s->strstart - max_start);

  00056	2b d0		 sub	 edx, eax
  00058	89 56 74	 mov	 DWORD PTR [esi+116], edx

; 1601 :             s->strstart = (uInt)max_start;

  0005b	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 1602 :             FLUSH_BLOCK(s, 0);

  0005e	85 c9		 test	 ecx, ecx
  00060	78 07		 js	 SHORT $LN18@deflate_st
  00062	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00065	03 d1		 add	 edx, ecx
  00067	eb 02		 jmp	 SHORT $LN19@deflate_st
$LN18@deflate_st:
  00069	33 d2		 xor	 edx, edx
$LN19@deflate_st:
  0006b	6a 00		 push	 0
  0006d	2b c1		 sub	 eax, ecx
  0006f	52		 push	 edx
  00070	8b ce		 mov	 ecx, esi
  00072	e8 00 00 00 00	 call	 __tr_flush_block
  00077	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0007a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0007c	83 c4 08	 add	 esp, 8
  0007f	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  00082	e8 00 00 00 00	 call	 _flush_pending
  00087	8b 16		 mov	 edx, DWORD PTR [esi]
  00089	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0008d	74 4c		 je	 SHORT $LN31@deflate_st
$LN7@deflate_st:

; 1603 :         }
; 1604 :         /* Flush if we may have to slide, otherwise block_start may become
; 1605 :          * negative and the data will be gone:
; 1606 :          */
; 1607 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  0008f	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  00092	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00095	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00098	2b c2		 sub	 eax, edx
  0009a	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  000a0	3b c1		 cmp	 eax, ecx
  000a2	0f 82 78 ff ff
	ff		 jb	 $LL14@deflate_st

; 1608 :             FLUSH_BLOCK(s, 0);

  000a8	85 d2		 test	 edx, edx
  000aa	78 07		 js	 SHORT $LN20@deflate_st
  000ac	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000af	03 ca		 add	 ecx, edx
  000b1	eb 02		 jmp	 SHORT $LN21@deflate_st
$LN20@deflate_st:
  000b3	33 c9		 xor	 ecx, ecx
$LN21@deflate_st:
  000b5	6a 00		 push	 0
  000b7	51		 push	 ecx
  000b8	8b ce		 mov	 ecx, esi
  000ba	e8 00 00 00 00	 call	 __tr_flush_block
  000bf	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  000c2	8b 3e		 mov	 edi, DWORD PTR [esi]
  000c4	83 c4 08	 add	 esp, 8
  000c7	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  000ca	e8 00 00 00 00	 call	 _flush_pending
  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000d5	0f 85 45 ff ff
	ff		 jne	 $LL14@deflate_st
$LN31@deflate_st:
  000db	5f		 pop	 edi
  000dc	33 c0		 xor	 eax, eax
  000de	5e		 pop	 esi

; 1619 : }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
$LN32@deflate_st:

; 1587 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  000e6	85 c0		 test	 eax, eax
  000e8	74 f1		 je	 SHORT $LN31@deflate_st

; 1609 :         }
; 1610 :     }
; 1611 :     s->insert = 0;
; 1612 :     if (flush == Z_FINISH) {
; 1613 :         FLUSH_BLOCK(s, 1);

  000ea	8b 56 5c	 mov	 edx, DWORD PTR [esi+92]
  000ed	c7 86 b4 16 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5812], 0
  000f7	83 f8 04	 cmp	 eax, 4
  000fa	75 3f		 jne	 SHORT $LN4@deflate_st
  000fc	85 d2		 test	 edx, edx
  000fe	78 07		 js	 SHORT $LN22@deflate_st
  00100	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00103	03 ca		 add	 ecx, edx
  00105	eb 02		 jmp	 SHORT $LN23@deflate_st
$LN22@deflate_st:
  00107	33 c9		 xor	 ecx, ecx
$LN23@deflate_st:
  00109	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0010c	6a 01		 push	 1
  0010e	51		 push	 ecx
  0010f	2b c2		 sub	 eax, edx
  00111	8b ce		 mov	 ecx, esi
  00113	e8 00 00 00 00	 call	 __tr_flush_block
  00118	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0011b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0011d	83 c4 08	 add	 esp, 8
  00120	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  00123	e8 00 00 00 00	 call	 _flush_pending
  00128	8b 16		 mov	 edx, DWORD PTR [esi]
  0012a	33 c0		 xor	 eax, eax
  0012c	39 42 10	 cmp	 DWORD PTR [edx+16], eax
  0012f	5f		 pop	 edi
  00130	0f 95 c0	 setne	 al
  00133	5e		 pop	 esi
  00134	83 c0 02	 add	 eax, 2

; 1619 : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
$LN4@deflate_st:

; 1614 :         return finish_done;
; 1615 :     }
; 1616 :     if ((long)s->strstart > s->block_start)

  0013b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0013e	3b c2		 cmp	 eax, edx
  00140	7e 35		 jle	 SHORT $LN1@deflate_st

; 1617 :         FLUSH_BLOCK(s, 0);

  00142	85 d2		 test	 edx, edx
  00144	78 07		 js	 SHORT $LN24@deflate_st
  00146	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00149	03 ca		 add	 ecx, edx
  0014b	eb 02		 jmp	 SHORT $LN25@deflate_st
$LN24@deflate_st:
  0014d	33 c9		 xor	 ecx, ecx
$LN25@deflate_st:
  0014f	6a 00		 push	 0
  00151	51		 push	 ecx
  00152	2b c2		 sub	 eax, edx
  00154	8b ce		 mov	 ecx, esi
  00156	e8 00 00 00 00	 call	 __tr_flush_block
  0015b	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0015e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00160	83 c4 08	 add	 esp, 8
  00163	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00166	e8 00 00 00 00	 call	 _flush_pending
  0016b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0016d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00171	0f 84 64 ff ff
	ff		 je	 $LN31@deflate_st
$LN1@deflate_st:
  00177	5f		 pop	 edi

; 1618 :     return block_done;

  00178	b8 01 00 00 00	 mov	 eax, 1
  0017d	5e		 pop	 esi

; 1619 : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_deflate_stored ENDP
_TEXT	ENDS
PUBLIC	_deflate@8
; Function compile flags: /Ogtp
;	COMDAT _deflate@8
_TEXT	SEGMENT
_old_flush$ = -4					; size = 4
tv1136 = 8						; size = 4
_beg$80701 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_deflate@8 PROC						; COMDAT

; 668  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 669  :     int old_flush; /* value of flush param for previous deflate call */
; 670  :     deflate_state *s;
; 671  : 
; 672  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 673  :         flush > Z_BLOCK || flush < 0) {

  00006	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	0f 84 40 08 00
	00		 je	 $LN82@deflate
  00011	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00014	85 f6		 test	 esi, esi
  00016	0f 84 35 08 00
	00		 je	 $LN82@deflate
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  0001f	83 f9 05	 cmp	 ecx, 5
  00022	0f 87 29 08 00
	00		 ja	 $LN82@deflate

; 674  :         return Z_STREAM_ERROR;
; 675  :     }
; 676  :     s = strm->state;
; 677  : 
; 678  :     if (strm->next_out == Z_NULL ||
; 679  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 680  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  00028	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0002c	0f 84 18 08 00
	00		 je	 $LN80@deflate
  00032	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00035	75 0a		 jne	 SHORT $LN79@deflate
  00037	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003b	0f 85 09 08 00
	00		 jne	 $LN80@deflate
$LN79@deflate:
  00041	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00044	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00049	75 09		 jne	 SHORT $LN81@deflate
  0004b	83 f9 04	 cmp	 ecx, 4
  0004e	0f 85 f6 07 00
	00		 jne	 $LN80@deflate
$LN81@deflate:

; 682  :     }
; 683  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  00054	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00058	75 14		 jne	 SHORT $LN78@deflate
  0005a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
  00061	5f		 pop	 edi
  00062	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00067	5e		 pop	 esi

; 976  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN78@deflate:

; 684  : 
; 685  :     s->strm = strm; /* just in case */
; 686  :     old_flush = s->last_flush;

  0006e	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00071	53		 push	 ebx
  00072	89 3e		 mov	 DWORD PTR [esi], edi
  00074	89 55 fc	 mov	 DWORD PTR _old_flush$[ebp], edx

; 687  :     s->last_flush = flush;

  00077	89 4e 28	 mov	 DWORD PTR [esi+40], ecx

; 688  : 
; 689  :     /* Write the header */
; 690  :     if (s->status == INIT_STATE) {

  0007a	bb 01 00 00 00	 mov	 ebx, 1
  0007f	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00082	0f 85 a1 02 00
	00		 jne	 $LN71@deflate

; 691  : #ifdef GZIP
; 692  :         if (s->wrap == 2) {

  00088	ba 02 00 00 00	 mov	 edx, 2
  0008d	39 56 18	 cmp	 DWORD PTR [esi+24], edx
  00090	0f 85 fe 01 00
	00		 jne	 $LN76@deflate

; 693  :             strm->adler = crc32(0L, Z_NULL, 0);

  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 _crc32@12
  000a1	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 694  :             put_byte(s, 31);

  000a4	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000a7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000aa	c6 04 08 1f	 mov	 BYTE PTR [eax+ecx], 31	; 0000001fH
  000ae	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000b1	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 695  :             put_byte(s, 139);

  000b4	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000b7	c6 04 10 8b	 mov	 BYTE PTR [eax+edx], 139	; 0000008bH
  000bb	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000be	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 696  :             put_byte(s, 8);

  000c1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c4	c6 04 08 08	 mov	 BYTE PTR [eax+ecx], 8
  000c8	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 697  :             if (s->gzhead == Z_NULL) {

  000cb	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000ce	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000d1	89 4d 08	 mov	 DWORD PTR tv1136[ebp], ecx
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 89 00 00
	00		 jne	 $LN75@deflate

; 698  :                 put_byte(s, 0);

  000dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000df	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  000e2	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000e5	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 699  :                 put_byte(s, 0);

  000e8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000eb	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000ef	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000f2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 700  :                 put_byte(s, 0);

  000f5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000f8	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
  000fc	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  000ff	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 701  :                 put_byte(s, 0);

  00102	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00105	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  00109	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  0010c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 702  :                 put_byte(s, 0);

  0010f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00112	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
  00116	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 703  :                 put_byte(s, s->level == 9 ? 2 :
; 704  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 705  :                              4 : 0));

  00119	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  0011f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00122	83 f8 09	 cmp	 eax, 9
  00125	75 05		 jne	 SHORT $LN88@deflate
  00127	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0012a	eb 17		 jmp	 SHORT $LN87@deflate
$LN88@deflate:
  0012c	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  00133	7d 09		 jge	 SHORT $LN86@deflate
  00135	83 f8 02	 cmp	 eax, 2
  00138	7c 04		 jl	 SHORT $LN86@deflate
  0013a	33 c0		 xor	 eax, eax
  0013c	eb 05		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  0013e	b8 04 00 00 00	 mov	 eax, 4
$LN87@deflate:
  00143	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00146	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00149	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  0014c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 706  :                 put_byte(s, OS_CODE);

  0014f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00152	c6 04 08 0b	 mov	 BYTE PTR [eax+ecx], 11	; 0000000bH
  00156	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 707  :                 s->status = BUSY_STATE;

  00159	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H

; 708  :             }
; 709  :             else {

  00160	e9 c4 01 00 00	 jmp	 $LN71@deflate
$LN75@deflate:

; 710  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 711  :                             (s->gzhead->hcrc ? 2 : 0) +
; 712  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 713  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 714  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 715  :                         );

  00165	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00168	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0016b	f7 da		 neg	 edx
  0016d	1a d2		 sbb	 dl, dl
  0016f	80 e2 10	 and	 dl, 16			; 00000010H
  00172	f7 d9		 neg	 ecx
  00174	1a c9		 sbb	 cl, cl
  00176	80 e1 02	 and	 cl, 2
  00179	02 d1		 add	 dl, cl
  0017b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0017e	f7 d9		 neg	 ecx
  00180	1a c9		 sbb	 cl, cl
  00182	80 e1 08	 and	 cl, 8
  00185	02 d1		 add	 dl, cl
  00187	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0018a	f7 d9		 neg	 ecx
  0018c	1a c9		 sbb	 cl, cl
  0018e	80 e1 04	 and	 cl, 4
  00191	02 d1		 add	 dl, cl
  00193	83 38 00	 cmp	 DWORD PTR [eax], 0
  00196	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00199	0f 95 c0	 setne	 al
  0019c	02 d0		 add	 dl, al
  0019e	8b 45 08	 mov	 eax, DWORD PTR tv1136[ebp]
  001a1	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  001a4	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  001a7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 716  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  001aa	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001ad	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  001b1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001b4	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  001b7	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 717  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  001ba	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  001bd	0f b6 52 05	 movzx	 edx, BYTE PTR [edx+5]
  001c1	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001c4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c7	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  001ca	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 718  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  001cd	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001d0	0f b6 49 06	 movzx	 ecx, BYTE PTR [ecx+6]
  001d4	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001d7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001da	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  001dd	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 719  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  001e0	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  001e3	0f b6 52 07	 movzx	 edx, BYTE PTR [edx+7]
  001e7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001ea	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001ed	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  001f0	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 720  :                 put_byte(s, s->level == 9 ? 2 :
; 721  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 722  :                              4 : 0));

  001f3	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  001f9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001fc	83 f8 09	 cmp	 eax, 9
  001ff	75 07		 jne	 SHORT $LN92@deflate
  00201	b8 02 00 00 00	 mov	 eax, 2
  00206	eb 17		 jmp	 SHORT $LN91@deflate
$LN92@deflate:
  00208	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  0020f	7d 09		 jge	 SHORT $LN90@deflate
  00211	83 f8 02	 cmp	 eax, 2
  00214	7c 04		 jl	 SHORT $LN90@deflate
  00216	33 c0		 xor	 eax, eax
  00218	eb 05		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  0021a	b8 04 00 00 00	 mov	 eax, 4
$LN91@deflate:
  0021f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00222	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00225	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 723  :                 put_byte(s, s->gzhead->os & 0xff);

  00228	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0022b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0022e	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00231	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00234	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00237	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 724  :                 if (s->gzhead->extra != Z_NULL) {

  0023a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0023d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00241	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00244	74 21		 je	 SHORT $LN73@deflate

; 725  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  00246	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  00249	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0024c	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0024f	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 726  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  00252	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00255	8a 49 15	 mov	 cl, BYTE PTR [ecx+21]
  00258	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0025b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0025e	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00261	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  00264	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
$LN73@deflate:

; 727  :                 }
; 728  :                 if (s->gzhead->hcrc)

  00267	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0026a	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0026e	74 11		 je	 SHORT $LN72@deflate

; 729  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 730  :                                         s->pending);

  00270	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00273	51		 push	 ecx
  00274	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  00277	50		 push	 eax
  00278	51		 push	 ecx
  00279	e8 00 00 00 00	 call	 _crc32@12
  0027e	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN72@deflate:

; 731  :                 s->gzindex = 0;

  00281	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 732  :                 s->status = EXTRA_STATE;

  00288	c7 46 04 45 00
	00 00		 mov	 DWORD PTR [esi+4], 69	; 00000045H

; 733  :             }
; 734  :         }
; 735  :         else

  0028f	e9 95 00 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 736  : #endif
; 737  :         {
; 738  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00294	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00297	83 e9 08	 sub	 ecx, 8
  0029a	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  0029d	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H

; 739  :             uInt level_flags;
; 740  : 
; 741  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  002a3	39 96 88 00 00
	00		 cmp	 DWORD PTR [esi+136], edx
  002a9	7d 20		 jge	 SHORT $LN69@deflate
  002ab	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  002b1	3b c2		 cmp	 eax, edx
  002b3	7c 16		 jl	 SHORT $LN69@deflate

; 743  :             else if (s->level < 6)

  002b5	83 f8 06	 cmp	 eax, 6
  002b8	7d 04		 jge	 SHORT $LN67@deflate

; 744  :                 level_flags = 1;

  002ba	8b c3		 mov	 eax, ebx
  002bc	eb 0f		 jmp	 SHORT $LN64@deflate
$LN67@deflate:

; 745  :             else if (s->level == 6)

  002be	33 d2		 xor	 edx, edx
  002c0	83 f8 06	 cmp	 eax, 6
  002c3	0f 95 c2	 setne	 dl
  002c6	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 746  :                 level_flags = 2;
; 747  :             else
; 748  :                 level_flags = 3;

  002c9	eb 02		 jmp	 SHORT $LN64@deflate
$LN69@deflate:

; 742  :                 level_flags = 0;

  002cb	33 c0		 xor	 eax, eax
$LN64@deflate:

; 749  :             header |= (level_flags << 6);

  002cd	c1 e0 06	 shl	 eax, 6
  002d0	0b c8		 or	 ecx, eax

; 750  :             if (s->strstart != 0) header |= PRESET_DICT;

  002d2	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  002d6	74 03		 je	 SHORT $LN63@deflate
  002d8	83 c9 20	 or	 ecx, 32			; 00000020H
$LN63@deflate:

; 751  :             header += 31 - (header % 31);

  002db	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  002e0	f7 e1		 mul	 ecx
  002e2	2b ca		 sub	 ecx, edx
  002e4	d1 e9		 shr	 ecx, 1
  002e6	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  002e9	c1 e8 04	 shr	 eax, 4

; 752  : 
; 753  :             s->status = BUSY_STATE;
; 754  :             putShortMSB(s, header);

  002ec	03 c3		 add	 eax, ebx
  002ee	8b c8		 mov	 ecx, eax
  002f0	c1 e1 05	 shl	 ecx, 5
  002f3	2b c8		 sub	 ecx, eax
  002f5	8b c6		 mov	 eax, esi
  002f7	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
  002fe	e8 00 00 00 00	 call	 _putShortMSB

; 755  : 
; 756  :             /* Save the adler32 of the preset dictionary: */
; 757  :             if (s->strstart != 0) {

  00303	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  00307	74 12		 je	 SHORT $LN62@deflate

; 758  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  00309	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  0030d	e8 00 00 00 00	 call	 _putShortMSB

; 759  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00312	0f b7 4f 30	 movzx	 ecx, WORD PTR [edi+48]
  00316	e8 00 00 00 00	 call	 _putShortMSB
$LN62@deflate:

; 760  :             }
; 761  :             strm->adler = adler32(0L, Z_NULL, 0);

  0031b	6a 00		 push	 0
  0031d	6a 00		 push	 0
  0031f	6a 00		 push	 0
  00321	e8 00 00 00 00	 call	 _adler32@12
  00326	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN71@deflate:

; 762  :         }
; 763  :     }
; 764  : #ifdef GZIP
; 765  :     if (s->status == EXTRA_STATE) {

  00329	83 7e 04 45	 cmp	 DWORD PTR [esi+4], 69	; 00000045H
  0032d	0f 85 c3 00 00
	00		 jne	 $LN109@deflate

; 766  :         if (s->gzhead->extra != Z_NULL) {

  00333	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00336	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0033a	0f 84 af 00 00
	00		 je	 $LN60@deflate

; 767  :             uInt beg = s->pending;  /* start of bytes to update crc */
; 768  : 
; 769  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  00340	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  00344	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00347	89 4d 08	 mov	 DWORD PTR _beg$80701[ebp], ecx
  0034a	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  0034d	73 69		 jae	 SHORT $LN101@deflate
  0034f	90		 npad	 1
$LL59@deflate:

; 770  :                 if (s->pending == s->pending_buf_size) {

  00350	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00353	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00356	75 34		 jne	 SHORT $LN55@deflate

; 771  :                     if (s->gzhead->hcrc && s->pending > beg)

  00358	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0035b	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0035f	74 19		 je	 SHORT $LN56@deflate
  00361	3b c1		 cmp	 eax, ecx
  00363	76 15		 jbe	 SHORT $LN56@deflate

; 772  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 773  :                                             s->pending - beg);

  00365	2b c1		 sub	 eax, ecx
  00367	50		 push	 eax
  00368	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0036b	03 c1		 add	 eax, ecx
  0036d	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  00370	50		 push	 eax
  00371	51		 push	 ecx
  00372	e8 00 00 00 00	 call	 _crc32@12
  00377	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN56@deflate:

; 774  :                     flush_pending(strm);

  0037a	e8 00 00 00 00	 call	 _flush_pending

; 775  :                     beg = s->pending;

  0037f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00382	8b c8		 mov	 ecx, eax
  00384	89 4d 08	 mov	 DWORD PTR _beg$80701[ebp], ecx

; 776  :                     if (s->pending == s->pending_buf_size)

  00387	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  0038a	74 2c		 je	 SHORT $LN101@deflate
$LN55@deflate:

; 777  :                         break;
; 778  :                 }
; 779  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  0038c	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0038f	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00392	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00395	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00398	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0039b	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl
  0039e	8b 4d 08	 mov	 ecx, DWORD PTR _beg$80701[ebp]
  003a1	b8 01 00 00 00	 mov	 eax, 1
  003a6	01 46 14	 add	 DWORD PTR [esi+20], eax

; 780  :                 s->gzindex++;

  003a9	01 46 20	 add	 DWORD PTR [esi+32], eax
  003ac	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  003af	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  003b3	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  003b6	72 98		 jb	 SHORT $LL59@deflate
$LN101@deflate:

; 781  :             }
; 782  :             if (s->gzhead->hcrc && s->pending > beg)

  003b8	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  003bb	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  003bf	74 1c		 je	 SHORT $LN54@deflate
  003c1	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003c4	3b c1		 cmp	 eax, ecx
  003c6	76 15		 jbe	 SHORT $LN54@deflate

; 783  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 784  :                                     s->pending - beg);

  003c8	2b c1		 sub	 eax, ecx
  003ca	50		 push	 eax
  003cb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003ce	03 c1		 add	 eax, ecx
  003d0	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  003d3	50		 push	 eax
  003d4	51		 push	 ecx
  003d5	e8 00 00 00 00	 call	 _crc32@12
  003da	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN54@deflate:

; 785  :             if (s->gzindex == s->gzhead->extra_len) {

  003dd	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  003e0	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  003e3	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  003e6	75 0e		 jne	 SHORT $LN109@deflate

; 786  :                 s->gzindex = 0;

  003e8	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN60@deflate:

; 787  :                 s->status = NAME_STATE;
; 788  :             }
; 789  :         }
; 790  :         else
; 791  :             s->status = NAME_STATE;

  003ef	c7 46 04 49 00
	00 00		 mov	 DWORD PTR [esi+4], 73	; 00000049H
$LN109@deflate:

; 792  :     }
; 793  :     if (s->status == NAME_STATE) {

  003f6	83 7e 04 49	 cmp	 DWORD PTR [esi+4], 73	; 00000049H
  003fa	0f 85 a1 00 00
	00		 jne	 $LN41@deflate

; 794  :         if (s->gzhead->name != Z_NULL) {

  00400	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00403	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00407	0f 84 8d 00 00
	00		 je	 $LN50@deflate

; 795  :             uInt beg = s->pending;  /* start of bytes to update crc */

  0040d	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
$LL49@deflate:

; 796  :             int val;
; 797  : 
; 798  :             do {
; 799  :                 if (s->pending == s->pending_buf_size) {

  00410	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00413	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00416	75 31		 jne	 SHORT $LN44@deflate

; 800  :                     if (s->gzhead->hcrc && s->pending > beg)

  00418	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0041b	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  0041f	74 19		 je	 SHORT $LN45@deflate
  00421	3b c2		 cmp	 eax, edx
  00423	76 15		 jbe	 SHORT $LN45@deflate

; 801  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 802  :                                             s->pending - beg);

  00425	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  00428	2b c2		 sub	 eax, edx
  0042a	50		 push	 eax
  0042b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0042e	03 c2		 add	 eax, edx
  00430	50		 push	 eax
  00431	51		 push	 ecx
  00432	e8 00 00 00 00	 call	 _crc32@12
  00437	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN45@deflate:

; 803  :                     flush_pending(strm);

  0043a	e8 00 00 00 00	 call	 _flush_pending

; 804  :                     beg = s->pending;

  0043f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00442	8b d0		 mov	 edx, eax

; 805  :                     if (s->pending == s->pending_buf_size) {

  00444	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00447	74 20		 je	 SHORT $LN102@deflate
$LN44@deflate:

; 807  :                         break;
; 808  :                     }
; 809  :                 }
; 810  :                 val = s->gzhead->name[s->gzindex++];

  00449	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0044c	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0044f	8b 5b 1c	 mov	 ebx, DWORD PTR [ebx+28]
  00452	0f b6 1c 0b	 movzx	 ebx, BYTE PTR [ebx+ecx]
  00456	41		 inc	 ecx
  00457	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 811  :                 put_byte(s, val);

  0045a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0045d	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
  00460	ff 46 14	 inc	 DWORD PTR [esi+20]

; 812  :             } while (val != 0);

  00463	85 db		 test	 ebx, ebx
  00465	75 a9		 jne	 SHORT $LL49@deflate
  00467	eb 05		 jmp	 SHORT $LN47@deflate
$LN102@deflate:

; 806  :                         val = 1;

  00469	bb 01 00 00 00	 mov	 ebx, 1
$LN47@deflate:

; 813  :             if (s->gzhead->hcrc && s->pending > beg)

  0046e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00471	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00475	74 1c		 je	 SHORT $LN43@deflate
  00477	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0047a	3b c2		 cmp	 eax, edx
  0047c	76 15		 jbe	 SHORT $LN43@deflate

; 814  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 815  :                                     s->pending - beg);

  0047e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00481	2b c2		 sub	 eax, edx
  00483	50		 push	 eax
  00484	03 ca		 add	 ecx, edx
  00486	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00489	51		 push	 ecx
  0048a	52		 push	 edx
  0048b	e8 00 00 00 00	 call	 _crc32@12
  00490	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN43@deflate:

; 816  :             if (val == 0) {

  00493	85 db		 test	 ebx, ebx
  00495	75 0a		 jne	 SHORT $LN41@deflate

; 817  :                 s->gzindex = 0;

  00497	89 5e 20	 mov	 DWORD PTR [esi+32], ebx
$LN50@deflate:

; 818  :                 s->status = COMMENT_STATE;
; 819  :             }
; 820  :         }
; 821  :         else
; 822  :             s->status = COMMENT_STATE;

  0049a	c7 46 04 5b 00
	00 00		 mov	 DWORD PTR [esi+4], 91	; 0000005bH
$LN41@deflate:

; 823  :     }
; 824  :     if (s->status == COMMENT_STATE) {

  004a1	83 7e 04 5b	 cmp	 DWORD PTR [esi+4], 91	; 0000005bH
  004a5	0f 85 a3 00 00
	00		 jne	 $LN30@deflate

; 825  :         if (s->gzhead->comment != Z_NULL) {

  004ab	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  004ae	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  004b2	0f 84 8f 00 00
	00		 je	 $LN39@deflate

; 826  :             uInt beg = s->pending;  /* start of bytes to update crc */

  004b8	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  004bb	eb 03 8d 49 00	 npad	 5
$LL38@deflate:

; 827  :             int val;
; 828  : 
; 829  :             do {
; 830  :                 if (s->pending == s->pending_buf_size) {

  004c0	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  004c3	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  004c6	75 31		 jne	 SHORT $LN33@deflate

; 831  :                     if (s->gzhead->hcrc && s->pending > beg)

  004c8	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  004cb	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  004cf	74 19		 je	 SHORT $LN34@deflate
  004d1	3b c2		 cmp	 eax, edx
  004d3	76 15		 jbe	 SHORT $LN34@deflate

; 832  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 833  :                                             s->pending - beg);

  004d5	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  004d8	2b c2		 sub	 eax, edx
  004da	50		 push	 eax
  004db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004de	03 c2		 add	 eax, edx
  004e0	50		 push	 eax
  004e1	51		 push	 ecx
  004e2	e8 00 00 00 00	 call	 _crc32@12
  004e7	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN34@deflate:

; 834  :                     flush_pending(strm);

  004ea	e8 00 00 00 00	 call	 _flush_pending

; 835  :                     beg = s->pending;

  004ef	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  004f2	8b d0		 mov	 edx, eax

; 836  :                     if (s->pending == s->pending_buf_size) {

  004f4	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  004f7	74 20		 je	 SHORT $LN103@deflate
$LN33@deflate:

; 838  :                         break;
; 839  :                     }
; 840  :                 }
; 841  :                 val = s->gzhead->comment[s->gzindex++];

  004f9	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  004fc	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  004ff	8b 5b 24	 mov	 ebx, DWORD PTR [ebx+36]
  00502	0f b6 1c 0b	 movzx	 ebx, BYTE PTR [ebx+ecx]
  00506	41		 inc	 ecx
  00507	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 842  :                 put_byte(s, val);

  0050a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0050d	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
  00510	ff 46 14	 inc	 DWORD PTR [esi+20]

; 843  :             } while (val != 0);

  00513	85 db		 test	 ebx, ebx
  00515	75 a9		 jne	 SHORT $LL38@deflate
  00517	eb 05		 jmp	 SHORT $LN36@deflate
$LN103@deflate:

; 837  :                         val = 1;

  00519	bb 01 00 00 00	 mov	 ebx, 1
$LN36@deflate:

; 844  :             if (s->gzhead->hcrc && s->pending > beg)

  0051e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00521	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00525	74 1c		 je	 SHORT $LN32@deflate
  00527	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0052a	3b c2		 cmp	 eax, edx
  0052c	76 15		 jbe	 SHORT $LN32@deflate

; 845  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 846  :                                     s->pending - beg);

  0052e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00531	2b c2		 sub	 eax, edx
  00533	50		 push	 eax
  00534	03 ca		 add	 ecx, edx
  00536	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00539	51		 push	 ecx
  0053a	52		 push	 edx
  0053b	e8 00 00 00 00	 call	 _crc32@12
  00540	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN32@deflate:

; 847  :             if (val == 0)

  00543	85 db		 test	 ebx, ebx
  00545	75 07		 jne	 SHORT $LN30@deflate
$LN39@deflate:

; 848  :                 s->status = HCRC_STATE;
; 849  :         }
; 850  :         else
; 851  :             s->status = HCRC_STATE;

  00547	c7 46 04 67 00
	00 00		 mov	 DWORD PTR [esi+4], 103	; 00000067H
$LN30@deflate:

; 852  :     }
; 853  :     if (s->status == HCRC_STATE) {

  0054e	83 7e 04 67	 cmp	 DWORD PTR [esi+4], 103	; 00000067H
  00552	75 59		 jne	 SHORT $LN25@deflate

; 854  :         if (s->gzhead->hcrc) {

  00554	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00557	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0055b	74 49		 je	 SHORT $LN28@deflate

; 855  :             if (s->pending + 2 > s->pending_buf_size)

  0055d	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00560	83 c1 02	 add	 ecx, 2
  00563	3b 4e 0c	 cmp	 ecx, DWORD PTR [esi+12]
  00566	76 05		 jbe	 SHORT $LN27@deflate

; 856  :                 flush_pending(strm);

  00568	e8 00 00 00 00	 call	 _flush_pending
$LN27@deflate:

; 857  :             if (s->pending + 2 <= s->pending_buf_size) {

  0056d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00570	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00573	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00576	77 35		 ja	 SHORT $LN25@deflate

; 858  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  00578	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  0057b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0057e	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 859  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00581	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00584	b9 01 00 00 00	 mov	 ecx, 1
  00589	01 4e 14	 add	 DWORD PTR [esi+20], ecx
  0058c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0058f	8a 5f 31	 mov	 bl, BYTE PTR [edi+49]

; 860  :                 strm->adler = crc32(0L, Z_NULL, 0);

  00592	6a 00		 push	 0
  00594	6a 00		 push	 0
  00596	88 1c 10	 mov	 BYTE PTR [eax+edx], bl
  00599	01 4e 14	 add	 DWORD PTR [esi+20], ecx
  0059c	6a 00		 push	 0
  0059e	e8 00 00 00 00	 call	 _crc32@12
  005a3	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN28@deflate:

; 861  :                 s->status = BUSY_STATE;
; 862  :             }
; 863  :         }
; 864  :         else
; 865  :             s->status = BUSY_STATE;

  005a6	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
$LN25@deflate:

; 866  :     }
; 867  : #endif
; 868  : 
; 869  :     /* Flush as much pending output as possible */
; 870  :     if (s->pending != 0) {

  005ad	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  005b1	74 1d		 je	 SHORT $LN24@deflate

; 871  :         flush_pending(strm);

  005b3	e8 00 00 00 00	 call	 _flush_pending

; 872  :         if (strm->avail_out == 0) {

  005b8	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  005bc	75 5e		 jne	 SHORT $LN106@deflate

; 942  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  005be	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1
$LN13@deflate:
  005c5	5b		 pop	 ebx
  005c6	5f		 pop	 edi

; 943  :               return Z_OK;

  005c7	33 c0		 xor	 eax, eax
  005c9	5e		 pop	 esi

; 976  : }

  005ca	8b e5		 mov	 esp, ebp
  005cc	5d		 pop	 ebp
  005cd	c2 08 00	 ret	 8
$LN24@deflate:

; 873  :             /* Since avail_out is 0, deflate will be called again with
; 874  :              * more output space, but possibly with both pending and
; 875  :              * avail_in equal to zero. There won't be anything to do,
; 876  :              * but this is not an error situation so make sure we
; 877  :              * return OK instead of BUF_ERROR at next call of deflate:
; 878  :              */
; 879  :             s->last_flush = -1;
; 880  :             return Z_OK;
; 881  :         }
; 882  : 
; 883  :     /* Make sure there is something to do and avoid duplicate consecutive
; 884  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 885  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 886  :      */
; 887  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
; 888  :                flush != Z_FINISH) {

  005d0	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  005d4	75 46		 jne	 SHORT $LN106@deflate
  005d6	8b 45 fc	 mov	 eax, DWORD PTR _old_flush$[ebp]
  005d9	33 c9		 xor	 ecx, ecx
  005db	83 f8 04	 cmp	 eax, 4
  005de	0f 9e c1	 setle	 cl
  005e1	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  005e4	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  005e7	8d 1c 00	 lea	 ebx, DWORD PTR [eax+eax]
  005ea	49		 dec	 ecx
  005eb	83 e1 09	 and	 ecx, 9
  005ee	2b d1		 sub	 edx, ecx
  005f0	33 c9		 xor	 ecx, ecx
  005f2	83 f8 04	 cmp	 eax, 4
  005f5	0f 9e c1	 setle	 cl
  005f8	49		 dec	 ecx
  005f9	83 e1 09	 and	 ecx, 9
  005fc	2b d9		 sub	 ebx, ecx
  005fe	3b da		 cmp	 ebx, edx
  00600	7f 1d		 jg	 SHORT $LN108@deflate
  00602	83 f8 04	 cmp	 eax, 4
  00605	74 18		 je	 SHORT $LN108@deflate

; 889  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00607	5b		 pop	 ebx
  00608	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
  0060f	5f		 pop	 edi
  00610	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00615	5e		 pop	 esi

; 976  : }

  00616	8b e5		 mov	 esp, ebp
  00618	5d		 pop	 ebp
  00619	c2 08 00	 ret	 8
$LN106@deflate:

; 873  :             /* Since avail_out is 0, deflate will be called again with
; 874  :              * more output space, but possibly with both pending and
; 875  :              * avail_in equal to zero. There won't be anything to do,
; 876  :              * but this is not an error situation so make sure we
; 877  :              * return OK instead of BUF_ERROR at next call of deflate:
; 878  :              */
; 879  :             s->last_flush = -1;
; 880  :             return Z_OK;
; 881  :         }
; 882  : 
; 883  :     /* Make sure there is something to do and avoid duplicate consecutive
; 884  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 885  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 886  :      */
; 887  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
; 888  :                flush != Z_FINISH) {

  0061c	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
$LN108@deflate:

; 890  :     }
; 891  : 
; 892  :     /* User must not provide more input after the first FINISH: */
; 893  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  0061f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00622	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  00628	75 1b		 jne	 SHORT $LN110@deflate
  0062a	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0062e	74 1b		 je	 SHORT $LN113@deflate

; 894  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00630	5b		 pop	 ebx
  00631	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
  00638	5f		 pop	 edi
  00639	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0063e	5e		 pop	 esi

; 976  : }

  0063f	8b e5		 mov	 esp, ebp
  00641	5d		 pop	 ebp
  00642	c2 08 00	 ret	 8
$LN110@deflate:

; 895  :     }
; 896  : 
; 897  :     /* Start a new block or continue the current one.
; 898  :      */
; 899  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 900  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  00645	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00649	75 1a		 jne	 SHORT $LN18@deflate
$LN113@deflate:
  0064b	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  0064f	75 14		 jne	 SHORT $LN18@deflate
  00651	85 c0		 test	 eax, eax
  00653	0f 84 f4 00 00
	00		 je	 $LN107@deflate
  00659	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  0065f	0f 84 e8 00 00
	00		 je	 $LN107@deflate
$LN18@deflate:

; 901  :         block_state bstate;
; 902  : 
; 903  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 904  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 905  :                         (*(configuration_table[s->level].func))(s, flush));

  00665	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0066b	50		 push	 eax
  0066c	83 f9 02	 cmp	 ecx, 2
  0066f	75 0a		 jne	 SHORT $LN96@deflate
  00671	e8 00 00 00 00	 call	 _deflate_huff
  00676	83 c4 04	 add	 esp, 4
  00679	eb 25		 jmp	 SHORT $LN95@deflate
$LN96@deflate:
  0067b	83 f9 03	 cmp	 ecx, 3
  0067e	75 0a		 jne	 SHORT $LN94@deflate
  00680	e8 00 00 00 00	 call	 _deflate_rle
  00685	83 c4 04	 add	 esp, 4
  00688	eb 16		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  0068a	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00690	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00693	8b 04 95 08 00
	00 00		 mov	 eax, DWORD PTR _configuration_table[edx*4+8]
  0069a	56		 push	 esi
  0069b	ff d0		 call	 eax
  0069d	83 c4 08	 add	 esp, 8
$LN95@deflate:

; 906  : 
; 907  :         if (bstate == finish_started || bstate == finish_done) {

  006a0	83 f8 02	 cmp	 eax, 2
  006a3	74 05		 je	 SHORT $LN16@deflate
  006a5	83 f8 03	 cmp	 eax, 3
  006a8	75 07		 jne	 SHORT $LN17@deflate
$LN16@deflate:

; 908  :             s->status = FINISH_STATE;

  006aa	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH
$LN17@deflate:

; 909  :         }
; 910  :         if (bstate == need_more || bstate == finish_started) {

  006b1	85 c0		 test	 eax, eax
  006b3	0f 84 75 01 00
	00		 je	 $LN14@deflate
  006b9	83 f8 02	 cmp	 eax, 2
  006bc	0f 84 6c 01 00
	00		 je	 $LN14@deflate

; 912  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
; 913  :             }
; 914  :             return Z_OK;
; 915  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 916  :              * of deflate should use the same flush parameter to make sure
; 917  :              * that the flush is complete. So we don't have to output an
; 918  :              * empty block here, this will be done at next call. This also
; 919  :              * ensures that for a very small output buffer, we emit at most
; 920  :              * one empty block.
; 921  :              */
; 922  :         }
; 923  :         if (bstate == block_done) {

  006c2	bb 01 00 00 00	 mov	 ebx, 1
  006c7	3b c3		 cmp	 eax, ebx
  006c9	0f 85 83 00 00
	00		 jne	 $LN6@deflate

; 924  :             if (flush == Z_PARTIAL_FLUSH) {

  006cf	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  006d2	3b c3		 cmp	 eax, ebx
  006d4	75 09		 jne	 SHORT $LN11@deflate

; 925  :                 _tr_align(s);

  006d6	8b c6		 mov	 eax, esi
  006d8	e8 00 00 00 00	 call	 __tr_align
  006dd	eb 51		 jmp	 SHORT $LN7@deflate
$LN11@deflate:

; 926  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  006df	83 f8 05	 cmp	 eax, 5
  006e2	74 4c		 je	 SHORT $LN7@deflate

; 927  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  006e4	6a 00		 push	 0
  006e6	6a 00		 push	 0
  006e8	33 c9		 xor	 ecx, ecx
  006ea	8b c6		 mov	 eax, esi
  006ec	e8 00 00 00 00	 call	 __tr_stored_block
  006f1	83 c4 08	 add	 esp, 8

; 928  :                 /* For a full flush, this empty block will be recognized
; 929  :                  * as a special marker by inflate_sync().
; 930  :                  */
; 931  :                 if (flush == Z_FULL_FLUSH) {

  006f4	83 7d 0c 03	 cmp	 DWORD PTR _flush$[ebp], 3
  006f8	75 36		 jne	 SHORT $LN7@deflate

; 932  :                     CLEAR_HASH(s);             /* forget history */

  006fa	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  006fd	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00700	33 c0		 xor	 eax, eax
  00702	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  00707	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0070a	8d 54 09 fe	 lea	 edx, DWORD PTR [ecx+ecx-2]
  0070e	52		 push	 edx
  0070f	50		 push	 eax
  00710	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00713	50		 push	 eax
  00714	e8 00 00 00 00	 call	 _memset
  00719	83 c4 0c	 add	 esp, 12			; 0000000cH

; 933  :                     if (s->lookahead == 0) {

  0071c	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00720	75 0e		 jne	 SHORT $LN7@deflate

; 934  :                         s->strstart = 0;

  00722	33 c0		 xor	 eax, eax
  00724	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 935  :                         s->block_start = 0L;

  00727	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 936  :                         s->insert = 0;

  0072a	89 86 b4 16 00
	00		 mov	 DWORD PTR [esi+5812], eax
$LN7@deflate:

; 937  :                     }
; 938  :                 }
; 939  :             }
; 940  :             flush_pending(strm);

  00730	e8 00 00 00 00	 call	 _flush_pending

; 941  :             if (strm->avail_out == 0) {

  00735	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00739	75 17		 jne	 SHORT $LN6@deflate

; 942  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  0073b	5b		 pop	 ebx
  0073c	5f		 pop	 edi
  0073d	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1

; 943  :               return Z_OK;

  00744	33 c0		 xor	 eax, eax
  00746	5e		 pop	 esi

; 976  : }

  00747	8b e5		 mov	 esp, ebp
  00749	5d		 pop	 ebp
  0074a	c2 08 00	 ret	 8
$LN107@deflate:

; 941  :             if (strm->avail_out == 0) {

  0074d	bb 01 00 00 00	 mov	 ebx, 1
$LN6@deflate:

; 944  :             }
; 945  :         }
; 946  :     }
; 947  :     Assert(strm->avail_out > 0, "bug2");
; 948  : 
; 949  :     if (flush != Z_FINISH) return Z_OK;

  00752	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00756	0f 85 69 fe ff
	ff		 jne	 $LN13@deflate

; 950  :     if (s->wrap <= 0) return Z_STREAM_END;

  0075c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0075f	85 c0		 test	 eax, eax
  00761	7f 0b		 jg	 SHORT $LN4@deflate
  00763	8b c3		 mov	 eax, ebx
  00765	5b		 pop	 ebx
  00766	5f		 pop	 edi
  00767	5e		 pop	 esi

; 976  : }

  00768	8b e5		 mov	 esp, ebp
  0076a	5d		 pop	 ebp
  0076b	c2 08 00	 ret	 8
$LN4@deflate:

; 951  : 
; 952  :     /* Write the trailer */
; 953  : #ifdef GZIP
; 954  :     if (s->wrap == 2) {

  0076e	83 f8 02	 cmp	 eax, 2
  00771	0f 85 81 00 00
	00		 jne	 $LN3@deflate

; 955  :         put_byte(s, (Byte)(strm->adler & 0xff));

  00777	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0077a	8a 47 30	 mov	 al, BYTE PTR [edi+48]
  0077d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00780	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00783	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 956  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00786	0f b6 57 31	 movzx	 edx, BYTE PTR [edi+49]
  0078a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0078d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00790	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  00793	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 957  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  00796	0f b6 57 32	 movzx	 edx, BYTE PTR [edi+50]
  0079a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0079d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007a0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007a3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 958  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  007a6	0f b6 57 33	 movzx	 edx, BYTE PTR [edi+51]
  007aa	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007ad	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007b0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007b3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 959  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  007b6	0f b6 57 08	 movzx	 edx, BYTE PTR [edi+8]
  007ba	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007bd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007c0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007c3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 960  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  007c6	0f b6 57 09	 movzx	 edx, BYTE PTR [edi+9]
  007ca	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007cd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007d0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007d3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 961  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  007d6	0f b6 57 0a	 movzx	 edx, BYTE PTR [edi+10]
  007da	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007dd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007e0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007e3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 962  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  007e6	0f b6 57 0b	 movzx	 edx, BYTE PTR [edi+11]
  007ea	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007ed	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007f0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  007f3	01 5e 14	 add	 DWORD PTR [esi+20], ebx

; 963  :     }
; 964  :     else

  007f6	eb 14		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 965  : #endif
; 966  :     {
; 967  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  007f8	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  007fc	8b c6		 mov	 eax, esi
  007fe	e8 00 00 00 00	 call	 _putShortMSB

; 968  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00803	0f b7 4f 30	 movzx	 ecx, WORD PTR [edi+48]
  00807	e8 00 00 00 00	 call	 _putShortMSB
$LN2@deflate:

; 969  :     }
; 970  :     flush_pending(strm);

  0080c	e8 00 00 00 00	 call	 _flush_pending

; 971  :     /* If avail_out is zero, the application will call deflate again
; 972  :      * to flush the rest.
; 973  :      */
; 974  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  00811	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00814	85 c0		 test	 eax, eax
  00816	7e 05		 jle	 SHORT $LN1@deflate
  00818	f7 d8		 neg	 eax
  0081a	89 46 18	 mov	 DWORD PTR [esi+24], eax
$LN1@deflate:

; 975  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0081d	33 c0		 xor	 eax, eax
  0081f	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00822	5b		 pop	 ebx
  00823	5f		 pop	 edi
  00824	0f 94 c0	 sete	 al
  00827	5e		 pop	 esi

; 976  : }

  00828	8b e5		 mov	 esp, ebp
  0082a	5d		 pop	 ebp
  0082b	c2 08 00	 ret	 8
$LN14@deflate:

; 911  :             if (strm->avail_out == 0) {

  0082e	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00832	0f 85 8d fd ff
	ff		 jne	 $LN13@deflate

; 942  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  00838	5b		 pop	 ebx
  00839	5f		 pop	 edi
  0083a	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1

; 943  :               return Z_OK;

  00841	33 c0		 xor	 eax, eax
  00843	5e		 pop	 esi

; 976  : }

  00844	8b e5		 mov	 esp, ebp
  00846	5d		 pop	 ebp
  00847	c2 08 00	 ret	 8
$LN80@deflate:

; 681  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0084a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET ??_C@_0N@MKKNPMJD@stream?5error?$AA@
$LN82@deflate:
  00851	5f		 pop	 edi
  00852	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00857	5e		 pop	 esi

; 976  : }

  00858	8b e5		 mov	 esp, ebp
  0085a	5d		 pop	 ebp
  0085b	c2 08 00	 ret	 8
_deflate@8 ENDP
_TEXT	ENDS
PUBLIC	_deflateParams@12
; Function compile flags: /Ogtp
;	COMDAT _deflateParams@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_deflateParams@12 PROC					; COMDAT

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  :     deflate_state *s;
; 496  :     compress_func func;
; 497  :     int err = Z_OK;
; 498  : 
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	85 d2		 test	 edx, edx
  0000b	0f 84 d6 00 00
	00		 je	 $LN8@deflatePar
  00011	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00014	85 f6		 test	 esi, esi
  00016	0f 84 cb 00 00
	00		 je	 $LN8@deflatePar

; 500  :     s = strm->state;
; 501  : 
; 502  : #ifdef FASTEST
; 503  :     if (level != 0) level = 1;
; 504  : #else
; 505  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0001c	57		 push	 edi
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _level$[ebp]
  00020	83 ff ff	 cmp	 edi, -1
  00023	75 05		 jne	 SHORT $LN7@deflatePar
  00025	8d 78 06	 lea	 edi, DWORD PTR [eax+6]

; 506  : #endif
; 507  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00028	eb 11		 jmp	 SHORT $LN13@deflatePar
$LN7@deflatePar:
  0002a	85 ff		 test	 edi, edi
  0002c	0f 88 aa 00 00
	00		 js	 $LN5@deflatePar
  00032	83 ff 09	 cmp	 edi, 9
  00035	0f 8f a1 00 00
	00		 jg	 $LN5@deflatePar
$LN13@deflatePar:
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  0003e	83 f9 04	 cmp	 ecx, 4
  00041	0f 87 95 00 00
	00		 ja	 $LN5@deflatePar

; 511  : 
; 512  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 513  :         strm->total_in != 0) {

  00047	3b 8e 88 00 00
	00		 cmp	 ecx, DWORD PTR [esi+136]
  0004d	75 1e		 jne	 SHORT $LN3@deflatePar

; 509  :     }
; 510  :     func = configuration_table[s->level].func;

  0004f	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00055	53		 push	 ebx
  00056	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]

; 511  : 
; 512  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 513  :         strm->total_in != 0) {

  00059	8b 0c 8d 08 00
	00 00		 mov	 ecx, DWORD PTR _configuration_table[ecx*4+8]
  00060	8d 1c 7f	 lea	 ebx, DWORD PTR [edi+edi*2]
  00063	3b 0c 9d 08 00
	00 00		 cmp	 ecx, DWORD PTR _configuration_table[ebx*4+8]
  0006a	5b		 pop	 ebx
  0006b	74 1a		 je	 SHORT $LN14@deflatePar
$LN3@deflatePar:
  0006d	39 42 08	 cmp	 DWORD PTR [edx+8], eax
  00070	74 15		 je	 SHORT $LN14@deflatePar

; 514  :         /* Flush the last buffer: */
; 515  :         err = deflate(strm, Z_BLOCK);

  00072	6a 05		 push	 5
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _deflate@8

; 516  :         if (err == Z_BUF_ERROR && s->pending == 0)

  0007a	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  0007d	75 08		 jne	 SHORT $LN14@deflatePar
  0007f	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  00083	75 02		 jne	 SHORT $LN14@deflatePar

; 517  :             err = Z_OK;

  00085	33 c0		 xor	 eax, eax
$LN14@deflatePar:

; 518  :     }
; 519  :     if (s->level != level) {

  00087	39 be 84 00 00
	00		 cmp	 DWORD PTR [esi+132], edi
  0008d	74 3e		 je	 SHORT $LN1@deflatePar

; 520  :         s->level = level;
; 521  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  0008f	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00092	03 c9		 add	 ecx, ecx
  00094	03 c9		 add	 ecx, ecx
  00096	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi
  0009c	0f b7 91 02 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[ecx+2]
  000a3	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx

; 522  :         s->good_match       = configuration_table[level].good_length;

  000a9	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[ecx]
  000b0	89 96 8c 00 00
	00		 mov	 DWORD PTR [esi+140], edx

; 523  :         s->nice_match       = configuration_table[level].nice_length;

  000b6	0f b7 91 04 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[ecx+4]
  000bd	89 96 90 00 00
	00		 mov	 DWORD PTR [esi+144], edx

; 524  :         s->max_chain_length = configuration_table[level].max_chain;

  000c3	0f b7 89 06 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[ecx+6]
  000ca	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
$LN1@deflatePar:

; 525  :     }
; 526  :     s->strategy = strategy;

  000cd	8b 55 10	 mov	 edx, DWORD PTR _strategy$[ebp]
  000d0	5f		 pop	 edi
  000d1	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  000d7	5e		 pop	 esi

; 527  :     return err;
; 528  : }

  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
$LN5@deflatePar:
  000dc	5f		 pop	 edi

; 508  :         return Z_STREAM_ERROR;

  000dd	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e2	5e		 pop	 esi

; 527  :     return err;
; 528  : }

  000e3	5d		 pop	 ebp
  000e4	c2 0c 00	 ret	 12			; 0000000cH
$LN8@deflatePar:

; 495  :     deflate_state *s;
; 496  :     compress_func func;
; 497  :     int err = Z_OK;
; 498  : 
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e7	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000ec	5e		 pop	 esi

; 527  :     return err;
; 528  : }

  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
_deflateParams@12 ENDP
END
